<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[使用Python脚本半自动化iOS企业版包更新]]></title>
      <url>%2F2017%2F03%2F25%2F%E4%BD%BF%E7%94%A8Python%E8%84%9A%E6%9C%AC%E5%8D%8A%E8%87%AA%E5%8A%A8%E5%8C%96iOS%E4%BC%81%E4%B8%9A%E7%89%88%E5%8C%85%E6%9B%B4%E6%96%B0%2F</url>
      <content type="text"><![CDATA[背景在我之前一篇文章里 iOS企业内部应用分发 讲述了 iOS 企业帐号打包的 ipa 分发，但是如果每次 ipa 更新，重新上传 *.ipa 后还要手动编辑 *.plist 的新的 ipa 的 url 和包的相关信息，这就和打包一样（使用 fastlane），是毫无技术含量但是花时间的事情，作为一个爱偷懒的人，我总是想利用自身所学或者一些工具来代替我做一些重复又没技术含量的事，在本文涉及的这件事里，显然，脚本要派上用场，最终选用了 Python 而没有用 Bash —- 从 ipa 读取相关信息并写入到目的 plist。Python 只是业余，如您有建议或改进，欢迎留言评论指出，感激不尽！ 直接上代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#!/usr/bin/python3#coding:utf-8 import zipfile, plistlib, sys, re, os.pathglobal plist_root # Info.plistglobal ipa_name # ipa 名称def analyze_ipa_with_plistlib(ipa_path): global plist_root ipa_file = zipfile.ZipFile(ipa_path) plist_path = find_plist_path(ipa_file) plist_data = ipa_file.read(plist_path) plist_root = plistlib.loads(plist_data) print_ipa_info (plist_root) def find_plist_path(zip_file): name_list = zip_file.namelist() pattern = re.compile(r'Payload/[^/]*.app/Info.plist') for path in name_list: m = pattern.match(path) if m is not None: return m.group()def print_ipa_info(plist_root): print ('\n' + '源 ipa 包信息:') CFBundleDisplayName = '' isCFBundleDisplayNameExist = True try: CFBundleDisplayName = plist_root['CFBundleDisplayName'] except: print ('CFBundleDisplayName 不存在，将获取 CFBundleName') isCFBundleDisplayNameExist = False if isCFBundleDisplayNameExist != True: try: CFBundleDisplayName = plist_root['CFBundleName'] except: print ('CFBundleName 不存在') print ('Display Name: %s' % CFBundleDisplayName) print ('Bundle Identifier: %s' % plist_root['CFBundleIdentifier']) print ('Version: %s' % plist_root['CFBundleShortVersionString'] + '\n') def print_plist_info(plist_path, beforeWritten): dict = plistlib.readPlist(plist_path) metadata = dict["items"][0]["metadata"] softwarePackageDict = dict["items"][0]["assets"][0] state = "前" if beforeWritten else "后" print ('写入' + state +'的plist信息') print ('bundle-identifier: %s' % metadata['bundle-identifier']) print ('bundle-version: %s' % metadata['bundle-version']) print ('title: %s' % metadata['title']) print ('ipa url: %s' % softwarePackageDict['url'] + '\n')def writeToPlist(plist_path): global plist_root # 读取app.plist dict = plistlib.readPlist(plist_path) CFBundleDisplayName = '' isCFBundleDisplayNameExist = True try: CFBundleDisplayName = plist_root['CFBundleDisplayName'] except: print ('CFBundleDisplayName 不存在，将获取 CFBundleName') isCFBundleDisplayNameExist = False if isCFBundleDisplayNameExist != True: try: CFBundleDisplayName = plist_root['CFBundleName'] except: print ('CFBundleName 不存在') # 更改包信息 metadata = dict["items"][0]["metadata"] metadata['bundle-identifier'] = plist_root['CFBundleIdentifier'] metadata['bundle-version'] = plist_root['CFBundleShortVersionString'] metadata['title'] = CFBundleDisplayName # 更改ipa地址 softwarePackageDict = dict["items"][0]["assets"][0] # 生成新的 ipa 路径 global ipa_name url = softwarePackageDict['url'] urlComArr = url.split('/') # 删除文件名 urlComArr.pop() # 删除最后一个 urlComArr.append(ipa_name) # 拼接新文件名及扩展名 newUrlComArrStr = '/'.join(urlComArr) # Array to String softwarePackageDict['url'] = newUrlComArrStr plistlib.writePlist(dict, plist_path) # 写入plist if __name__ == '__main__': args = sys.argv[1:] if len(args) != 2: print ('参数错误，用法: python3 config.py /path/to/ipa /path/to/plist') sys.exit(0) global ipa_name ipa_path = args[0] analyze_ipa_with_plistlib(ipa_path) ipa_name = os.path.basename(ipa_path) plist_path = args[1] print_plist_info(plist_path, True) writeToPlist (plist_path) print_plist_info(plist_path, False) 说明每次新打包后，需要更新 plist 文件相关信息，直接在服务器或者本地运行该脚本便可更新 plist 信息，然后覆盖服务器上的同名文件即可（亲手实践过 ipa 分发就没困惑），但运行该脚本的系统应该安装了 Python3，否则无法运行。用法如下，选你的终端执行： 1python3 config.py appName.ipa路径 app.plist路径]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[原生 JavaScript 判断 DOM 是否包含某个 class]]></title>
      <url>%2F2017%2F03%2F23%2F%E5%8E%9F%E7%94%9F-JavaScript-%E5%88%A4%E6%96%AD-DOM-%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E6%9F%90%E4%B8%AA-class%2F</url>
      <content type="text"><![CDATA[使用 classlist 12345678910111213if (document.body.classList.contains('thatClass')) &#123; // do some stuff&#125;Other uses of classList:document.body.classList.add('thisClass');// $('body').addClass('thisClass');document.body.classList.remove('thatClass');// $('body').removeClass('thatClass');document.body.classList.toggle('anotherClass');// $('body').toggleClass('anotherClass'); 简单封装一下12345678function hasClass(el, cn)&#123; var classes = el.classList; for(var j = 0; j &lt; classes.length; j++)&#123; if(classes[j] == cn)&#123; return true; &#125; &#125;&#125; 支持IE812345function hasClass(el, cls) &#123; var regexp = new RegExp('(\\s|^)' + cls + '(\\s|$)'), target = (typeof el.className === 'undefined') ? window.event.srcElement : el; return target.className.match(regexp);&#125; 浏览器支持 Chrome 8.0 Firefox 3.6 IE 10 Opera 11.50 Safari 5.1]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS 企业版应用一键更新]]></title>
      <url>%2F2017%2F03%2F22%2FiOS-%E4%BC%81%E4%B8%9A%E7%89%88%E5%BA%94%E7%94%A8%E4%B8%80%E9%94%AE%E6%9B%B4%E6%96%B0%2F</url>
      <content type="text"><![CDATA[如果后台没有获取版本号的接口，自己就直接从下载企业版应用指向的 plist 文件中获取吧，如果有，就不用这么麻烦还要去下载整个 plist 文件了，直接根据拿到的版本好与本地对比即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#pragma mark -#pragma mark 检查更新- (void)checkForUpdating &#123; // 先清空之前下载的缓存文件 NSString *tmpDirectory = NSTemporaryDirectory(); NSFileManager *fileManager = [NSFileManager defaultManager]; NSError *error; NSArray *cacheFiles = [fileManager contentsOfDirectoryAtPath:tmpDirectory error:&amp;error]; for (NSString *file in cacheFiles) &#123; error = nil; [fileManager removeItemAtPath:[tmpDirectory stringByAppendingPathComponent:file] error:&amp;error]; &#125; // 从服务器下载plist文件 NSURLRequest *downloadRequest = [NSURLRequest requestWithURL:[NSURL URLWithString:CheckUpdatingPlistUrl]]; NSURLSessionConfiguration *sessionConfig = [NSURLSessionConfiguration defaultSessionConfiguration]; NSURLSession *urlSession = [NSURLSession sessionWithConfiguration:sessionConfig delegate:nil delegateQueue:nil]; NSURLSessionDownloadTask *task = [urlSession downloadTaskWithRequest:downloadRequest completionHandler:^(NSURL * _Nullable location, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123; if (error) &#123; WJLog(@"获取下载服务器版本失败:\n%@", error.localizedDescription); &#125; else &#123; NSDictionary *dict = [NSDictionary dictionaryWithContentsOfURL:location]; // 服务器版本号 NSString *serverVersion = dict[@"items"][0][@"metadata"][@"bundle-version"]; // 本地版本号 NSString *localVersion = [[NSBundle mainBundle] infoDictionary][@"CFBundleShortVersionString"]; // 对比版本号，升序 if ([localVersion compare:serverVersion options:NSNumericSearch] == NSOrderedAscending) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; // 先提示安装 FCAlertView *alert = [[FCAlertView alloc] init]; [alert showAlertWithTitle:@"提示" withSubtitle:@"新版本已发布，点击确定开始更新" withCustomImage:nil withDoneButtonTitle:nil andButtons:nil]; alert.hideDoneButton = YES; alert.bounceAnimations = YES; alert.colorScheme = alert.flatOrange; [alert makeAlertTypeCaution]; alert.subTitleColor = [UIColor redColor]; [alert addButton:@"确定" withActionBlock:^&#123; // 模拟器不支持 if (TARGET_IPHONE_SIMULATOR) &#123; WJLog(@"模拟器不支持该操作"); return; &#125; // 真机执行安装 NSURL *url = [NSURL URLWithString:[NSString stringWithFormat:@"itms-services://?action=download-manifest&amp;url=%@", CheckUpdatingPlistUrl]]; [[UIApplication sharedApplication] openURL:url]; // 动画退出App UIWindow *window = [UIApplication sharedApplication].keyWindow; [UIView animateWithDuration:.5f animations:^&#123; window.alpha = 0; CGFloat width = window.bounds.size.width; CGFloat height = window.bounds.size.height; window.frame = CGRectMake(width * 0.5, height * 0.5, 0, 0); &#125; completion:^(BOOL finished) &#123; exit(0); &#125;]; &#125;]; [alert addButton:@"下次再说" withActionBlock:nil]; &#125;); &#125; &#125; &#125;]; [task resume];&#125; 那个 FCAlertView 没有可以用原生的，比如： 123456789101112131415161718192021222324252627282930313233343536// 对比版本号，升序if ([localVersion compare:serverVersion options:NSNumericSearch] == NSOrderedAscending) &#123; __weak typeof(self) weakSelf = self; dispatch_async(dispatch_get_main_queue(), ^&#123; // 先提示安装 UIAlertController *alertVc = [UIAlertController alertControllerWithTitle:@"提示" message:@"新版本已发布，点击确定开始更新" preferredStyle:UIAlertControllerStyleAlert]; UIAlertAction *confirmAct = [UIAlertAction actionWithTitle:@"确定" style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) &#123; // 模拟器不支持 if (TARGET_IPHONE_SIMULATOR) &#123; WJLog(@"模拟器不支持该操作"); return; &#125; // 真机执行安装 NSURL *url = [NSURL URLWithString:[NSString stringWithFormat:@"itms-services://?action=download-manifest&amp;url=%@", CheckUpdatingPlistUrl]]; [[UIApplication sharedApplication] openURL:url]; // 动画退出App UIWindow *window = [UIApplication sharedApplication].keyWindow; [UIView animateWithDuration:.5f animations:^&#123; window.alpha = 0; CGFloat width = window.bounds.size.width; CGFloat height = window.bounds.size.height; window.frame = CGRectMake(width * 0.5, height * 0.5, 0, 0); &#125; completion:^(BOOL finished) &#123; exit(0); &#125;]; &#125;]; // 取消 UIAlertAction *cancelAct = [UIAlertAction actionWithTitle:@"下次再说" style:UIAlertActionStyleDefault handler:nil]; [alertVc addAction:confirmAct]; [alertVc addAction:cancelAct]; [weakSelf.window.rootViewController presentViewController:alertVc animated:YES completion:nil]; &#125;);&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[为 NexT 主题添加球型标签云]]></title>
      <url>%2F2017%2F03%2F19%2F%E4%B8%BA-NexT-%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E7%90%83%E5%BD%A2%E6%A0%87%E7%AD%BE%E4%BA%91%2F</url>
      <content type="text"><![CDATA[确定你已开启标签功能参考 NexT 配置文档 添加标签页面 ，开启标签功能。 了解球形标签云插件了解球形标签云 javascript 插件，点击这里 下载插件下载 js 插件 tagcanvas.js 放入对应目录将下载的 tagcanvas.js 放入主题目录 themes/NexT/source/js/custom/tagcanvas.js，custom 为新建文件夹。 新建标签云文件，引用 js在 themes/NexT/layout/_partials 下建一个 plugin 文件夹，在该目录下 touch 一个名为 tagcanvas.swig 的文件，并写入如下内容： 1234567891011121314151617181920212223242526272829303132333435363738&lt;div class="tags" id="myTags"&gt; &lt;canvas width="350" height="350" id="my3DTags"&gt; &lt;p&gt;Anything in here will be replaced on browsers that support the canvas element&lt;/p&gt; &lt;/canvas&gt;&lt;/div&gt;&lt;div class="tags" id="tags"&gt; &lt;ul style="display: none"&gt; &#123;&#123; tagcloud(&#123; min_font: 16, max_font: 35, amount: 999, color: true, start_color: 'red', end_color: 'red', &#125;) &#125;&#125; &lt;/ul&gt;&lt;/div&gt;&lt;script type="text/javascript" src="/js/custom/tagcanvas.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" &gt; window.onload = function() &#123; try &#123; TagCanvas.Start('my3DTags','tags',&#123; textFont: 'Georgia,Optima', textColour: null, outlineColour: 'black', weight: true, reverse: true, depth: 0.8, maxSpeed: 0.05, bgRadius: 1, freezeDecel: true &#125;); &#125; catch(e) &#123; // something went wrong, hide the canvas container document.getElementById('myTags').style.display = 'none'; &#125; &#125;;&lt;/script&gt; 使用 tagcanvas.swig在 themes/NexT/layout/page.swig 中作如下修改： 替换红框中原来位置的 div 标签为如下： 12&#123;# tagcanvas plugin 球型云标签 #&#125;&#123;% include '_partials/plugin/tagcanvas.swig' %&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mac 彻底卸载 MYSQL 解决疑难杂症]]></title>
      <url>%2F2017%2F03%2F18%2FMac-%E5%BD%BB%E5%BA%95%E5%8D%B8%E8%BD%BD-MYSQL-%E8%A7%A3%E5%86%B3%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87%2F</url>
      <content type="text"><![CDATA[备份数据库备份看个人了，可以用软件如 Navicat 导出，也可以用 mysqldump 命令导出。 kill mysql相关进程终端运行 ps -ax | grep mysql 查看 mysql 相关进程， 有的话 kill 卸载 Homebrew 安装的mysql卸载全部以前用 brew 安装 的 mysql，先 brew list 查看安装的 mysql 版本，假如列出了 mysql@5.5， 则运行 brew uninstall mysql@5.5，卸载完后执行 brew cleanup。 移除残留文件删除与 mysql 相关的文件 12345sudo rm /usr/local/mysql;sudo rm -rf /usr/local/var/mysql;sudo rm -rf /usr/local/mysql*;sudo rm -rf /Library/StartupItems/MySQLCOM;sudo rm -rf /Library/PreferencePanes/My* 移除残留自动登陆项移除自动登陆项，如果你安装过 DMG 版本的 mysql，则把以下命令中的 LaunchAgents 替换为 LaunchDaemons 再执行一次 1launchctl unload -w ~/Library/LaunchAgents/homebrew.mxcl.mysql.plist unload 之后再删除该文件， 123sudo rm ~/Library/LaunchAgents/homebrew.mxcl.mysql.plist或sudo rm ~/Library/LaunchDaemons/homebrew.mxcl.mysql.plist 移除残留配置subl /etc/hostconfig ` 后输入 Remove the line MYSQLCOM=-YES- ` 移除残留偏好设置1234rm -rf ~/Library/PreferencePanes/My*;sudo rm -rf /Library/Receipts/mysql*;sudo rm -rf /Library/Receipts/MySQL*;sudo rm -rf /private/var/db/receipts/*mysql* 重启电脑，重新安装 mysql建议使用 Homebrew 安装 12brew search mysqlbrew install 你要的版本 启动 mysql1mysql.server start 如果报 commond not found，则在 ~/.zshrc 或者 ~/.bashrc 中加入以下两行（注意替换mysql路径）： 12export MYSQL=/usr/local/Cellar/mysql@5.6/5.6.35/support-filesexport PATH=$MYSQL:$PATH]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo 中为多说添加最近访客]]></title>
      <url>%2F2017%2F03%2F17%2FHexo-%E4%B8%AD%E4%B8%BA%E5%A4%9A%E8%AF%B4%E6%B7%BB%E5%8A%A0%E6%9C%80%E8%BF%91%E8%AE%BF%E5%AE%A2%2F</url>
      <content type="text"><![CDATA[添加自定义样式1. 多说后台添加到多说后台管理-&gt;设置-&gt;基本设置-&gt;自定义css中添加如下css样式： 1234567891011121314151617181920212223242526272829303132333435363738#ds-reset .ds-avatar img,#ds-recent-visitors .ds-avatar img &#123;width: 54px;height: 54px; /*设置图像的长和宽，这里要根据自己的评论框情况更改*/border-radius: 27px; /*设置图像圆角效果,在这里我直接设置了超过width/2的像素，即为圆形了*/-webkit-border-radius: 27px; /*圆角效果：兼容webkit浏览器*/-moz-border-radius: 27px;box-shadow: inset 0 -1px 0 #3333sf; /*设置图像阴影效果*/-webkit-box-shadow: inset 0 -1px 0 #3333sf;-webkit-transition: 0.4s;-webkit-transition: -webkit-transform 0.4s ease-out;transition: transform 0.4s ease-out; /*变化时间设置为0.4秒(变化动作即为下面的图像旋转360读）*/-moz-transition: -moz-transform 0.4s ease-out;&#125;#ds-reset .ds-avatar img:hover,#ds-recent-visitors .ds-avatar img:hover &#123;/*设置鼠标悬浮在头像时的CSS样式*/ box-shadow: 0 0 10px #fff;rgba(255, 255, 255, .6), inset 0 0 20px rgba(255, 255, 255, 1);-webkit-box-shadow: 0 0 10px #fff;rgba(255, 255, 255, .6), inset 0 0 20px rgba(255, 255, 255, 1);transform: rotateZ(360deg); /*图像旋转360度*/-webkit-transform: rotateZ(360deg);-moz-transform: rotateZ(360deg);&#125;/*#ds-thread #ds-reset .ds-textarea-wrapper textarea &#123;background: url(http://www.wuxubj.cn/images/duoshuo_bkground.jpg) right no-repeat;&#125;*/#ds-recent-visitors .ds-avatar &#123;float: left&#125;/*隐藏多说底部版权*/#ds-thread #ds-reset .ds-powered-by &#123;display: none;&#125; 2. Hexo 本地添加自定义CSS（推荐）打开 /themes/NexT/layout/_custom/header.swig或者 themes/NexT/source/css/_custom/custom.styl输入以下内容（custom.styl 可省略 style 标签）: 1234567891011121314151617181920212223242526272829303132333435363738&lt;style type="text/css"&gt;#ds-reset .ds-avatar img,#ds-recent-visitors .ds-avatar img &#123;width: 54px;height: 54px; /*设置图像的长和宽，这里要根据自己的评论框情况更改*/border-radius: 27px; /*设置图像圆角效果,在这里我直接设置了超过width/2的像素，即为圆形了*/-webkit-border-radius: 27px; /*圆角效果：兼容webkit浏览器*/-moz-border-radius: 27px;box-shadow: inset 0 -1px 0 #3333sf; /*设置图像阴影效果*/-webkit-box-shadow: inset 0 -1px 0 #3333sf;-webkit-transition: 0.4s;-webkit-transition: -webkit-transform 0.4s ease-out;transition: transform 0.4s ease-out; /*变化时间设置为0.4秒(变化动作即为下面的图像旋转360读）*/-moz-transition: -moz-transform 0.4s ease-out;&#125;#ds-reset .ds-avatar img:hover,#ds-recent-visitors .ds-avatar img:hover &#123;/*设置鼠标悬浮在头像时的CSS样式*/ box-shadow: 0 0 10px #fff;rgba(255, 255, 255, .6), inset 0 0 20px rgba(255, 255, 255, 1);-webkit-box-shadow: 0 0 10px #fff;rgba(255, 255, 255, .6), inset 0 0 20px rgba(255, 255, 255, 1);transform: rotateZ(360deg); /*图像旋转360度*/-webkit-transform: rotateZ(360deg);-moz-transform: rotateZ(360deg);&#125;/*#ds-thread #ds-reset .ds-textarea-wrapper textarea &#123;background: url(http://www.wuxubj.cn/images/duoshuo_bkground.jpg) right no-repeat;&#125;*/#ds-recent-visitors .ds-avatar &#123;float: left&#125;/*隐藏多说底部版权*/#ds-thread #ds-reset .ds-powered-by &#123;display: none;&#125;&lt;/style&gt; 添加 dom在需要添加最近访客的网页对应的 markdown 文件中添加如下代码： 123&gt; 最近访客&lt;div class="ds-recent-visitors" data-num-items="28" data-avatar-size="42" id="ds-recent-visitors"&gt;&lt;/div&gt;&lt;br/&gt; 添加最近访客 dom 到模板文件中（此做法更新抛弃，采用下面做法）在博客站点根目录的 scaffolds/*.md 模板文件中添加以上 dom 代码，以后新建 [layout] 便无需手动拷贝。 编辑主题配置文件在主题配置文件 _config.yml 中添加： 12# 最近访客duoshuo_recent_visit: true 修改 reward.swi 文件文件路径: 1/themes/NexT/layout/_macro/reward.swi 在顶部添加内容：123456789&#123;% if theme.duoshuo_recent_visit %&#125;&lt;blockquote&gt;&lt;p&gt;最近访客&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;div class="ds-recent-visitors" data-num-items="28" data-avatar-size="42" id="ds-recent-visitors"&gt;&lt;/div&gt;&lt;br&gt;&lt;br&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;&#123;% endif %&#125; 保存，重启 Hexo 即可]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[动态加载javascript]]></title>
      <url>%2F2017%2F03%2F09%2F%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BDjavascript%2F</url>
      <content type="text"><![CDATA[使用以下函数 12345678910111213141516171819202122232425262728// 另外一个独立的动态加载js的函数function loadJs(jsurl, head, callback) &#123; var script = document.createElement(script); script.setAttribute("type", "text/javascript"); if(callback) &#123; if(script.readyState) &#123; //IE script.onreadystatechange = function() &#123; if(script.readyState == "loaded" || script.readyState == "complete") &#123; script.onreadystatechange = null; callback(); &#125; &#125;; &#125; else &#123; //Others script.onload = function() &#123; callback(); &#125;; &#125; &#125; script.setAttribute("src", jsurl); if(head) document.getElementsByTagName(head)[0].appendChild(script); else &#123; document.body.appendChild(script); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[利用 dumpdecrypted 砸壳]]></title>
      <url>%2F2017%2F02%2F08%2F%E5%88%A9%E7%94%A8dumpdecrypted%E7%A0%B8%E5%A3%B3%2F</url>
      <content type="text"><![CDATA[1、编译生成 dumpdecrypted.dylib 2、给生成的 dumpdecrypted.dylib 签名 3、ssh到手机，ps aux | grep 目标APP查看APP安装目录 4、（可忽略这步）cycript -p 目标 APP，执行 1[[NSFileManager defaultManager] URLsForDirectory:NSDocumentDirectory inDomains:NSUserDomainMask][0] 查看沙盒目录 5、将 dumpdecrypted.dylib拷贝 /var/tmp，进入 /var/tmp 6、将 dumpdecrypted.dylib 拷贝到沙盒目录，进入沙盒目录，执行 1DYLD_INSERT_LIBRARIES=dumpdecrypted.dylib /var/containers/Bundle/Application/0B8A6E0F-9D64-4EF4-97D2-D3A508FC3574/APP.app/APP 7、得到目标 APP.decrypted就是二进制文件]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[给包签名]]></title>
      <url>%2F2017%2F02%2F08%2F%E7%BB%99%E5%8C%85%E7%AD%BE%E5%90%8D%2F</url>
      <content type="text"><![CDATA[查看可用签名1security find-identity -v -p codesigning 签名1codesign --force --verify --verbose --sign "iPhone Developer: 396736694@qq.com (Z4965JH2C8)” 目标包]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS企业内部应用分发]]></title>
      <url>%2F2017%2F01%2F11%2FiOS%E4%BC%81%E4%B8%9A%E5%86%85%E9%83%A8%E5%BA%94%E7%94%A8%E5%88%86%E5%8F%91%2F</url>
      <content type="text"><![CDATA[iOS 支持以无线方式安装企业内部应用，而无需使用 iTunes 或 App Store。 格式要求应用格式要求:.ipa，并且使用企业内部预置描述文件进行构建，即经企业证书签名。 无线安装要求： XML 清单文件（一个 plist 配置文件） 可让设备访问 Apple iTunes 服务器的网络配置（设备要能连接互联网，因为要校验） 对于 iOS 7.1 或更高版本， plist 文件和 ipa 文件需要放在 HTTPS 的服务器上为了安装应用，用户使用特殊的 URL 前缀从您的网站上下载plist清单文件，您可以分发该特殊前缀的URL给用户或者放置于可供用户访问的互联网上。 准备分发企业内部应用: 创建应用的归档，格式为 *.ipa 格式，并且归档中包括企业内部预置描述文件，且使用分发证书签名； 无线清单文件，您可以使用支持编辑 plist 文档的编辑器编写或者直接修改下面提供的范例，各字段意义范例中会写明； 可直接供内连网或互联网访问的 HTTPS 服务器。 关于无线 plist 清单文件单文件是一个 XML plist 文件，可供 Apple 设备用来从您的 Web 服务器上查找、下载和安装应用。 以下栏是必填项： URL：应用 (*.ipa) 文件的完全限定 HTTPS URL display-image：57 x 57 px 的 PNG 图像，在下载和安装过程中显示，图片的 Web URL full-size-image：512 x 512 px 的 PNG 图像，表示 iTunes 中相应的应用，图片的 Web URL bundle-identifier：应用的包标识符，与 Xcode 项目中指定的完全一样 bundle-version：应用的包版本，在 Xcode 项目中指定 title：下载和安装过程中显示的应用的名称样本清单文件还包含可选字段。例如，如果应用文件太大，并且想要在执行错误检验（TCP 通信通常会执行该检验）的基础上确保下载的完整性，可以使用 MD5 校验，使用见范例。您也可以在一个plist文件中配置多个应用，一个 item 作为一项。 构建网站将这些项目上传到网站上可供已认证的用户访问的区域： 应用 (.ipa) 文件 清单 (.plist) 文件您的网站可以是链接到清单文件的单个页面。用户轻点 Web 链接后会下载清单文件，并触发下载和安装。以下是示例链接：&lt;a href="itms-services://?action=download-manifest&amp;url=https://example.com/manifest.plist"&gt;安装应用&lt;/a&gt; 虽然 URL 的协议部分是“itms-services”，但 iTunes Store 并不参与此过程。 配置服务器 MIME 类型（一般不用配置）您可能需要配置 Web 服务器，让清单文件和应用文件可正确传输。 对于 Server 应用，请将 MIME 类型添加到网页服务的 MIME 类型设置： application/octet-stream ipa text/xml plist 对于微软的互联网信息服务器 (IIS)，请使用 IIS Manager 在服务器的“属性”页面中添加 MIME 类型： .ipa application/octet-stream .plist text/xml 无线 iOS 应用分发故障诊断如果无线应用分发失败，并显示“无法下载”信息： 请确定应用已正确进行签名。测试方法是使用 Apple Configurator 2 将它安装到设备上，然后查看是否发生错误。 请确定清单文件的链接是否正确，清单文件是否可供网络用户访问。 请确定 .ipa 文件（在清单文件中）的 URL 是否正确，并且该 .ipa 文件是否可供网络用户通过 HTTPS 访问。 网络配置要求如果设备连接到内网，那么您必须允许它访问以下站点： https://ax.init.itunes.apple.com 使用蜂窝移动网络下载应用时，设备会限制其当前文件大小。如果无法访问此站点，安装可能会失败。 https://ppq.apple.com 设备会联系此网站，检查用来给预置描述文件签名的分发证书状态。 应用更新 程序内检查 Server 端ipa版本和本地版本，比较是否已发布新版本，并提示用户更新。 如果用户想保留旧版本数据，请告知其不要卸载旧版本，并且新旧版本 bundle-identifier 相同。 更新方法：直接使用应用内部的openURL 方法，打开的是plist文件的web url 带 itms-services描述 链接（真机）。 证书验证 用户首次打开应用时，系统会通过联系 Apple 的 OCSP 服务器来验证分发证书。如果证书已撤销，应用将不会启动。为了验证状态，设备必须能够访问 ocsp.apple.com。 OCSP 响应会在设备上缓存一段时间（由 OCSP 服务器指定），当前为 3 到 7 天之间。在重新启动设备和缓存的响应过期之前，将不会再次检查证书的有效性。如果当时收到撤销命令，系统将阻止应用运行。【警告】撤销分发证书会导致使用该证书签名的所有应用失效。只有万不得已时才应撤销证书，比如确定专用密钥已丢失或确信证书已遭破解。 示例示例 iOS 应用 plist 清单文件，可复制，保存为plist格式，也可从 这里 下载 &lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt; &lt;plist version="1.0"&gt; &lt;dict&gt; &lt;key&gt;items&lt;/key&gt; &lt;array&gt; &lt;dict&gt; &lt;key&gt;assets&lt;/key&gt; &lt;array&gt; &lt;dict&gt; &lt;key&gt;kind&lt;/key&gt; &lt;string&gt;software-package&lt;/string&gt; &lt;key&gt;md5-size&lt;/key&gt; &lt;integer&gt;10485760&lt;/integer&gt; &lt;key&gt;md5s&lt;/key&gt; &lt;array&gt; &lt;string&gt;41fa64bb7a7cae5a46bfb45821ac8bba&lt;/string&gt; &lt;string&gt;51fa64bb7a7cae5a46bfb45821ac8bba&lt;/string&gt; &lt;/array&gt; &lt;key&gt;url&lt;/key&gt; &lt;string&gt;https://www.example.com/apps/foo.ipa&lt;/string&gt; &lt;/dict&gt; &lt;dict&gt; &lt;key&gt;kind&lt;/key&gt; &lt;string&gt;display-image&lt;/string&gt; &lt;key&gt;needs-shine&lt;/key&gt; &lt;true/&gt; &lt;key&gt;url&lt;/key&gt; &lt;string&gt;https://www.example.com/image.57x57.png&lt;/string&gt; &lt;/dict&gt; &lt;dict&gt; &lt;key&gt;kind&lt;/key&gt; &lt;string&gt;full-size-image&lt;/string&gt; &lt;key&gt;md5&lt;/key&gt; &lt;string&gt;61fa64bb7a7cae5a46bfb45821ac8bba&lt;/string&gt; &lt;key&gt;needs-shine&lt;/key&gt; &lt;true/&gt; &lt;key&gt;url&lt;/key&gt;&lt;string&gt;https://www.example.com/image.512x512.jpg&lt;/string&gt; &lt;/dict&gt; &lt;/array&gt; &lt;key&gt;metadata&lt;/key&gt; &lt;dict&gt; &lt;key&gt;bundle-identifier&lt;/key&gt; &lt;string&gt;com.example.fooapp&lt;/string&gt; &lt;key&gt;bundle-version&lt;/key&gt; &lt;string&gt;1.0&lt;/string&gt; &lt;key&gt;kind&lt;/key&gt; &lt;string&gt;software&lt;/string&gt; &lt;key&gt;subtitle&lt;/key&gt; &lt;string&gt;Apple&lt;/string&gt; &lt;key&gt;title&lt;/key&gt; &lt;string&gt;Example Corporate App&lt;/string&gt; &lt;/dict&gt; &lt;/dict&gt; &lt;/array&gt; &lt;/dict&gt; &lt;/plist&gt; 简单配置示例作为包体积较小的应用，如以下简单配置即可，从这里下载 &lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt; &lt;plist version="1.0"&gt; &lt;dict&gt; &lt;key&gt;items&lt;/key&gt; &lt;array&gt; &lt;dict&gt; &lt;key&gt;assets&lt;/key&gt; &lt;array&gt; &lt;dict&gt; &lt;key&gt;kind&lt;/key&gt; &lt;string&gt;software-package&lt;/string&gt; &lt;key&gt;url&lt;/key&gt; &lt;string&gt;https://yourwebsite/appName.ipa&lt;/string&gt; &lt;/dict&gt; &lt;dict&gt; &lt;key&gt;kind&lt;/key&gt; &lt;string&gt;full-size-image&lt;/string&gt; &lt;key&gt;needs-shine&lt;/key&gt; &lt;true/&gt; &lt;key&gt;url&lt;/key&gt; &lt;string&gt;https://yourwebsite/app_icon_full_size.png&lt;/string&gt; &lt;/dict&gt; &lt;dict&gt; &lt;key&gt;kind&lt;/key&gt; &lt;string&gt;display-image&lt;/string&gt; &lt;key&gt;needs-shine&lt;/key&gt; &lt;true/&gt; &lt;key&gt;url&lt;/key&gt; &lt;string&gt;https://yourwebsite/app_icon_download.png&lt;/string&gt; &lt;/dict&gt; &lt;/array&gt; &lt;key&gt;metadata&lt;/key&gt; &lt;dict&gt; &lt;key&gt;bundle-identifier&lt;/key&gt; &lt;string&gt; your app bundle id &lt;/string&gt; &lt;key&gt;bundle-version&lt;/key&gt; &lt;string&gt;shortVersion&lt;/string&gt; &lt;key&gt;kind&lt;/key&gt; &lt;string&gt;software&lt;/string&gt; &lt;key&gt;subtitle&lt;/key&gt; &lt;string&gt;欢迎使用&lt;/string&gt; &lt;key&gt;title&lt;/key&gt; &lt;string&gt; app 名称&lt;/string&gt; &lt;/dict&gt; &lt;/dict&gt; &lt;/array&gt; &lt;/dict&gt; &lt;/plist&gt; Author: CoderJay 如需转载，请注明出处]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mac查看CPU具体型号]]></title>
      <url>%2F2016%2F12%2F16%2FMac%E6%9F%A5%E7%9C%8BCPU%E5%85%B7%E4%BD%93%E5%9E%8B%E5%8F%B7%2F</url>
      <content type="text"><![CDATA[运行以下命令:1sysctl machdep.cpu.brand_string]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[OC用AFN做Soap请求webService]]></title>
      <url>%2F2016%2F01%2F10%2FOC%E7%94%A8AFN%E5%81%9ASoap%E8%AF%B7%E6%B1%82webService%2F</url>
      <content type="text"><![CDATA[前言好吧，标题有点拗口。我平时一般不发帖子，因为感觉太花时间了，还是喜欢宅着研究技术。但这个帖子网上资料还是没有很详细的，周末了明天休息，所以现在写下来总结一下，也希望能帮助有这方面需求的开发者朋友，如果错误之处还请谅解，欢迎指出。排版大家就不要在意了，我也不清楚这个支不支持markdown，就直接手动简单排一下。 进入主题，最近公司做一个新项目，后台是webService，要做iOS版本的客户端，由于我以前不怎么了解这方面，所以云里雾里得摸索了两天，因为后台人员也不清楚我具体要传什么给他，所以。。。。我就两边跑。。。。最终我确定问题还是在于后端，今天上午完美解决，对webService和WSDL以及CXF有了个大概的了解。 我就不做过多的概念介绍了，我很懒不愿复制粘贴，只要说一些细节让大家少走弯路就可以。 在继续往下之前你需要先去了解一些概念：SOAP、WSDL、CXF，和他们之间的关系。这里我觉得这个帖子比较好，推荐一下，Web Service笔记（三）：wsdl 与 soap协议详解 , 对XML或者HTML稍微有点了解看了这篇文章之后对WSDL基本都能大体了解了，这里也感谢一下作者。 假定现在你对它们有个大体的了解，SOAP请求就是你发一段XML给后台，然后后台返回数据给你，它是通用的，参数后台会在XML中提取，所以我们在这个过程中其实就是在于传的XML的内容，本文也会讲到中间遇到的一些细节。 首先不要把它想的很复杂，弄通了封装一下，其实这种方式传的东西个人感觉和普通的GET/POST差不多，甚或更方便。WSDL文档由于我现在不在公司连不上服务器所以就不介绍。 开始吧首先XML内容，你的SOAP协议版本要和后台一致，不然后台报错会说版本不一致之类的，这里列出，请自行对比。 SOAP 1.1以下是 SOAP 1.1 请求和响应示例。所显示的占位符需替换为实际值。 请求 12345678910111213141516POST /WebServices/MobileCodeWS.asmx HTTP/1.1Host: webservice.webxml.com.cnContent-Type: text/xml; charset=utf-8Content-Length: lengthSOAPAction: "http://WebXml.com.cn/getMobileCodeInfo"&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;soap:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/"&gt; &lt;soap:Body&gt; &lt;getMobileCodeInfo xmlns="http://WebXml.com.cn/"&gt; &lt;mobileCode&gt;string&lt;/mobileCode&gt; &lt;userID&gt;string&lt;/userID&gt; &lt;/getMobileCodeInfo&gt; &lt;/soap:Body&gt;&lt;/soap:Envelope&gt; 响应 123456789101112HTTP/1.1 200 OKContent-Type: text/xml; charset=utf-8Content-Length: length&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;soap:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/"&gt; &lt;soap:Body&gt; &lt;getMobileCodeInfoResponse xmlns="http://WebXml.com.cn/"&gt; &lt;getMobileCodeInfoResult&gt;string&lt;/getMobileCodeInfoResult&gt; &lt;/getMobileCodeInfoResponse&gt; &lt;/soap:Body&gt;&lt;/soap:Envelope&gt; SOAP 1.2以下是 SOAP 1.2 请求和响应示例。所显示的占位符需替换为实际值。 请求 1234567891011121314POST /WebServices/MobileCodeWS.asmx HTTP/1.1Host: webservice.webxml.com.cnContent-Type: application/soap+xml; charset=utf-8Content-Length: length&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;soap12:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap12="http://www.w3.org/2003/05/soap-envelope"&gt; &lt;soap12:Body&gt; &lt;getMobileCodeInfo xmlns="http://WebXml.com.cn/"&gt; &lt;mobileCode&gt;string&lt;/mobileCode&gt; &lt;userID&gt;string&lt;/userID&gt; &lt;/getMobileCodeInfo&gt; &lt;/soap12:Body&gt;&lt;/soap12:Envelope&gt; 响应 123456789101112HTTP/1.1 200 OKContent-Type: application/soap+xml; charset=utf-8Content-Length: length&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;soap12:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap12="http://www.w3.org/2003/05/soap-envelope"&gt; &lt;soap12:Body&gt; &lt;getMobileCodeInfoResponse xmlns="http://WebXml.com.cn/"&gt; &lt;getMobileCodeInfoResult&gt;string&lt;/getMobileCodeInfoResult&gt; &lt;/getMobileCodeInfoResponse&gt; &lt;/soap12:Body&gt;&lt;/soap12:Envelope&gt; 注意点直接说注意点，拿SOAP 1.1 请求做例子，要传的XML文档为: 123456789&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;soap:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/"&gt; &lt;soap:Body&gt; &lt;getMobileCodeInfo xmlns="http://WebXml.com.cn/"&gt; &lt;mobileCode&gt;string&lt;/mobileCode&gt; &lt;userID&gt;string&lt;/userID&gt; &lt;/getMobileCodeInfo&gt; &lt;/soap:Body&gt;&lt;/soap:Envelope&gt; 标签以外的不用改，head一般也不用传，要调用的方法和参数都包在body里面，比如这个例子中， getMobileCodeInfo 是WSDL文档发布的你要调用的方法名，其后接的xmlns是你wsdl文档中对应的 targetNameSpace ，这个和你JAVA中的 package 名对应，比如你后台JAVA代码中该方法中import的package为 com.xxxx.oooo 那么这里的xmlns就是 ooo.xxxx.com ，mobileCode和userID是这个方法中接收的参数名，那么也就是说该方法在其JAVA后台大概是这个样子 1public getMobileCodeInfo (@WebParam(name="mobileCode" , name="userID") String mobileCode, String userID) 对应的WSDL中该operation的input下也应该有两个name就是mobileCode和userID，注意@WebParam(name=”mobileCode” , name=”userID”) 不能少，这个注解让后台认识参数名，少了后台会一直报unexpected element ，我们后台一开始就少了这个，搞了很久。这种情况是参数分开传的情况，有的后台的参数直接一个request，但是里面包含有几个键值对也其实就是相当于几个参数，刚接触的新手在这里很容易绕弯，比如我后台有这个个方法 public login (WebParam(name=”req” ) String req) ，很明显这里只接一个参数，而且叫做req，但是这个请求就是需要账户名和密码，所以在对应的xml中文档应这样写body中内容 12345&lt;soap12:Body&gt; &lt;login xmlns="http://WebXml.com.cn/"&gt; &lt;req&gt;&#123;@"userNameKey": zhangsan, @"password": pwdpwd&#125;&lt;/req&gt; &lt;/login&gt;&lt;/soap12:Body&gt; NSURLSession请求soap最后请求地址就是你的wsdl文档中的Endpoint address地址，请求体就是该XML，发个POST请求就完事啦，这里又有事了，本人是强迫症，因为一开始就用的AFN请求，咋请求咋报错，于是跟着网上找的DEMO换NSURLConnection，一不小心成功了一次，但是这个iOS已经废弃了不喜欢，于是用NSURLSession，恩也成功了，但是还是感觉好麻烦，发个NSURLSession请求soap的代码: 1234567891011121314151617181920212223242526272829303132333435363738394041 NSString *soapStr = [NSString stringWithFormat:@"&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\ &lt;soap:Envelope xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\"\ xmlns:soap=\"http://schemas.xmlsoap.org/soap/envelope/\"&gt;\ &lt;soap:Header&gt;\ &lt;/soap:Header&gt;\ &lt;soap:Body&gt;\ &lt;login xmlns=\"targetNameSpace地址/\"&gt;\ &lt;param1&gt;test&lt;/param1&gt;\ &lt;param2&gt;test&lt;/param2&gt;\ &lt;/login&gt;\ &lt;/soap:Body&gt;\ &lt;/soap:Envelope&gt;"]; NSURL *url=[NSURL URLWithString:@"你自己wsdl文档中对应的endpoint address"]; NSMutableURLRequest *request=[NSMutableURLRequest requestWithURL:url]; // 访问方式 [request setHTTPMethod:@"POST"]; // 设置请求头(请求头也可以不设置，前两个设不设置都一样，应该默认的，但是SOAPAction我怎么都设置不对，不设置也可以，干脆不设置了) // [request addValue:@"text/xml; charset=utf-8" forHTTPHeaderField:@"Content-Type"];// [request addValue:[NSString stringWithFormat:@"%zd", soapStr.length] forHTTPHeaderField:@"Content-Length"]; // [request addValue:@"nameSpace/methodName" forHTTPHeaderField:@"SOAPAction"]; // body内容 [request setHTTPBody:[soapStr dataUsingEncoding:NSUTF8StringEncoding]]; NSURLSession *session = [NSURLSession sharedSession]; NSURLSessionDataTask *task = [session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123; NSString *result = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding]; WJLog(@"进入成功回调Session-----结果：%@----请求地址：%@", result, response.URL); if (error) &#123; WJLog(@"Session----失败----%@", error.localizedDescription); &#125; &#125;]; [task resume]; AFHTTPRequestOperation 请求经过和后台七改八改都无果，我干脆自己了解这些文档规范，在上午确定我操作没错之后，直接说后台那边有问题，然后后台改，重启服务器我请求没有任何进展，最后竟然是什么问题你们知道么。。前一天其实我已经传对了XML，只是后台改动的代码放错了地方，只放到了正式服没有放测试服，我也是，，，醉了，，不过也好，要是那么顺畅我就不会去过多了解这方面了。好了，要传什么，注意点都讲了，现在到了客户端的问题，用官方SDK请求是不是感觉很麻烦？是的，对于用惯了AFN或者自己封装的网络请求工具类的人来说如果每次都要写这多么代码发一次请求太痛苦了，于是我想可不可以用AFN请求SOAP，一开始想用manager发请求，直接把XML当params发POST肯定是直接挂了，于是想要设置HTTPBody要不用AFHTTPRequestOperation？没错这样确实可以，代码如下： 1234567891011121314151617NSMutableURLRequest *request=[NSMutableURLRequest requestWithURL:url]; [request setHTTPMethod:@"POST"]; [request setHTTPBody:[soapStr dataUsingEncoding:NSUTF8StringEncoding]]; AFHTTPRequestOperation *operation = [[AFHTTPRequestOperation alloc] initWithRequest:request]; // 设置返回数据格式 operation.responseSerializer = [AFHTTPResponseSerializer serializer]; [operation setCompletionBlockWithSuccess:^(AFHTTPRequestOperation * _Nonnull operation, id _Nonnull responseObject) &#123; NSString *result = [[NSString alloc] initWithData:responseObject encoding:NSUTF8StringEncoding]; WJLog(@"AFN--成功--结果：%@----返回数据%@", result, responseObject); &#125; failure:^(AFHTTPRequestOperation * _Nonnull operation, NSError * _Nonnull error) &#123; WJLog(@"AFN--失败--%@", error.localizedDescription); &#125;]; [operation start]; 这一看感觉和NSURLSession没多大差别，还是想用manager，关键问题就在于设置request的HTTBbody为XML，但是AFHTTPSessionManager已经把request封装了，默认用的params，怎么改？于是想改动或者添加AFN内部方法，但是总感觉这样不好，万一更新库了又要搞一遍。于是想能否拦截这个request，或者通过manager.requestSerializer设置HTTPBody，敲set浏览一下没有HTTPBody字眼的，用KVC也不行，那样还是相当于把XML当params传了，伤心绝望之时看到这个方法: 123 [manager.requestSerializer setQueryStringSerializationWithBlock:^NSString *(NSURLRequest *request, NSDictionary *parameters, NSError *__autoreleasing *error) &#123; // &#125;] 简单封装 AFHTTPSessionManager 请求一看里面有request 有 params 高兴了，说不定在这里能拦截，于是直接写 123[manager.requestSerializer setQueryStringSerializationWithBlock:^NSString *(NSURLRequest *request, NSDictionary *parameters, NSError *__autoreleasing *error) &#123; return soapStr;&#125;] 请求成功，happy。接下来另一个问题了，简单封装一下，我收到的是二进制，所以把AFN封装成了个工具类，供大家参考，欢迎提出改进 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/*** 请求SOAP，返回NSData** @param url 请求地址* @param soapBody soap的XML中方法和参数段* @param success 成功block* @param failure 失败block*/+ (void)SOAPData:(NSString *)url soapBody:(NSString *)soapBody success:(void (^)(id responseObject))success failure:(void(^)(NSError *error))failure &#123; NSString *soapStr = [NSString stringWithFormat: @"&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\ &lt;soap:Envelope xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\"\ xmlns:soap=\"http://schemas.xmlsoap.org/soap/envelope/\"&gt;\ &lt;soap:Header&gt;\ &lt;/soap:Header&gt;\ &lt;soap:Body&gt;%@&lt;/soap:Body&gt;\ &lt;/soap:Envelope&gt;",soapBody]; AFHTTPSessionManager *manager = [AFHTTPSessionManager manager]; manager.responseSerializer = [AFXMLParserResponseSerializer serializer]; // 设置请求超时时间 manager.requestSerializer.timeoutInterval = 30; // 返回NSData manager.responseSerializer = [AFHTTPResponseSerializer serializer]; // 设置请求头，也可以不设置 [manager.requestSerializer setValue:@"application/soap+xml; charset=utf-8" forHTTPHeaderField:@"Content-Type"]; [manager.requestSerializer setValue:[NSString stringWithFormat:@"%zd", soapStr.length] forHTTPHeaderField:@"Content-Length"]; // 设置HTTPBody [manager.requestSerializer setQueryStringSerializationWithBlock:^NSString *(NSURLRequest *request, NSDictionary *parameters, NSError *__autoreleasing *error) &#123; return soapStr; &#125;]; [manager POST:url parameters:soapStr success:^(NSURLSessionDataTask * _Nonnull task, id _Nonnull responseObject) &#123; // 把返回的二进制数据转为字符串 NSString *result = [[NSString alloc] initWithData:responseObject encoding:NSUTF8StringEncoding]; // 利用正则表达式取出&lt;return&gt;&lt;/return&gt;之间的字符串 NSRegularExpression *regular = [[NSRegularExpression alloc] initWithPattern:@"(?&lt;=return\\&gt;).*(?=&lt;/return)" options:NSRegularExpressionCaseInsensitive error:nil]; NSDictionary *dict = [NSDictionary dictionary]; for (NSTextCheckingResult *checkingResult in [regular matchesInString:result options:0 range:NSMakeRange(0, result.length)]) &#123; // 得到字典 dict = [NSJSONSerialization JSONObjectWithData:[[result substringWithRange:checkingResult.range] dataUsingEncoding:NSUTF8StringEncoding] options:NSJSONReadingMutableLeaves error:nil]; &#125; // 请求成功并且结果有值把结果传出去 if (success &amp;&amp; dict) &#123; success(dict); &#125; &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123; if (failure) &#123; failure(error); &#125; &#125;];&#125; 原文地址：OC用AFN做Soap请求webService 结束语差不多了，如果有什么问题指正欢迎大家留言。排版真的很丑，大家见谅，洗洗睡了。 Author: CoderJay 如需转载，请注明出处]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ASI 和 AFN 区别]]></title>
      <url>%2F2015%2F10%2F06%2FASI-%E5%92%8C-AFN-%E5%8C%BA%E5%88%AB%2F</url>
      <content type="text"><![CDATA[一 底层实现 AFN的底层基于OC的NSURLConnection和NSURLSession ASI的底层基于纯C语言的CFNetwork框架 ASI的运行性能 高于 AFN 二 对服务器返回的数据处理 ASI没有直接提供对服务器数据处理的方式，直接返回data\string AFN提供了多种对服务器数据处理的方式 JSON处理 XML处理 其他处理 三 监听请求的过程 AFN提供了success和failure两个block来监听请求的过程（只能监听成功和失败） success : 请求成功后调用 failure : 请求失败后调用 ASI提供了3套方案，每一套方案都能监听请求的完整过程（监听请求开始、接收到响应头信息、接受到具体数据、接受完毕、请求失败） 成为代理，遵守协议，实现协议中的代理方法 成为代理，不遵守协议，自定义代理方法 设置block 四 在文件下载和文件上传的使用难易度 AFN 不容易监听下载进度和上传进度 不容易实现断点续传 一般只用来下载不大的文件 ASI 非常容易实现下载和上传 非常容易监听下载进度和上传进度 非常容易实现断点续传 下载或大或小的文件都行 五 ASI提供了更多的实用功能 控制圈圈要不要在请求过程中转 可以轻松地设置请求之间的依赖：每一个请求都是一个 NSOperation 对象 可以统一管理所有请求（还专门提供了一个叫做 ASINetworkQueue 来管理所有的请求对象） 暂停\恢复\取消所有的请求 监听整个队列中所有请求的下载进度和上传进度]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[OC 千位分隔符格式化数字]]></title>
      <url>%2F2015%2F08%2F16%2FOC-%E5%8D%83%E4%BD%8D%E5%88%86%E9%9A%94%E7%AC%A6%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%95%B0%E5%AD%97%2F</url>
      <content type="text"><![CDATA[工作中总是碰到很多需求，比如金额需要以千位分隔的方式显示，这是OC版本转换方法，其它语言的可参考，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** 转换目标字符串为千位分隔显示 @param digitString 目标字符串 @return 转换结果字符串 */+ (NSString *)groupedThousandsDigitStringWithStr:(NSString *)digitString &#123; // 判断小数部位 NSRange rangeOfPoint = [digitString rangeOfString:@"."]; NSString *pointStr = @""; if (rangeOfPoint.length &gt;= 1) &#123; pointStr = [digitString substringFromIndex:rangeOfPoint.location]; &#125; // 去掉小数部位 digitString = [digitString substringToIndex:rangeOfPoint.location]; // 去掉小数位后长度小于3直接返回原字符 if (digitString.length &lt;= 3) return [digitString stringByAppendingString:pointStr]; NSMutableString *processString = [NSMutableString stringWithString:digitString]; NSInteger location = processString.length - 3; NSMutableArray *processArray = [NSMutableArray array]; while (location &gt;= 0) &#123; NSString *temp = [processString substringWithRange:NSMakeRange(location, 3)]; [processArray addObject:temp]; if (location &lt; 3 &amp;&amp; location &gt; 0) &#123; NSString *t = [processString substringWithRange:NSMakeRange(0, location)]; [processArray addObject:t]; &#125; location -= 3; &#125; NSMutableArray *resultsArray = [NSMutableArray array]; NSInteger k = 0; for (NSString *str in processArray) &#123; k++; NSMutableString *tmp = [NSMutableString stringWithString:str]; if (str.length &gt; 2 &amp;&amp; k &lt; processArray.count ) &#123; [tmp insertString:@"," atIndex:0]; [resultsArray addObject:tmp]; &#125; else &#123; [resultsArray addObject:tmp]; &#125; &#125; NSMutableString *resultString = [NSMutableString string]; for (NSInteger i = resultsArray.count - 1 ; i &gt;= 0; i--) &#123; NSString *tmp = [resultsArray objectAtIndex:i]; [resultString appendString:tmp]; &#125; return [resultString stringByAppendingString:pointStr];&#125;]]></content>
    </entry>

    
  
  
</search>
