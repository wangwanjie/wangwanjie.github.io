<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Ubuntu 18.04 LTS 安装部署 Seafile]]></title>
    <url>%2F2018%2F10%2F01%2FUbuntu-18-04-LTS-%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2-Seafile%2F</url>
    <content type="text"><![CDATA[背景新入职的公司内部同步一些文件使用的 Seafile，没部署远程，只使用的内网，由于这个 seafile 是一个前同事搭建的（之前的 iOSer，我来替代他了，阴差阳错。。。），可能那时他也不是太熟吧，把文件存放目录放在了安装位置的挂载分区，导致长时间使用下来，该分区磁盘空间满了，无法继续运行，于是我简单 google 了一番，开始转移目录，找到了 seafile-data 目录之后，发现查看都没权限，包括 cp -R、mv 都无法运行，直接给了755权限，mv seafile-data 目录至新目录，更改 seafile.ini 文件，指向新目录，重启 seafile，发现 seafile 已经无法启动……下意识重启一下电脑，还是不行，这时看下禅道，测试又提了一堆 BUG，就先放下开始修 BUG 了。第二天早上过来继续，发现系统都进不去了，登录界面无法输入密码，没办法只好命令行登入系统，再次 google 了解到 seafile 存放文件的形式类似于 svn 或 git ，也是那种打散存放并内部记录 state 和带有 commit log 的，看到了官方有修复工具，尝试无果，放弃了，系统也崩了（多年linux 经验解决不了，尝试了几个小时，google 了解到貌似是 Ubuntu 16.04 LTS 的 bug 所致，有个旧内核依赖怎么都干不掉，导致所有的 dpkg -i 都运行不了），这台机器上安装了 jenkins 和 seafile，问过了别无其他，心想 jenkins 我也熟练部署了，只能硬着头皮去跟组长说要重装系统，于是有了这篇文章。 重装系统下载 Ububtu 系统，选了最新的长期支持版本 18.04，UI 大改了，看了挺喜欢，安排下载。这步没啥说，随便拿了个5年前的捣鼓用的 4G U盘，在 mac 制作了一个 Ubuntu 的安装盘。从 U盘启动，安装系统。 安装 Seafile 服务器端更新下系统12apt-get update apt-get upgrade 安装 python 2.7 及其它依赖由于 seafile 使用的 py 2.7，但 Ubuntu 默认集成的是 3+ 版本，所以要安装。 123apt-get install pythonapt-get install python2.7 libpython2.7 python-setuptools python-pil python-ldap python-urllib3 ffmpeg python-pip python-mysqldb python-memcachepip install pillow moviepy 安装 Mariadb1sudo apt install mariadb-server 开始安装 seafile下载 Seafile 服务器端程序去 Seafile官方下载地址 复制 服务器端 -&gt; Linux 服务器端 -&gt; 64bit 链接，比如现在最新的是 http://seafile-downloads.oss-cn-shanghai.aliyuncs.com/seafile-server_6.2.5_x86-64.tar.gz，目录的话建议安装到 /opt 下面，但是数据目录使用磁盘空间比较大的地方，比如我这边是是安装位置和数据目录都放在了 /home/data/seafile 下，过程如下： 1234cd /homemkdir -p data/seafile &amp;&amp; cd data/seafilewget http://seafile-downloads.oss-cn-shanghai.aliyuncs.com/seafile-server_6.2.5_x86-64.tar.gzmkdir installed &amp;&amp; mv seafile-server_6.2.5_x86-64.tar.gz installed 安装 seafile 服务端因为依赖环境和数据库都已经安装好了，这边我是使用的 Mariadb，所以用的是 seafile 写好的 setup-seafile-mysql.sh 脚本进行 setup，中间会提示你输入 seafile-data 数据存放目录，记得输入你指定的目录，比如我这里应该填/home/data/seafile/seafile-data，当然如果你已经在/home/data/seafile/seafile-server-6.2.5则直接 Enter 默认即可，它会自动去上层目录创建seafile-data目录。 12cd seafile-server-6.2.5./setup-seafile-mysql.sh 一路按引导完成，根据提示，输入服务器名、IP、数据目录（默认为../seafile-data）、seahub 端口、seafile-server监听端口（默认8082，不可更改），ifconfig 查看自己内网 ip，查完成之后确认设置，目录会变成如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152vanjay@VanJay:/home/data$ sudo tree -L 3.└── seafile ├── ccnet │ ├── ccnet.sock │ ├── misc │ ├── mykey.peer │ └── seafile.ini ├── conf │ ├── ccnet.conf │ ├── seafdav.conf │ ├── seafile.conf │ ├── seahub_settings.py │ └── seahub_settings.pyc ├── installed │ └── seafile-server_6.2.5_x86-64.tar.gz ├── logs │ ├── ccnet.log │ ├── controller.log │ ├── seafile.log │ ├── seahub.log │ └── seahub_django_request.log ├── pids │ ├── ccnet.pid │ └── seaf-server.pid ├── seafile-data │ ├── commits │ ├── fs │ ├── httptemp │ ├── library-template │ ├── storage │ └── tmpfiles ├── seafile-server-6.2.5 │ ├── check_init_admin.py │ ├── reset-admin.sh │ ├── runtime │ ├── seaf-fsck.sh │ ├── seaf-fuse.sh │ ├── seaf-gc.sh │ ├── seafile │ ├── seafile.sh │ ├── seahub │ ├── seahub.sh │ ├── setup-seafile-mysql.py │ ├── setup-seafile-mysql.sh │ ├── setup-seafile.sh │ └── upgrade ├── seafile-server-latest -&gt; seafile-server-6.2.5 └── seahub-data └── avatars22 directories, 26 files 启动/停止 Seafile启动Seafile-server和Seahub，第一次启动会提示建立管理员账号。 12./seafile.sh start./seahub.sh start &lt;端口号&gt; 此时通过浏览器本地访问 localhost:端口号，应该可以出现登录页面。如果出现网页乱码，可以删除/tmp/seahub_cache再重启seahub，即可恢复正常。 常用命令： 关闭 12./seahub.sh stop # 停止 Seahub./seafile.sh stop # 停止 Seafile 进程 重启 12./seafile.sh restart # 停止当前的 Seafile 进程，然后重启 Seafile./seahub.sh restart # 停止当前的 Seahub 进程，并在 8000 端口重新启动 Seahub 使用 pgrep 命令检查 seafile/seahub 进程是否还在运行中 12pgrep -f seafile-controller # 查看 Seafile 进程pgrep -f "seahub" # 查看 Seahub 进程 使用 pkill 命令杀掉相关进程 12pkill -f seafile-controller # 结束 Seafile 进程pkill -f "seahub" # 结束 Seafile 进程 配置防火墙本地可以访问了，但从外部访问就不行了，需要配置下防火墙，当然你也直接关闭防火墙。 开关防火墙 12ufw disable # 关闭ufw enable # 开启 也可添加端口，端口8082，必须添加，这是 seafile-file 端口，不可更改。8000为 seahub 默认监听端口，如果自定义 seahub 监听端口，这里记得添加。 12345firewall-cmd --permanent --add-port=8000/tcpfirewall-cmd --permanent --add-port=8082/tcpfirewall-cmd --permanent --add-service httpfirewall-cmd --reloadfirewall-cmd --list-all 安装 Ubuntu Seafile 客户端开始使用吧。 123sudo add-apt-repository ppa:seafile/seafile-clientsudo apt-get updatesudo apt-get install seafile-gui 添加执行用户和配置目录权限123useradd vanjay -s /sbin/nologin -d /home/data/seafilechown -R vanjay:vanjay /home/data/seafile/chown -R vanjay:vanjay /tmp/seahub_cache/ 配置开机自启动 Seafile对于运行 systemd 的系统（例如 Debian 8 以及更新的版本，Ubuntu 15.04以及更新的版本），创建 systemd 服务管理文件（注意自行更改 User 、Group 和Seafile 路径） 创建 seafile service 1sudo vim /etc/systemd/system/seafile.service 注意！注意！注意！ 这里有个大坑，花了我一个晚上去解决！由于官方提供了开机启动 service 脚本，一般都是直接拿来用，改改路径用户名就好，但是！我在 Ubuntu 18.04 开机启动 seafile 上花了整整一个晚上！，systemctl status seafile查看服务状态，由于 seafile 启动依赖数据库，所以需要先等待数据库服务启动完毕再启动，我这安装的是 mariadb ，所以要在 After 后面加上 mariadb.service，重启正常自启了，阿弥陀佛！ 123456789101112131415[Unit]Description=Seafile# add mysql.service or postgresql.service depending on your database to the line belowAfter=network.target mariadb.service[Service]Type=oneshotExecStart=/home/data/seafile/seafile-server-latest/seafile.sh startExecStop=/home/data/seafile/seafile-server-latest/seafile.sh stopRemainAfterExit=yesUser=vanjayGroup=vanjay[Install]WantedBy=multi-user.target 创建 seahub service 1sudo vim /etc/systemd/system/seahub.service 输入如下内容，用户、用户组、路径改为自己的 seafile 路径。 123456789101112131415[Unit]Description=Seafile hubAfter=network.target seafile.service[Service]# change start to start-fastcgi if you want to run fastcgiExecStart=/home/data/seafile/seafile-server-latest/seahub.sh startExecStop=/home/data/seafile/seafile-server-latest/seahub.sh stopUser=vanjayGroup=vanjayType=oneshotRemainAfterExit=yes[Install]WantedBy=multi-user.target 设置服务开机自启动123sudo systemctl daemon-reloadsudo systemctl enable seafilesudo systemctl enable seahub 致谢参考链接： Seafile 中文文档 搭建一个属于自己的Seafile网盘]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Seafile</tag>
        <tag>Ubuntu</tag>
        <tag>个人云盘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 开发从 Array 生成特定分隔符隔开的 String]]></title>
    <url>%2F2018%2F10%2F01%2FiOS-%E5%BC%80%E5%8F%91%E4%BB%8E-Array-%E7%94%9F%E6%88%90%E7%89%B9%E5%AE%9A%E5%88%86%E9%9A%94%E7%AC%A6%E9%9A%94%E5%BC%80%E7%9A%84-String%2F</url>
    <content type="text"><![CDATA[从一个String Array 或者 Object Array 生成字符串，使用特定的分隔符隔开，起始和末尾不需要分隔符，当传入的是对象的时候，需要指定Object 中 String 的 key 字符串，效果如下图所示： 直接看代码，只是备忘。 头文件123456789101112131415161718//// TGStringTool.h// DongKe//// Created by VanJay on 2018/9/30.// Copyright © 2018 DongKe. All rights reserved.//#import &lt;Foundation/Foundation.h&gt;NS_ASSUME_NONNULL_BEGIN@interface TGStringTool : NSObject+ (NSString *)stringWithStringArr:(NSArray&lt;NSString *&gt; *)arr separatedStr:(NSString *)separatedStr;+ (NSString *)stringWithArr:(NSArray&lt;id&gt; *)arr valueKey:(NSString *)key separatedStr:(NSString *)separatedStr;@endNS_ASSUME_NONNULL_END 实现文件123456789101112131415161718192021222324252627282930313233343536373839404142434445//// TGStringTool.m// DongKe//// Created by VanJay on 2018/9/30.// Copyright © 2018 DongKe. All rights reserved.//#import &quot;TGStringTool.h&quot;@implementation TGStringTool+ (NSString *)stringWithStringArr:(NSArray&lt;NSString *&gt; *)arr separatedStr:(NSString *)separatedStr &#123; NSMutableString *temp = [NSMutableString string]; if (arr.count &gt; 0) &#123; [arr enumerateObjectsUsingBlock:^(NSString *_Nonnull str, NSUInteger idx, BOOL *_Nonnull stop) &#123; if (str.length &gt; 0) &#123; [temp appendString:str]; if (idx &lt; arr.count - 1) &#123; [temp appendString:separatedStr]; &#125; &#125; &#125;]; &#125; return temp;&#125;+ (NSString *)stringWithArr:(NSArray&lt;id&gt; *)arr valueKey:(NSString *)key separatedStr:(NSString *)separatedStr &#123; NSMutableString *temp = [NSMutableString string]; if (arr.count &gt; 0) &#123; [arr enumerateObjectsUsingBlock:^(id _Nonnull obj, NSUInteger idx, BOOL *_Nonnull stop) &#123; if ([obj respondsToSelector:NSSelectorFromString(key)]) &#123; NSString *str = [obj valueForKey:key]; if (str.length &gt; 0) &#123; [temp appendString:str]; if (idx &lt; arr.count - 1) &#123; [temp appendString:separatedStr]; &#125; &#125; &#125; &#125;]; &#125; return temp;&#125;@end]]></content>
      <categories>
        <category>iOS 开发</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>String</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 数字转 xx 万 xx 亿]]></title>
    <url>%2F2018%2F09%2F30%2FiOS-%E6%95%B0%E5%AD%97%E8%BD%AC-xx-%E4%B8%87-xx-%E4%BA%BF%2F</url>
    <content type="text"><![CDATA[App 开发显示 XX 万 xx 亿APP开发中界面显示很多地方需要显示数字，但是如果数字过大，可能会有将数字显示成 xx 万、xx 百万、xx 亿的需求，简单封装了一下，备忘，以便日后使用。 这是声明文件，调用者可以决定保留几位小数，是否需要四舍五入，也可依据代码自行扩展方法。 123456789101112131415161718192021222324252627282930//// TGCaculateNumberTool.h// Tungee//// Created by VanJay on 2018/8/22.// Copyright © 2018年 Tungee. All rights reserved.//#import &lt;Foundation/Foundation.h&gt;typedef NS_ENUM(NSInteger, TGCNToFixedCount) &#123; TGCNToFixedCountZero = 0, ///&lt; b不保留小数 TGCNToFixedCountOne, ///&lt; 保留一位小数 TGCNToFixedCountTwo, ///&lt; 保留两位小数 TGCNToFixedCountThree, ///&lt; 保留三位小数 TGCNToFixedCountFour ///&lt; 保留四位小数&#125;;@interface TGCaculateNumberTool : NSObject+ (NSString *)stringFromNumber:(NSUInteger)number;/** 返回数字描述 @param number 数字 @param toFixed 保留小数位数 @param isRounded 是否四舍五入 */+ (NSString *)stringFromNumber:(NSUInteger)number toFixedCount:(TGCNToFixedCount)toFixed rounded:(BOOL)isRounded;@end 这是实现文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990//// TGCaculateNumberTool.m// Tungee//// Created by VanJay on 2018/8/22.// Copyright © 2018年 Tungee. All rights reserved.//#import &quot;TGCaculateNumberTool.h&quot;@implementation TGCaculateNumberTool+ (NSString *)stringFromNumber:(NSUInteger)number &#123; NSString *output; if (number &lt;= 0) &#123; output = @&quot;0&quot;; &#125; else if (number &lt;= 9999) &#123; output = [NSString stringWithFormat:@&quot;%ld&quot;, (unsigned long)number]; &#125; else if (number &lt;= 99999999) &#123; // 9999999 output = [NSString stringWithFormat:@&quot;%.0f万&quot;, [self roundFloat:(double)number / 10000.0 toFixedCount:TGCNToFixedCountZero rounded:YES]]; &#125; else &#123; output = [NSString stringWithFormat:@&quot;%.0f亿&quot;, [self roundFloat:(double)number / 100000000.0 toFixedCount:TGCNToFixedCountZero rounded:YES]]; &#125; return output;&#125;+ (NSString *)stringFromNumber:(NSUInteger)number toFixedCount:(TGCNToFixedCount)toFixed rounded:(BOOL)isRounded &#123; NSString *output; if (number &lt;= 0) &#123; output = @&quot;0&quot;; &#125; else if (number &lt;= 9999) &#123; output = [NSString stringWithFormat:@&quot;%ld&quot;, (unsigned long)number]; &#125; else if (number &lt;= 99999999) &#123; // 9999999 if (toFixed == TGCNToFixedCountZero) &#123; output = [NSString stringWithFormat:@&quot;%.0f万&quot;, [self roundFloat:(double)number / 10000.0 toFixedCount:toFixed rounded:isRounded]]; &#125; else if (toFixed == TGCNToFixedCountOne) &#123; output = [NSString stringWithFormat:@&quot;%.1f万&quot;, [self roundFloat:(double)number / 10000.0 toFixedCount:toFixed rounded:isRounded]]; &#125; else if (toFixed == TGCNToFixedCountTwo) &#123; output = [NSString stringWithFormat:@&quot;%.2f万&quot;, [self roundFloat:(double)number / 10000.0 toFixedCount:toFixed rounded:isRounded]]; &#125; else if (toFixed == TGCNToFixedCountThree) &#123; output = [NSString stringWithFormat:@&quot;%.3f万&quot;, [self roundFloat:(double)number / 10000.0 toFixedCount:toFixed rounded:isRounded]]; &#125; else if (toFixed == TGCNToFixedCountFour) &#123; output = [NSString stringWithFormat:@&quot;%.4f万&quot;, [self roundFloat:(double)number / 10000.0 toFixedCount:toFixed rounded:isRounded]]; &#125; &#125; else &#123; if (toFixed == TGCNToFixedCountZero) &#123; output = [NSString stringWithFormat:@&quot;%.0f亿&quot;, [self roundFloat:(double)number / 100000000.0 toFixedCount:toFixed rounded:isRounded]]; &#125; else if (toFixed == TGCNToFixedCountOne) &#123; output = [NSString stringWithFormat:@&quot;%.1f亿&quot;, [self roundFloat:(double)number / 100000000.0 toFixedCount:toFixed rounded:isRounded]]; &#125; else if (toFixed == TGCNToFixedCountTwo) &#123; output = [NSString stringWithFormat:@&quot;%.2f亿&quot;, [self roundFloat:(double)number / 100000000.0 toFixedCount:toFixed rounded:isRounded]]; &#125; else if (toFixed == TGCNToFixedCountThree) &#123; output = [NSString stringWithFormat:@&quot;%.3f亿&quot;, [self roundFloat:(double)number / 100000000.0 toFixedCount:toFixed rounded:isRounded]]; &#125; else if (toFixed == TGCNToFixedCountFour) &#123; output = [NSString stringWithFormat:@&quot;%.4f亿&quot;, [self roundFloat:(double)number / 100000000.0 toFixedCount:toFixed rounded:isRounded]]; &#125; &#125; return output;&#125;/** 计算特定小数位数 @param input 输入数字 @param toFixed 保留小数位数 @param isRounded 是否四舍五入 */+ (double)roundFloat:(double)input toFixedCount:(TGCNToFixedCount)toFixed rounded:(BOOL)isRounded &#123; double scale = 1; if (toFixed == TGCNToFixedCountZero) &#123; scale = 1; &#125; else if (toFixed == TGCNToFixedCountOne) &#123; scale = 10; &#125; else if (toFixed == TGCNToFixedCountTwo) &#123; scale = 100; &#125; else if (toFixed == TGCNToFixedCountThree) &#123; scale = 1000; &#125; else if (toFixed == TGCNToFixedCountFour) &#123; scale = 10000; &#125; if (isRounded) &#123; return (floorf(input * scale + 0.5)) / scale; &#125; else &#123; return (floorf(input * scale - 0.5)) / scale; &#125;&#125;@end]]></content>
      <categories>
        <category>iOS 开发</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Objective</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[购买BanwagonHOST VPS自建Shadowsocks记录]]></title>
    <url>%2F2017%2F07%2F28%2F%E8%B4%AD%E4%B9%B0BanwagonHOST-VPS%E8%87%AA%E5%BB%BAShadowsocks%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[前言 不能畅游墙外没法好好生活和工作 本来手里有着五六个 Shadowsocks 帐号，但体验都不佳，一直也没怎么用，是因为一直使用公司搭建的 Cisco Anyconnect，科学上网后百兆带宽可以满速使用，速度虽快，但是客户端软件默认是全局代理的，虽然可以走IP route list达到和Shadowsocks的PAC同样的作用，但效果慎微，而且IP要自己去填，所以公司IT直接没搞这个route list，因为我们大部分电脑和手机APP都在墙内，这就导致在使用了Cisco Anyconnect后大部分电脑或者手机上的APP网络访问困难，常开VPN还是需要Shadowsocks等可根据 PAC清单自动代理 或者 分应用代理 的一类软件。 主题废话有点多，进入主题。前几日群里的前辈在群里说道自搭的Shadowsocks在使用了Google提出的TCP拥塞控制新算法——BBR之后，解决了以下两个问题： 1. 在有一定丢包率的网络链路上充分利用带宽； 2. 降低网络链路上的 buffer 占用率，从而降低延迟。 正好有时间，大佬说的又激发了我的兴趣，我决定自己也搭一个玩玩，也以备不时之需，经历这一天，也总结了个人认为最省事的路线，以下是步骤记录。 购买VPS在请教了群里的前辈购买何档次的BanwagonHOST VPN之后，购买了19.99$/年的方案，这是购买地址：BanwagonHOST，这里注意两点，第一点：购买时注意买基于KVM的，而不是OpenVZ，KVM是新推出的，只了解了大体不同，想知道具体差异自行Google，一般来说，买新架构就没错了；第二点：在选择Location时，最好选择美国洛杉矶节点Los Angeles，别问为什么，前人经验，至于是QNET还是MCOM，自行谷歌这二者差异，有人汇总对比了这两种方案，不同城市的ping值有高有低，总体来说QNET稍好，所以我购买的是它。 重装系统付款购买成功后，进入当前页面的Services-My Services菜单下，找到你新购买的Product/Service，进入控制面板KiviVM Control Panel，界面很简单，每个功能浏览一下之后开始吧，预装的貌似是Cent OS 6，重装成你想要的系统吧，根据提示来，很easy。我个人比较习惯Ubuntu，所以安装了面板上支持的最新版本的Ubuntu 16.04 x86_64，面板里有一键安装Shadowsocks Server和ShadowsocksR Server功能，但个人不推荐，没啥别的原因，因为感觉不受我控制。装好后会提示你生成了一个随机的ROOT密码，记下来。执行以下步骤： 1.回到你的电脑，用你自己的方式`SSH`登陆到你的`VPS`，我用的`iTerm`，输入`ssh root@your_vps_ip_address -p your_vps_port`（本地要配置好`RSA`），默认密码是前面保存的随机密码。 2.默认ROOT密码不好记，登陆成功后输入`passwd`输入两次新的`ROOT`密码更改密码。 3.`Ubuntu`的话更新下系统，分别执行`apt-get update`和`apt-get upgrade`（不必须但建议） 安装Shadowsocks安装的方式有很多，我独爱个人认为最优的那种，执行以下命令： 123wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocksR.shchmod +x shadowsocksR.sh./shadowsocksR.sh 2&gt;&amp;1 | tee shadowsocksR.log 你也可以用&amp;&amp;连接一次性执行，按提示完成即可。 安装Google bbr一、如果你的VPS是基于KVM的，运行以下命令： 123wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.shchmod +x bbr.sh./bbr.sh 按照提示安装完成，安装完成后，检测是否成功安装： 1sysctl net.ipv4.tcp_available_congestion_control 输出的信息包含bbr就Ok了，一般为net.ipv4.tcp_available_congestion_control = bbr cubic reno 二、如果你不小心购买了基于OpenVZ的VPS，运行这个： 123wget https://raw.githubusercontent.com/kuoruan/shell-scripts/master/ovz-bbr/ovz-bbr-installer.shchmod +x ovz-bbr-installer.sh./ovz-bbr-installer.sh 这个连提示都是中文的，按照提示安装完成即可，安装完成使用看说明，检测是否安装成功： 1ping 10.0.0.2 如果能通，说明 bbr 已经启动,然后检查 iptables 规则: 1234567891011121314iptables -t nat -nLChain PREROUTING (policy ACCEPT)target prot opt source destinationLKL_IN all -- 0.0.0.0/0 0.0.0.0/0 Chain POSTROUTING (policy ACCEPT)target prot opt source destination Chain OUTPUT (policy ACCEPT)target prot opt source destination Chain LKL_IN (1 references)target prot opt source destinationDNAT tcp -- 0.0.0.0/0 0.0.0.0/0 tcp dpt:8989 to:10.0.0.2 里面有相应的端口规则。 使用Shadowsocks使用对应的客户端使用的你的Shadowsocks吧，怎么使用自行搜索。想着就那么几个步骤，还是写了这么多。。。 后记我购买时不小心买成了OpenVZ的，请教了群里的一位前辈之后告诉我联系客服，我便邮件联系官方退款了，购买了新的基于KVM，服务态度非常好，值得点赞。供参考，希望能帮到有需要的朋友。 参考资料搬瓦工(Bandwagonhost)搭建Shadowsocks并优化速度 OpenVZ 平台 Google BBR 一键安装脚本]]></content>
      <categories>
        <category>VPN</category>
      </categories>
      <tags>
        <tag>Mac使用</tag>
        <tag>BanwagonHOST</tag>
        <tag>Shadowsocks</tag>
        <tag>科学上网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Wap APP开发心得]]></title>
    <url>%2F2017%2F05%2F03%2FWap-APP%E5%BC%80%E5%8F%91%E5%BF%83%E5%BE%97%2F</url>
    <content type="text"><![CDATA[经过了一个多月，加班加点，总算完成基本完成了这个Wap APP，可以作为 Version one 面见客户了，感受不多。 MUI 结合 Hbuilder 使用 HTML5+ 开发APP整体来说还是挺顺畅的，虽然文档不完整，但是有开发经验的一眼看过去就知道怎么用了，以后做些不是大型的APP或许会成为我的首选。 算来这也算是我第三次做一个完整的 Wap 类型的 APP了，总体来说这次是最满意的，前面两个都是用的 JSP，很多特性也是依赖其完成的，但这次是纯原生页面，实现了做这个之前感觉很难的问题（至少去年这个时候感觉好难），当然了，这中间少不了 5+ 和 MUI 的功劳，遗憾的是没用上 Vue，忙的时候总是感叹自己时间不够，太多想学的东西没时间学，但些许零碎的空闲时间一有了又无法埋头去学，这样不好啊~ 这个 APP 先发布 iOS 端， 安卓端还有些许适配问题，相信这次之后，对Wap 开发 APP 能够有一个比较深的认识。]]></content>
      <categories>
        <category>APP开发</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>MUI</tag>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MUI webview选项卡 首次只加载首页，点击触发打开页面]]></title>
    <url>%2F2017%2F04%2F15%2FMUI%20webview%E9%80%89%E9%A1%B9%E5%8D%A1%20%E9%A6%96%E6%AC%A1%E5%8F%AA%E5%8A%A0%E8%BD%BD%E9%A6%96%E9%A1%B5%EF%BC%8C%E7%82%B9%E5%87%BB%E8%A7%A6%E5%8F%91%E6%89%93%E5%BC%80%E9%A1%B5%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[MUI 官方的 Demo 的加载 webview 选项卡的逻辑是一次创建全部的选项卡，只默认显示默认创建的页面，这个页面逻辑没必要这么复杂，扩展性也不强，修改一处多处要修改，我做了简单修改，直接修改数据源，就可以达到更改全部的效果。 直接上全部代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;Main&lt;/title&gt; &lt;script type="text/javascript" src="../js/config.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="../js/helper.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="../js/common-head.js"&gt;&lt;/script&gt; &lt;link rel="stylesheet" href="../css/main.css"&gt; &lt;/head&gt; &lt;body&gt; &lt;nav class="mui-bar mui-bar-tab"&gt; &lt;a class="mui-tab-item"&gt; &lt;span class="mui-icon iconfont icon-zuanshi"&gt;&lt;/span&gt; &lt;span class="mui-tab-label"&gt;&lt;/span&gt; &lt;/a&gt; &lt;a class="mui-tab-item"&gt; &lt;span class="mui-icon iconfont icon-8"&gt;&lt;/span&gt; &lt;span class="mui-tab-label"&gt;&lt;/span&gt; &lt;/a&gt; &lt;a class="mui-tab-item"&gt; &lt;span class="mui-icon iconfont icon-zoushi"&gt;&lt;/span&gt; &lt;span class="mui-tab-label"&gt;&lt;/span&gt; &lt;/a&gt; &lt;a class="mui-tab-item"&gt; &lt;span class="mui-icon iconfont icon-yonghuming"&gt;&lt;/span&gt; &lt;span class="mui-tab-label"&gt;&lt;/span&gt; &lt;/a&gt; &lt;/nav&gt; &lt;script type="text/javascript" charset="utf-8"&gt; //mui初始化 mui.init(); var subpage_style = &#123; top: '0px', bottom: '60px' &#125;; var subPages = [&#123; href: 'wonderfulRecommend.html', style: subpage_style, id: config.pageID.wonderfulRecommend, name: "精彩推荐" &#125;, &#123; href: 'lotteryHall.html', style: subpage_style, id: config.pageID.lotteryHall, name: "购彩大厅" &#125;, &#123; href: 'drawTrend-pullRefresh.html', style: subpage_style, id: config.pageID.drawTrend_pullRefresh, name: "开奖走势" &#125;, &#123; href: 'myLottery.html', style: subpage_style, id: config.pageID.myLottery, name: "我的彩票" &#125; ] // 默认显示页面 var defaultPageIndex = 0; mui.ready(function() &#123; // 动态添加 href 和名称 var tabBarItems = document.getElementsByClassName('mui-tab-item'); for(var i = 0; i &lt; tabBarItems.length; i++) &#123; var tabBarItem = tabBarItems[i]; // 设置目标页面 tabBarItem.setAttribute('href', subPages[i].href); // 设置索引 tabBarItem.setAttribute('index', i); // 设置文字标题 var tab_item_label = tabBarItem.querySelector('.mui-tab-label'); tab_item_label.innerHTML = subPages[i].name; // 默认激活的 mui-tab-item if(i == defaultPageIndex) &#123; tabBarItem.classList.add('mui-active'); &#125; &#125; &#125;) //创建子页面，首个选项卡页面显示，其它均隐藏； mui.plusReady(function() &#123; var self = plus.webview.currentWebview(); var defaultPage = plus.webview.create(subPages[defaultPageIndex].href, subPages[defaultPageIndex].id, subPages[defaultPageIndex].style); self.append(defaultPage); &#125;); var activeTab = subPages[defaultPageIndex].id; mui('.mui-bar-tab').on('tap', 'a', function(e) &#123; var targetTab = this.getAttribute('href'); if(targetTab == activeTab) &#123; return; &#125; var index = this.getAttribute('index'); log(index); // 先获取 var destPage = plus.webview.getWebviewById(subPages[index].id); if(destPage) &#123; destPage.show(); &#125; else &#123; var self = plus.webview.currentWebview(); var sub = plus.webview.create(targetTab, subPages[index].id, subPages[index].style); self.append(sub); &#125; //隐藏当前; plus.webview.hide(activeTab); //这里应该是关闭页面，不知道隐藏与关闭区别有多大 //更改当前活跃的选项卡 activeTab = targetTab; &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>MUI</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 主动选择 option]]></title>
    <url>%2F2017%2F04%2F11%2FJavaScript-%E4%B8%BB%E5%8A%A8%E9%80%89%E6%8B%A9-option%2F</url>
    <content type="text"><![CDATA[主动选择 select 中的 option 123456789// 获取默认typevar defaultType = '1';var typeSelect = document.getElementById("type");for(var i = 0; i &lt; typeSelect.options.length; i++) &#123; if(typeSelect.options[i].value === defaultType) &#123; typeSelect.selectedIndex = i; break; &#125;&#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Python脚本半自动化iOS企业版包更新]]></title>
    <url>%2F2017%2F03%2F25%2F%E4%BD%BF%E7%94%A8Python%E8%84%9A%E6%9C%AC%E5%8D%8A%E8%87%AA%E5%8A%A8%E5%8C%96iOS%E4%BC%81%E4%B8%9A%E7%89%88%E5%8C%85%E6%9B%B4%E6%96%B0%2F</url>
    <content type="text"><![CDATA[背景在我之前一篇文章里 iOS企业内部应用分发 讲述了 iOS 企业帐号打包的 ipa 分发，但是如果每次 ipa 更新，重新上传 *.ipa 后还要手动编辑 *.plist 的新的 ipa 的 url 和包的相关信息，这就和打包一样（使用 fastlane），是毫无技术含量但是花时间的事情，作为一个爱偷懒的人，我总是想利用自身所学或者一些工具来代替我做一些重复又没技术含量的事，在本文涉及的这件事里，显然，脚本要派上用场，最终选用了 Python 而没有用 Bash —- 从 ipa 读取相关信息并写入到目的 plist。Python 只是业余，如您有建议或改进，欢迎留言评论指出，感激不尽！ 直接上代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#!/usr/bin/python3#coding:utf-8 import zipfile, plistlib, sys, re, os.path, iosys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8')global plist_root # Info.plistglobal ipa_name # ipa 名称def analyze_ipa_with_plistlib(ipa_path): global plist_root ipa_file = zipfile.ZipFile(ipa_path) plist_path = find_plist_path(ipa_file) plist_data = ipa_file.read(plist_path) plist_root = plistlib.loads(plist_data) print_ipa_info (plist_root) def find_plist_path(zip_file): name_list = zip_file.namelist() pattern = re.compile(r'Payload/[^/]*.app/Info.plist') for path in name_list: m = pattern.match(path) if m is not None: return m.group()def print_ipa_info(plist_root): print ('\n' + '源 ipa 包信息:') CFBundleDisplayName = '' isCFBundleDisplayNameExist = True try: CFBundleDisplayName = plist_root['CFBundleDisplayName'] except: print ('CFBundleDisplayName 不存在，将获取 CFBundleName') isCFBundleDisplayNameExist = False if isCFBundleDisplayNameExist != True: try: CFBundleDisplayName = plist_root['CFBundleName'] except: print ('CFBundleName 不存在') print ('Display Name: %s' % CFBundleDisplayName) print ('Bundle Identifier: %s' % plist_root['CFBundleIdentifier']) print ('Version: %s' % plist_root['CFBundleShortVersionString'] + '\n') def print_plist_info(plist_path, beforeWritten): dict = plistlib.readPlist(plist_path) metadata = dict["items"][0]["metadata"] softwarePackageDict = dict["items"][0]["assets"][0] state = "前" if beforeWritten else "后" print ('写入' + state +'的plist信息') print ('bundle-identifier: %s' % metadata['bundle-identifier']) print ('bundle-version: %s' % metadata['bundle-version']) print ('title: %s' % metadata['title']) print ('ipa url: %s' % softwarePackageDict['url'] + '\n')def writeToPlist(plist_path): global plist_root # 读取app.plist dict = plistlib.readPlist(plist_path) CFBundleDisplayName = '' isCFBundleDisplayNameExist = True try: CFBundleDisplayName = plist_root['CFBundleDisplayName'] except: print ('CFBundleDisplayName 不存在，将获取 CFBundleName') isCFBundleDisplayNameExist = False if isCFBundleDisplayNameExist != True: try: CFBundleDisplayName = plist_root['CFBundleName'] except: print ('CFBundleName 不存在') # 更改包信息 metadata = dict["items"][0]["metadata"] metadata['bundle-identifier'] = plist_root['CFBundleIdentifier'] metadata['bundle-version'] = plist_root['CFBundleShortVersionString'] metadata['title'] = CFBundleDisplayName # 更改ipa地址 softwarePackageDict = dict["items"][0]["assets"][0] # 生成新的 ipa 路径 global ipa_name url = softwarePackageDict['url'] urlComArr = url.split('/') # 删除文件名 urlComArr.pop() # 删除最后一个 urlComArr.append(ipa_name) # 拼接新文件名及扩展名 newUrlComArrStr = '/'.join(urlComArr) # Array to String softwarePackageDict['url'] = newUrlComArrStr plistlib.writePlist(dict, plist_path) # 写入plist if __name__ == '__main__': args = sys.argv[1:] if len(args) != 2: print ('参数错误，用法: python3 config.py /path/to/ipa /path/to/plist') sys.exit(0) global ipa_name ipa_path = args[0] analyze_ipa_with_plistlib(ipa_path) ipa_name = os.path.basename(ipa_path) plist_path = args[1] print_plist_info(plist_path, True) writeToPlist (plist_path) print_plist_info(plist_path, False) 说明每次新打包后，需要更新 plist 文件相关信息，直接在服务器或者本地运行该脚本便可更新 plist 信息，然后覆盖服务器上的同名文件即可（亲手实践过 ipa 分发就没困惑），但运行该脚本的系统应该安装了 Python3，否则无法运行。用法如下，选你的终端执行： 1python3 config.py appName.ipa路径 app.plist路径]]></content>
      <categories>
        <category>Python3</category>
      </categories>
      <tags>
        <tag>iOS打包</tag>
        <tag>iOS企业应用更新</tag>
        <tag>Python3 读写 plist</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原生 JavaScript 判断 DOM 是否包含某个 class]]></title>
    <url>%2F2017%2F03%2F23%2F%E5%8E%9F%E7%94%9F-JavaScript-%E5%88%A4%E6%96%AD-DOM-%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E6%9F%90%E4%B8%AA-class%2F</url>
    <content type="text"><![CDATA[使用 classlist 12345678910111213if (document.body.classList.contains('thatClass')) &#123; // do some stuff&#125;Other uses of classList:document.body.classList.add('thisClass');// $('body').addClass('thisClass');document.body.classList.remove('thatClass');// $('body').removeClass('thatClass');document.body.classList.toggle('anotherClass');// $('body').toggleClass('anotherClass'); 简单封装一下12345678function hasClass(el, cn)&#123; var classes = el.classList; for(var j = 0; j &lt; classes.length; j++)&#123; if(classes[j] == cn)&#123; return true; &#125; &#125;&#125; 支持IE812345function hasClass(el, cls) &#123; var regexp = new RegExp('(\\s|^)' + cls + '(\\s|$)'), target = (typeof el.className === 'undefined') ? window.event.srcElement : el; return target.className.match(regexp);&#125; 浏览器支持 Chrome 8.0 Firefox 3.6 IE 10 Opera 11.50 Safari 5.1]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>DOM</tag>
        <tag>DOM Class</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 企业版应用一键更新]]></title>
    <url>%2F2017%2F03%2F22%2FiOS-%E4%BC%81%E4%B8%9A%E7%89%88%E5%BA%94%E7%94%A8%E4%B8%80%E9%94%AE%E6%9B%B4%E6%96%B0%2F</url>
    <content type="text"><![CDATA[如果后台没有获取版本号的接口，自己就直接从下载企业版应用指向的 plist 文件中获取吧，如果有，就不用这么麻烦还要去下载整个 plist 文件了，直接根据拿到的版本好与本地对比即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#pragma mark -#pragma mark 检查更新- (void)checkForUpdating &#123; // 先清空之前下载的缓存文件 NSString *tmpDirectory = NSTemporaryDirectory(); NSFileManager *fileManager = [NSFileManager defaultManager]; NSError *error; NSArray *cacheFiles = [fileManager contentsOfDirectoryAtPath:tmpDirectory error:&amp;error]; for (NSString *file in cacheFiles) &#123; error = nil; [fileManager removeItemAtPath:[tmpDirectory stringByAppendingPathComponent:file] error:&amp;error]; &#125; // 从服务器下载plist文件 NSURLRequest *downloadRequest = [NSURLRequest requestWithURL:[NSURL URLWithString:CheckUpdatingPlistUrl]]; NSURLSessionConfiguration *sessionConfig = [NSURLSessionConfiguration defaultSessionConfiguration]; NSURLSession *urlSession = [NSURLSession sessionWithConfiguration:sessionConfig delegate:nil delegateQueue:nil]; NSURLSessionDownloadTask *task = [urlSession downloadTaskWithRequest:downloadRequest completionHandler:^(NSURL * _Nullable location, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123; if (error) &#123; WJLog(@"获取下载服务器版本失败:\n%@", error.localizedDescription); &#125; else &#123; NSDictionary *dict = [NSDictionary dictionaryWithContentsOfURL:location]; // 服务器版本号 NSString *serverVersion = dict[@"items"][0][@"metadata"][@"bundle-version"]; // 本地版本号 NSString *localVersion = [[NSBundle mainBundle] infoDictionary][@"CFBundleShortVersionString"]; // 对比版本号，升序 if ([localVersion compare:serverVersion options:NSNumericSearch] == NSOrderedAscending) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; // 先提示安装 FCAlertView *alert = [[FCAlertView alloc] init]; [alert showAlertWithTitle:@"提示" withSubtitle:@"新版本已发布，点击确定开始更新" withCustomImage:nil withDoneButtonTitle:nil andButtons:nil]; alert.hideDoneButton = YES; alert.bounceAnimations = YES; alert.colorScheme = alert.flatOrange; [alert makeAlertTypeCaution]; alert.subTitleColor = [UIColor redColor]; [alert addButton:@"确定" withActionBlock:^&#123; // 模拟器不支持 if (TARGET_IPHONE_SIMULATOR) &#123; WJLog(@"模拟器不支持该操作"); return; &#125; // 真机执行安装 NSURL *url = [NSURL URLWithString:[NSString stringWithFormat:@"itms-services://?action=download-manifest&amp;url=%@", CheckUpdatingPlistUrl]]; [[UIApplication sharedApplication] openURL:url]; // 动画退出App UIWindow *window = [UIApplication sharedApplication].keyWindow; [UIView animateWithDuration:.5f animations:^&#123; window.alpha = 0; CGFloat width = window.bounds.size.width; CGFloat height = window.bounds.size.height; window.frame = CGRectMake(width * 0.5, height * 0.5, 0, 0); &#125; completion:^(BOOL finished) &#123; exit(0); &#125;]; &#125;]; [alert addButton:@"下次再说" withActionBlock:nil]; &#125;); &#125; &#125; &#125;]; [task resume];&#125; 那个 FCAlertView 没有可以用原生的，比如： 123456789101112131415161718192021222324252627282930313233343536// 对比版本号，升序if ([localVersion compare:serverVersion options:NSNumericSearch] == NSOrderedAscending) &#123; __weak typeof(self) weakSelf = self; dispatch_async(dispatch_get_main_queue(), ^&#123; // 先提示安装 UIAlertController *alertVc = [UIAlertController alertControllerWithTitle:@"提示" message:@"新版本已发布，点击确定开始更新" preferredStyle:UIAlertControllerStyleAlert]; UIAlertAction *confirmAct = [UIAlertAction actionWithTitle:@"确定" style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) &#123; // 模拟器不支持 if (TARGET_IPHONE_SIMULATOR) &#123; WJLog(@"模拟器不支持该操作"); return; &#125; // 真机执行安装 NSURL *url = [NSURL URLWithString:[NSString stringWithFormat:@"itms-services://?action=download-manifest&amp;url=%@", CheckUpdatingPlistUrl]]; [[UIApplication sharedApplication] openURL:url]; // 动画退出App UIWindow *window = [UIApplication sharedApplication].keyWindow; [UIView animateWithDuration:.5f animations:^&#123; window.alpha = 0; CGFloat width = window.bounds.size.width; CGFloat height = window.bounds.size.height; window.frame = CGRectMake(width * 0.5, height * 0.5, 0, 0); &#125; completion:^(BOOL finished) &#123; exit(0); &#125;]; &#125;]; // 取消 UIAlertAction *cancelAct = [UIAlertAction actionWithTitle:@"下次再说" style:UIAlertActionStyleDefault handler:nil]; [alertVc addAction:confirmAct]; [alertVc addAction:cancelAct]; [weakSelf.window.rootViewController presentViewController:alertVc animated:YES completion:nil]; &#125;);&#125;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS 应用更新</tag>
        <tag>企业版应用更新</tag>
        <tag>打包</tag>
        <tag>发布</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为 NexT 主题添加球型标签云]]></title>
    <url>%2F2017%2F03%2F19%2F%E4%B8%BA-NexT-%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E7%90%83%E5%BD%A2%E6%A0%87%E7%AD%BE%E4%BA%91%2F</url>
    <content type="text"><![CDATA[确定你已开启标签功能参考 NexT 配置文档 添加标签页面 ，开启标签功能。 了解球形标签云插件了解球形标签云 javascript 插件，点击这里 下载插件下载 js 插件 tagcanvas.js 放入对应目录将下载的 tagcanvas.js 放入主题目录 themes/NexT/source/js/custom/tagcanvas.js，custom 为新建文件夹。 新建标签云文件，引用 js在 themes/NexT/layout/_partials 下建一个 plugin 文件夹，在该目录下 touch 一个名为 tagcanvas.swig 的文件，并写入如下内容： 1234567891011121314151617181920212223242526272829303132333435363738&lt;div class="tags" id="myTags"&gt; &lt;canvas width="350" height="350" id="my3DTags"&gt; &lt;p&gt;Anything in here will be replaced on browsers that support the canvas element&lt;/p&gt; &lt;/canvas&gt;&lt;/div&gt;&lt;div class="tags" id="tags"&gt; &lt;ul style="display: none"&gt; &#123;&#123; tagcloud(&#123; min_font: 16, max_font: 35, amount: 999, color: true, start_color: 'red', end_color: 'red', &#125;) &#125;&#125; &lt;/ul&gt;&lt;/div&gt;&lt;script type="text/javascript" src="/js/custom/tagcanvas.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" &gt; window.onload = function() &#123; try &#123; TagCanvas.Start('my3DTags','tags',&#123; textFont: 'Georgia,Optima', textColour: null, outlineColour: 'black', weight: true, reverse: true, depth: 0.8, maxSpeed: 0.05, bgRadius: 1, freezeDecel: true &#125;); &#125; catch(e) &#123; // something went wrong, hide the canvas container document.getElementById('myTags').style.display = 'none'; &#125; &#125;;&lt;/script&gt; 使用 tagcanvas.swig在 themes/NexT/layout/page.swig 中作如下修改： 替换红框中原来位置的 div 标签为如下： 12&#123;# tagcanvas plugin 球型云标签 #&#125;&#123;% include '_partials/plugin/tagcanvas.swig' %&#125;]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>标签</tag>
        <tag>主题</tag>
        <tag>球形标签云</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac 彻底卸载 MYSQL 解决疑难杂症]]></title>
    <url>%2F2017%2F03%2F18%2FMac-%E5%BD%BB%E5%BA%95%E5%8D%B8%E8%BD%BD-MYSQL-%E8%A7%A3%E5%86%B3%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87%2F</url>
    <content type="text"><![CDATA[备份数据库备份看个人了，可以用软件如 Navicat 导出，也可以用 mysqldump 命令导出。 kill mysql相关进程终端运行 ps -ax | grep mysql 查看 mysql 相关进程， 有的话 kill 卸载 Homebrew 安装的mysql卸载全部以前用 brew 安装 的 mysql，先 brew list 查看安装的 mysql 版本，假如列出了 `mysql@5.5， 则运行brew uninstall mysql@5.5，卸载完后执行brew cleanup`。 移除残留文件删除与 mysql 相关的文件 12345sudo rm /usr/local/mysql;sudo rm -rf /usr/local/var/mysql;sudo rm -rf /usr/local/mysql*;sudo rm -rf /Library/StartupItems/MySQLCOM;sudo rm -rf /Library/PreferencePanes/My* 移除残留自动登陆项移除自动登陆项，如果你安装过 DMG 版本的 mysql，则把以下命令中的 LaunchAgents 替换为 LaunchDaemons 再执行一次 1launchctl unload -w ~/Library/LaunchAgents/homebrew.mxcl.mysql.plist unload 之后再删除该文件， 123sudo rm ~/Library/LaunchAgents/homebrew.mxcl.mysql.plist或sudo rm ~/Library/LaunchDaemons/homebrew.mxcl.mysql.plist 移除残留配置subl /etc/hostconfig ` 后输入 Remove the line MYSQLCOM=-YES- ` 移除残留偏好设置1234rm -rf ~/Library/PreferencePanes/My*;sudo rm -rf /Library/Receipts/mysql*;sudo rm -rf /Library/Receipts/MySQL*;sudo rm -rf /private/var/db/receipts/*mysql* 重启电脑，重新安装 mysql建议使用 Homebrew 安装 12brew search mysqlbrew install 你要的版本 启动 mysql1mysql.server start 如果报 commond not found，则在 ~/.zshrc 或者 ~/.bashrc 中加入以下两行（注意替换mysql路径）： 12export MYSQL=/usr/local/Cellar/mysql@5.6/5.6.35/support-filesexport PATH=$MYSQL:$PATH]]></content>
      <categories>
        <category>系统疑难</category>
      </categories>
      <tags>
        <tag>MYSQL</tag>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 中为多说添加最近访客]]></title>
    <url>%2F2017%2F03%2F17%2FHexo-%E4%B8%AD%E4%B8%BA%E5%A4%9A%E8%AF%B4%E6%B7%BB%E5%8A%A0%E6%9C%80%E8%BF%91%E8%AE%BF%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[添加自定义样式1. 多说后台添加到多说后台管理-&gt;设置-&gt;基本设置-&gt;自定义css中添加如下css样式： 1234567891011121314151617181920212223242526272829303132333435363738#ds-reset .ds-avatar img,#ds-recent-visitors .ds-avatar img &#123;width: 54px;height: 54px; /*设置图像的长和宽，这里要根据自己的评论框情况更改*/border-radius: 27px; /*设置图像圆角效果,在这里我直接设置了超过width/2的像素，即为圆形了*/-webkit-border-radius: 27px; /*圆角效果：兼容webkit浏览器*/-moz-border-radius: 27px;box-shadow: inset 0 -1px 0 #3333sf; /*设置图像阴影效果*/-webkit-box-shadow: inset 0 -1px 0 #3333sf;-webkit-transition: 0.4s;-webkit-transition: -webkit-transform 0.4s ease-out;transition: transform 0.4s ease-out; /*变化时间设置为0.4秒(变化动作即为下面的图像旋转360读）*/-moz-transition: -moz-transform 0.4s ease-out;&#125;#ds-reset .ds-avatar img:hover,#ds-recent-visitors .ds-avatar img:hover &#123;/*设置鼠标悬浮在头像时的CSS样式*/ box-shadow: 0 0 10px #fff;rgba(255, 255, 255, .6), inset 0 0 20px rgba(255, 255, 255, 1);-webkit-box-shadow: 0 0 10px #fff;rgba(255, 255, 255, .6), inset 0 0 20px rgba(255, 255, 255, 1);transform: rotateZ(360deg); /*图像旋转360度*/-webkit-transform: rotateZ(360deg);-moz-transform: rotateZ(360deg);&#125;/*#ds-thread #ds-reset .ds-textarea-wrapper textarea &#123;background: url(http://www.wuxubj.cn/images/duoshuo_bkground.jpg) right no-repeat;&#125;*/#ds-recent-visitors .ds-avatar &#123;float: left&#125;/*隐藏多说底部版权*/#ds-thread #ds-reset .ds-powered-by &#123;display: none;&#125; 2. Hexo 本地添加自定义CSS（推荐）打开 /themes/NexT/layout/_custom/header.swig或者 themes/NexT/source/css/_custom/custom.styl输入以下内容（custom.styl 可省略 style 标签）: 1234567891011121314151617181920212223242526272829303132333435363738&lt;style type="text/css"&gt;#ds-reset .ds-avatar img,#ds-recent-visitors .ds-avatar img &#123;width: 54px;height: 54px; /*设置图像的长和宽，这里要根据自己的评论框情况更改*/border-radius: 27px; /*设置图像圆角效果,在这里我直接设置了超过width/2的像素，即为圆形了*/-webkit-border-radius: 27px; /*圆角效果：兼容webkit浏览器*/-moz-border-radius: 27px;box-shadow: inset 0 -1px 0 #3333sf; /*设置图像阴影效果*/-webkit-box-shadow: inset 0 -1px 0 #3333sf;-webkit-transition: 0.4s;-webkit-transition: -webkit-transform 0.4s ease-out;transition: transform 0.4s ease-out; /*变化时间设置为0.4秒(变化动作即为下面的图像旋转360读）*/-moz-transition: -moz-transform 0.4s ease-out;&#125;#ds-reset .ds-avatar img:hover,#ds-recent-visitors .ds-avatar img:hover &#123;/*设置鼠标悬浮在头像时的CSS样式*/ box-shadow: 0 0 10px #fff;rgba(255, 255, 255, .6), inset 0 0 20px rgba(255, 255, 255, 1);-webkit-box-shadow: 0 0 10px #fff;rgba(255, 255, 255, .6), inset 0 0 20px rgba(255, 255, 255, 1);transform: rotateZ(360deg); /*图像旋转360度*/-webkit-transform: rotateZ(360deg);-moz-transform: rotateZ(360deg);&#125;/*#ds-thread #ds-reset .ds-textarea-wrapper textarea &#123;background: url(http://www.wuxubj.cn/images/duoshuo_bkground.jpg) right no-repeat;&#125;*/#ds-recent-visitors .ds-avatar &#123;float: left&#125;/*隐藏多说底部版权*/#ds-thread #ds-reset .ds-powered-by &#123;display: none;&#125;&lt;/style&gt; 添加 dom在需要添加最近访客的网页对应的 markdown 文件中添加如下代码： 123&gt; 最近访客&lt;div class="ds-recent-visitors" data-num-items="28" data-avatar-size="42" id="ds-recent-visitors"&gt;&lt;/div&gt;&lt;br/&gt; 添加最近访客 dom 到模板文件中（此做法更新抛弃，采用下面做法）在博客站点根目录的 scaffolds/*.md 模板文件中添加以上 dom 代码，以后新建 [layout] 便无需手动拷贝。 编辑主题配置文件在主题配置文件 _config.yml 中添加： 12# 最近访客duoshuo_recent_visit: true 修改 reward.swi 文件文件路径: 1/themes/NexT/layout/_macro/reward.swi 在顶部添加内容：123456789&#123;% if theme.duoshuo_recent_visit %&#125;&lt;blockquote&gt;&lt;p&gt;最近访客&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;div class="ds-recent-visitors" data-num-items="28" data-avatar-size="42" id="ds-recent-visitors"&gt;&lt;/div&gt;&lt;br&gt;&lt;br&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;&#123;% endif %&#125; 保存，重启 Hexo 即可]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态加载javascript]]></title>
    <url>%2F2017%2F03%2F09%2F%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BDjavascript%2F</url>
    <content type="text"><![CDATA[使用以下函数 12345678910111213141516171819var dynamicLoading = &#123; meta : function()&#123; document.write('&lt;meta charset="utf-8"&gt;'); document.write('&lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;'); document.write('&lt;meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1, maximum-scale=1, minimum-scale=1, shrink-to-fit=no"&gt;'); &#125;, css: function(path)&#123; if(!path || path.length === 0)&#123; throw new Error('argument "path" is required!'); &#125; document.write('&lt;link rel="stylesheet" type="text/css" href="' + path + '"&gt;'); &#125;, js: function(path, charset)&#123; if(!path || path.length === 0)&#123; throw new Error('argument "path" is required!'); &#125; document.write('&lt;script type="text/javascript" src="' + path + '"&gt;&lt;/script&gt;'); &#125;&#125;; 12345678910111213141516171819202122232425262728// 另外一个独立的动态加载js的函数function loadJs(jsurl, head, callback) &#123; var script = document.createElement(script); script.setAttribute("type", "text/javascript"); if(callback) &#123; if(script.readyState) &#123; //IE script.onreadystatechange = function() &#123; if(script.readyState == "loaded" || script.readyState == "complete") &#123; script.onreadystatechange = null; callback(); &#125; &#125;; &#125; else &#123; //Others script.onload = function() &#123; callback(); &#125;; &#125; &#125; script.setAttribute("src", jsurl); if(head) document.getElementsByTagName(head)[0].appendChild(script); else &#123; document.body.appendChild(script); &#125;&#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用 dumpdecrypted 砸壳]]></title>
    <url>%2F2017%2F02%2F08%2F%E5%88%A9%E7%94%A8dumpdecrypted%E7%A0%B8%E5%A3%B3%2F</url>
    <content type="text"><![CDATA[1、编译生成 dumpdecrypted.dylib 2、给生成的 dumpdecrypted.dylib 签名 3、ssh到手机，ps aux | grep 目标APP查看APP安装目录 4、（可忽略这步）cycript -p 目标 APP，执行 1[[NSFileManager defaultManager] URLsForDirectory:NSDocumentDirectory inDomains:NSUserDomainMask][0] 查看沙盒目录 5、将 dumpdecrypted.dylib拷贝 /var/tmp，进入 /var/tmp 6、将 dumpdecrypted.dylib 拷贝到沙盒目录，进入沙盒目录，执行 1DYLD_INSERT_LIBRARIES=dumpdecrypted.dylib /var/containers/Bundle/Application/0B8A6E0F-9D64-4EF4-97D2-D3A508FC3574/APP.app/APP 7、得到目标 APP.decrypted就是二进制文件]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>逆向</tag>
        <tag>iOS安全</tag>
        <tag>破解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[给包签名]]></title>
    <url>%2F2017%2F02%2F08%2F%E7%BB%99%E5%8C%85%E7%AD%BE%E5%90%8D%2F</url>
    <content type="text"><![CDATA[查看可用签名1security find-identity -v -p codesigning 签名1codesign --force --verify --verbose --sign "iPhone Developer: 396736694@qq.com (Z4965JH2C8)” 目标包]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>打包</tag>
        <tag>iOS签名</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS企业内部应用分发]]></title>
    <url>%2F2017%2F01%2F11%2FiOS%E4%BC%81%E4%B8%9A%E5%86%85%E9%83%A8%E5%BA%94%E7%94%A8%E5%88%86%E5%8F%91%2F</url>
    <content type="text"><![CDATA[iOS 支持以无线方式安装企业内部应用，而无需使用 iTunes 或 App Store。 格式要求应用格式要求:.ipa，并且使用企业内部预置描述文件进行构建，即经企业证书签名。 无线安装要求： XML 清单文件（一个 plist 配置文件） 可让设备访问 Apple iTunes 服务器的网络配置（设备要能连接互联网，因为要校验） 对于 iOS 7.1 或更高版本， plist 文件和 ipa 文件需要放在 HTTPS 的服务器上为了安装应用，用户使用特殊的 URL 前缀从您的网站上下载plist清单文件，您可以分发该特殊前缀的URL给用户或者放置于可供用户访问的互联网上。 准备分发企业内部应用: 创建应用的归档，格式为 *.ipa 格式，并且归档中包括企业内部预置描述文件，且使用分发证书签名； 无线清单文件，您可以使用支持编辑 plist 文档的编辑器编写或者直接修改下面提供的范例，各字段意义范例中会写明； 可直接供内连网或互联网访问的 HTTPS 服务器。 关于无线 plist 清单文件单文件是一个 XML plist 文件，可供 Apple 设备用来从您的 Web 服务器上查找、下载和安装应用。 以下栏是必填项： URL：应用 (*.ipa) 文件的完全限定 HTTPS URL display-image：57 x 57 px 的 PNG 图像，在下载和安装过程中显示，图片的 Web URL full-size-image：512 x 512 px 的 PNG 图像，表示 iTunes 中相应的应用，图片的 Web URL bundle-identifier：应用的包标识符，与 Xcode 项目中指定的完全一样 bundle-version：应用的包版本，在 Xcode 项目中指定 title：下载和安装过程中显示的应用的名称样本清单文件还包含可选字段。例如，如果应用文件太大，并且想要在执行错误检验（TCP 通信通常会执行该检验）的基础上确保下载的完整性，可以使用 MD5 校验，使用见范例。您也可以在一个plist文件中配置多个应用，一个 item 作为一项。 构建网站将这些项目上传到网站上可供已认证的用户访问的区域： 应用 (.ipa) 文件 清单 (.plist) 文件您的网站可以是链接到清单文件的单个页面。用户轻点 Web 链接后会下载清单文件，并触发下载和安装。以下是示例链接：&lt;a href="itms-services://?action=download-manifest&amp;url=https://example.com/manifest.plist"&gt;安装应用&lt;/a&gt; 虽然 URL 的协议部分是“itms-services”，但 iTunes Store 并不参与此过程。 配置服务器 MIME 类型（一般不用配置）您可能需要配置 Web 服务器，让清单文件和应用文件可正确传输。 对于 Server 应用，请将 MIME 类型添加到网页服务的 MIME 类型设置： application/octet-stream ipa text/xml plist 对于微软的互联网信息服务器 (IIS)，请使用 IIS Manager 在服务器的“属性”页面中添加 MIME 类型： .ipa application/octet-stream .plist text/xml 无线 iOS 应用分发故障诊断如果无线应用分发失败，并显示“无法下载”信息： 请确定应用已正确进行签名。测试方法是使用 Apple Configurator 2 将它安装到设备上，然后查看是否发生错误。 请确定清单文件的链接是否正确，清单文件是否可供网络用户访问。 请确定 .ipa 文件（在清单文件中）的 URL 是否正确，并且该 .ipa 文件是否可供网络用户通过 HTTPS 访问。 网络配置要求如果设备连接到内网，那么您必须允许它访问以下站点： https://ax.init.itunes.apple.com 使用蜂窝移动网络下载应用时，设备会限制其当前文件大小。如果无法访问此站点，安装可能会失败。 https://ppq.apple.com 设备会联系此网站，检查用来给预置描述文件签名的分发证书状态。 应用更新 程序内检查 Server 端ipa版本和本地版本，比较是否已发布新版本，并提示用户更新。 如果用户想保留旧版本数据，请告知其不要卸载旧版本，并且新旧版本 bundle-identifier 相同。 更新方法：直接使用应用内部的openURL 方法，打开的是plist文件的web url 带 itms-services描述 链接（真机）。 证书验证 用户首次打开应用时，系统会通过联系 Apple 的 OCSP 服务器来验证分发证书。如果证书已撤销，应用将不会启动。为了验证状态，设备必须能够访问 ocsp.apple.com。 OCSP 响应会在设备上缓存一段时间（由 OCSP 服务器指定），当前为 3 到 7 天之间。在重新启动设备和缓存的响应过期之前，将不会再次检查证书的有效性。如果当时收到撤销命令，系统将阻止应用运行。【警告】撤销分发证书会导致使用该证书签名的所有应用失效。只有万不得已时才应撤销证书，比如确定专用密钥已丢失或确信证书已遭破解。 示例示例 iOS 应用 plist 清单文件，可复制，保存为plist格式，也可从 这里 下载 &lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt; &lt;plist version="1.0"&gt; &lt;dict&gt; &lt;key&gt;items&lt;/key&gt; &lt;array&gt; &lt;dict&gt; &lt;key&gt;assets&lt;/key&gt; &lt;array&gt; &lt;dict&gt; &lt;key&gt;kind&lt;/key&gt; &lt;string&gt;software-package&lt;/string&gt; &lt;key&gt;md5-size&lt;/key&gt; &lt;integer&gt;10485760&lt;/integer&gt; &lt;key&gt;md5s&lt;/key&gt; &lt;array&gt; &lt;string&gt;41fa64bb7a7cae5a46bfb45821ac8bba&lt;/string&gt; &lt;string&gt;51fa64bb7a7cae5a46bfb45821ac8bba&lt;/string&gt; &lt;/array&gt; &lt;key&gt;url&lt;/key&gt; &lt;string&gt;https://www.example.com/apps/foo.ipa&lt;/string&gt; &lt;/dict&gt; &lt;dict&gt; &lt;key&gt;kind&lt;/key&gt; &lt;string&gt;display-image&lt;/string&gt; &lt;key&gt;needs-shine&lt;/key&gt; &lt;true/&gt; &lt;key&gt;url&lt;/key&gt; &lt;string&gt;https://www.example.com/image.57x57.png&lt;/string&gt; &lt;/dict&gt; &lt;dict&gt; &lt;key&gt;kind&lt;/key&gt; &lt;string&gt;full-size-image&lt;/string&gt; &lt;key&gt;md5&lt;/key&gt; &lt;string&gt;61fa64bb7a7cae5a46bfb45821ac8bba&lt;/string&gt; &lt;key&gt;needs-shine&lt;/key&gt; &lt;true/&gt; &lt;key&gt;url&lt;/key&gt;&lt;string&gt;https://www.example.com/image.512x512.jpg&lt;/string&gt; &lt;/dict&gt; &lt;/array&gt; &lt;key&gt;metadata&lt;/key&gt; &lt;dict&gt; &lt;key&gt;bundle-identifier&lt;/key&gt; &lt;string&gt;com.example.fooapp&lt;/string&gt; &lt;key&gt;bundle-version&lt;/key&gt; &lt;string&gt;1.0&lt;/string&gt; &lt;key&gt;kind&lt;/key&gt; &lt;string&gt;software&lt;/string&gt; &lt;key&gt;subtitle&lt;/key&gt; &lt;string&gt;Apple&lt;/string&gt; &lt;key&gt;title&lt;/key&gt; &lt;string&gt;Example Corporate App&lt;/string&gt; &lt;/dict&gt; &lt;/dict&gt; &lt;/array&gt; &lt;/dict&gt; &lt;/plist&gt; 简单配置示例作为包体积较小的应用，如以下简单配置即可，从这里下载 &lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt; &lt;plist version="1.0"&gt; &lt;dict&gt; &lt;key&gt;items&lt;/key&gt; &lt;array&gt; &lt;dict&gt; &lt;key&gt;assets&lt;/key&gt; &lt;array&gt; &lt;dict&gt; &lt;key&gt;kind&lt;/key&gt; &lt;string&gt;software-package&lt;/string&gt; &lt;key&gt;url&lt;/key&gt; &lt;string&gt;https://yourwebsite/appName.ipa&lt;/string&gt; &lt;/dict&gt; &lt;dict&gt; &lt;key&gt;kind&lt;/key&gt; &lt;string&gt;full-size-image&lt;/string&gt; &lt;key&gt;needs-shine&lt;/key&gt; &lt;true/&gt; &lt;key&gt;url&lt;/key&gt; &lt;string&gt;https://yourwebsite/app_icon_full_size.png&lt;/string&gt; &lt;/dict&gt; &lt;dict&gt; &lt;key&gt;kind&lt;/key&gt; &lt;string&gt;display-image&lt;/string&gt; &lt;key&gt;needs-shine&lt;/key&gt; &lt;true/&gt; &lt;key&gt;url&lt;/key&gt; &lt;string&gt;https://yourwebsite/app_icon_download.png&lt;/string&gt; &lt;/dict&gt; &lt;/array&gt; &lt;key&gt;metadata&lt;/key&gt; &lt;dict&gt; &lt;key&gt;bundle-identifier&lt;/key&gt; &lt;string&gt; your app bundle id &lt;/string&gt; &lt;key&gt;bundle-version&lt;/key&gt; &lt;string&gt;shortVersion&lt;/string&gt; &lt;key&gt;kind&lt;/key&gt; &lt;string&gt;software&lt;/string&gt; &lt;key&gt;subtitle&lt;/key&gt; &lt;string&gt;欢迎使用&lt;/string&gt; &lt;key&gt;title&lt;/key&gt; &lt;string&gt; app 名称&lt;/string&gt; &lt;/dict&gt; &lt;/dict&gt; &lt;/array&gt; &lt;/dict&gt; &lt;/plist&gt; Author: CoderJay 如需转载，请注明出处]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>打包</tag>
        <tag>发布</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac查看CPU具体型号]]></title>
    <url>%2F2016%2F12%2F16%2FMac%E6%9F%A5%E7%9C%8BCPU%E5%85%B7%E4%BD%93%E5%9E%8B%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[运行以下命令:1sysctl machdep.cpu.brand_string]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Mac使用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OC用AFN做Soap请求webService]]></title>
    <url>%2F2016%2F01%2F10%2FOC%E7%94%A8AFN%E5%81%9ASoap%E8%AF%B7%E6%B1%82webService%2F</url>
    <content type="text"><![CDATA[前言好吧，标题有点拗口。我平时一般不发帖子，因为感觉太花时间了，还是喜欢宅着研究技术。但这个帖子网上资料还是没有很详细的，周末了明天休息，所以现在写下来总结一下，也希望能帮助有这方面需求的开发者朋友，如果错误之处还请谅解，欢迎指出。排版大家就不要在意了，我也不清楚这个支不支持markdown，就直接手动简单排一下。 进入主题，最近公司做一个新项目，后台是webService，要做iOS版本的客户端，由于我以前不怎么了解这方面，所以云里雾里得摸索了两天，因为后台人员也不清楚我具体要传什么给他，所以。。。。我就两边跑。。。。最终我确定问题还是在于后端，今天上午完美解决，对webService和WSDL以及CXF有了个大概的了解。 我就不做过多的概念介绍了，我很懒不愿复制粘贴，只要说一些细节让大家少走弯路就可以。 在继续往下之前你需要先去了解一些概念：SOAP、WSDL、CXF，和他们之间的关系。这里我觉得这个帖子比较好，推荐一下，Web Service笔记（三）：wsdl 与 soap协议详解 , 对XML或者HTML稍微有点了解看了这篇文章之后对WSDL基本都能大体了解了，这里也感谢一下作者。 假定现在你对它们有个大体的了解，SOAP请求就是你发一段XML给后台，然后后台返回数据给你，它是通用的，参数后台会在XML中提取，所以我们在这个过程中其实就是在于传的XML的内容，本文也会讲到中间遇到的一些细节。 首先不要把它想的很复杂，弄通了封装一下，其实这种方式传的东西个人感觉和普通的GET/POST差不多，甚或更方便。WSDL文档由于我现在不在公司连不上服务器所以就不介绍。 开始吧首先XML内容，你的SOAP协议版本要和后台一致，不然后台报错会说版本不一致之类的，这里列出，请自行对比。 SOAP 1.1以下是 SOAP 1.1 请求和响应示例。所显示的占位符需替换为实际值。 请求 12345678910111213141516POST /WebServices/MobileCodeWS.asmx HTTP/1.1Host: webservice.webxml.com.cnContent-Type: text/xml; charset=utf-8Content-Length: lengthSOAPAction: "http://WebXml.com.cn/getMobileCodeInfo"&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;soap:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/"&gt; &lt;soap:Body&gt; &lt;getMobileCodeInfo xmlns="http://WebXml.com.cn/"&gt; &lt;mobileCode&gt;string&lt;/mobileCode&gt; &lt;userID&gt;string&lt;/userID&gt; &lt;/getMobileCodeInfo&gt; &lt;/soap:Body&gt;&lt;/soap:Envelope&gt; 响应 123456789101112HTTP/1.1 200 OKContent-Type: text/xml; charset=utf-8Content-Length: length&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;soap:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/"&gt; &lt;soap:Body&gt; &lt;getMobileCodeInfoResponse xmlns="http://WebXml.com.cn/"&gt; &lt;getMobileCodeInfoResult&gt;string&lt;/getMobileCodeInfoResult&gt; &lt;/getMobileCodeInfoResponse&gt; &lt;/soap:Body&gt;&lt;/soap:Envelope&gt; SOAP 1.2以下是 SOAP 1.2 请求和响应示例。所显示的占位符需替换为实际值。 请求 1234567891011121314POST /WebServices/MobileCodeWS.asmx HTTP/1.1Host: webservice.webxml.com.cnContent-Type: application/soap+xml; charset=utf-8Content-Length: length&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;soap12:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap12="http://www.w3.org/2003/05/soap-envelope"&gt; &lt;soap12:Body&gt; &lt;getMobileCodeInfo xmlns="http://WebXml.com.cn/"&gt; &lt;mobileCode&gt;string&lt;/mobileCode&gt; &lt;userID&gt;string&lt;/userID&gt; &lt;/getMobileCodeInfo&gt; &lt;/soap12:Body&gt;&lt;/soap12:Envelope&gt; 响应 123456789101112HTTP/1.1 200 OKContent-Type: application/soap+xml; charset=utf-8Content-Length: length&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;soap12:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap12="http://www.w3.org/2003/05/soap-envelope"&gt; &lt;soap12:Body&gt; &lt;getMobileCodeInfoResponse xmlns="http://WebXml.com.cn/"&gt; &lt;getMobileCodeInfoResult&gt;string&lt;/getMobileCodeInfoResult&gt; &lt;/getMobileCodeInfoResponse&gt; &lt;/soap12:Body&gt;&lt;/soap12:Envelope&gt; 注意点直接说注意点，拿SOAP 1.1 请求做例子，要传的XML文档为: 123456789&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;soap:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/"&gt; &lt;soap:Body&gt; &lt;getMobileCodeInfo xmlns="http://WebXml.com.cn/"&gt; &lt;mobileCode&gt;string&lt;/mobileCode&gt; &lt;userID&gt;string&lt;/userID&gt; &lt;/getMobileCodeInfo&gt; &lt;/soap:Body&gt;&lt;/soap:Envelope&gt; &lt;soap: Body&gt; 标签以外的不用改，head一般也不用传，要调用的方法和参数都包在body里面，比如这个例子中， getMobileCodeInfo 是WSDL文档发布的你要调用的方法名，其后接的xmlns是你wsdl文档中对应的 targetNameSpace ，这个和你JAVA中的 package 名对应，比如你后台JAVA代码中该方法中import的package为 com.xxxx.oooo 那么这里的xmlns就是 ooo.xxxx.com ，mobileCode和userID是这个方法中接收的参数名，那么也就是说该方法在其JAVA后台大概是这个样子 1public getMobileCodeInfo (@WebParam(name="mobileCode" , name="userID") String mobileCode, String userID) 对应的WSDL中该operation的input下也应该有两个name就是mobileCode和userID，注意@WebParam(name=”mobileCode” , name=”userID”) 不能少，这个注解让后台认识参数名，少了后台会一直报unexpected element ，我们后台一开始就少了这个，搞了很久。这种情况是参数分开传的情况，有的后台的参数直接一个request，但是里面包含有几个键值对也其实就是相当于几个参数，刚接触的新手在这里很容易绕弯，比如我后台有这个个方法 public login (WebParam(name=”req” ) String req) ，很明显这里只接一个参数，而且叫做req，但是这个请求就是需要账户名和密码，所以在对应的xml中文档应这样写body中内容 12345&lt;soap12:Body&gt; &lt;login xmlns="http://WebXml.com.cn/"&gt; &lt;req&gt;&#123;@"userNameKey": zhangsan, @"password": pwdpwd&#125;&lt;/req&gt; &lt;/login&gt;&lt;/soap12:Body&gt; NSURLSession请求soap最后请求地址就是你的wsdl文档中的Endpoint address地址，请求体就是该XML，发个POST请求就完事啦，这里又有事了，本人是强迫症，因为一开始就用的AFN请求，咋请求咋报错，于是跟着网上找的DEMO换NSURLConnection，一不小心成功了一次，但是这个iOS已经废弃了不喜欢，于是用NSURLSession，恩也成功了，但是还是感觉好麻烦，发个NSURLSession请求soap的代码: 1234567891011121314151617181920212223242526272829303132333435363738394041 NSString *soapStr = [NSString stringWithFormat:@"&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\ &lt;soap:Envelope xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\"\ xmlns:soap=\"http://schemas.xmlsoap.org/soap/envelope/\"&gt;\ &lt;soap:Header&gt;\ &lt;/soap:Header&gt;\ &lt;soap:Body&gt;\ &lt;login xmlns=\"targetNameSpace地址/\"&gt;\ &lt;param1&gt;test&lt;/param1&gt;\ &lt;param2&gt;test&lt;/param2&gt;\ &lt;/login&gt;\ &lt;/soap:Body&gt;\ &lt;/soap:Envelope&gt;"]; NSURL *url=[NSURL URLWithString:@"你自己wsdl文档中对应的endpoint address"]; NSMutableURLRequest *request=[NSMutableURLRequest requestWithURL:url]; // 访问方式 [request setHTTPMethod:@"POST"]; // 设置请求头(请求头也可以不设置，前两个设不设置都一样，应该默认的，但是SOAPAction我怎么都设置不对，不设置也可以，干脆不设置了) // [request addValue:@"text/xml; charset=utf-8" forHTTPHeaderField:@"Content-Type"];// [request addValue:[NSString stringWithFormat:@"%zd", soapStr.length] forHTTPHeaderField:@"Content-Length"]; // [request addValue:@"nameSpace/methodName" forHTTPHeaderField:@"SOAPAction"]; // body内容 [request setHTTPBody:[soapStr dataUsingEncoding:NSUTF8StringEncoding]]; NSURLSession *session = [NSURLSession sharedSession]; NSURLSessionDataTask *task = [session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123; NSString *result = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding]; WJLog(@"进入成功回调Session-----结果：%@----请求地址：%@", result, response.URL); if (error) &#123; WJLog(@"Session----失败----%@", error.localizedDescription); &#125; &#125;]; [task resume]; AFHTTPRequestOperation 请求经过和后台七改八改都无果，我干脆自己了解这些文档规范，在上午确定我操作没错之后，直接说后台那边有问题，然后后台改，重启服务器我请求没有任何进展，最后竟然是什么问题你们知道么。。前一天其实我已经传对了XML，只是后台改动的代码放错了地方，只放到了正式服没有放测试服，我也是，，，醉了，，不过也好，要是那么顺畅我就不会去过多了解这方面了。好了，要传什么，注意点都讲了，现在到了客户端的问题，用官方SDK请求是不是感觉很麻烦？是的，对于用惯了AFN或者自己封装的网络请求工具类的人来说如果每次都要写这多么代码发一次请求太痛苦了，于是我想可不可以用AFN请求SOAP，一开始想用manager发请求，直接把XML当params发POST肯定是直接挂了，于是想要设置HTTPBody要不用AFHTTPRequestOperation？没错这样确实可以，代码如下： 1234567891011121314151617NSMutableURLRequest *request=[NSMutableURLRequest requestWithURL:url]; [request setHTTPMethod:@"POST"]; [request setHTTPBody:[soapStr dataUsingEncoding:NSUTF8StringEncoding]]; AFHTTPRequestOperation *operation = [[AFHTTPRequestOperation alloc] initWithRequest:request]; // 设置返回数据格式 operation.responseSerializer = [AFHTTPResponseSerializer serializer]; [operation setCompletionBlockWithSuccess:^(AFHTTPRequestOperation * _Nonnull operation, id _Nonnull responseObject) &#123; NSString *result = [[NSString alloc] initWithData:responseObject encoding:NSUTF8StringEncoding]; WJLog(@"AFN--成功--结果：%@----返回数据%@", result, responseObject); &#125; failure:^(AFHTTPRequestOperation * _Nonnull operation, NSError * _Nonnull error) &#123; WJLog(@"AFN--失败--%@", error.localizedDescription); &#125;]; [operation start]; 这一看感觉和NSURLSession没多大差别，还是想用manager，关键问题就在于设置request的HTTBbody为XML，但是AFHTTPSessionManager已经把request封装了，默认用的params，怎么改？于是想改动或者添加AFN内部方法，但是总感觉这样不好，万一更新库了又要搞一遍。于是想能否拦截这个request，或者通过manager.requestSerializer设置HTTPBody，敲set浏览一下没有HTTPBody字眼的，用KVC也不行，那样还是相当于把XML当params传了，伤心绝望之时看到这个方法: 123 [manager.requestSerializer setQueryStringSerializationWithBlock:^NSString *(NSURLRequest *request, NSDictionary *parameters, NSError *__autoreleasing *error) &#123; // &#125;] 简单封装 AFHTTPSessionManager 请求一看里面有request 有 params 高兴了，说不定在这里能拦截，于是直接写 123[manager.requestSerializer setQueryStringSerializationWithBlock:^NSString *(NSURLRequest *request, NSDictionary *parameters, NSError *__autoreleasing *error) &#123; return soapStr;&#125;] 请求成功，happy。接下来另一个问题了，简单封装一下，我收到的是二进制，所以把AFN封装成了个工具类，供大家参考，欢迎提出改进 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/*** 请求SOAP，返回NSData** @param url 请求地址* @param soapBody soap的XML中方法和参数段* @param success 成功block* @param failure 失败block*/+ (void)SOAPData:(NSString *)url soapBody:(NSString *)soapBody success:(void (^)(id responseObject))success failure:(void(^)(NSError *error))failure &#123; NSString *soapStr = [NSString stringWithFormat: @"&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\ &lt;soap:Envelope xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\"\ xmlns:soap=\"http://schemas.xmlsoap.org/soap/envelope/\"&gt;\ &lt;soap:Header&gt;\ &lt;/soap:Header&gt;\ &lt;soap:Body&gt;%@&lt;/soap:Body&gt;\ &lt;/soap:Envelope&gt;",soapBody]; AFHTTPSessionManager *manager = [AFHTTPSessionManager manager]; manager.responseSerializer = [AFXMLParserResponseSerializer serializer]; // 设置请求超时时间 manager.requestSerializer.timeoutInterval = 30; // 返回NSData manager.responseSerializer = [AFHTTPResponseSerializer serializer]; // 设置请求头，也可以不设置 [manager.requestSerializer setValue:@"application/soap+xml; charset=utf-8" forHTTPHeaderField:@"Content-Type"]; [manager.requestSerializer setValue:[NSString stringWithFormat:@"%zd", soapStr.length] forHTTPHeaderField:@"Content-Length"]; // 设置HTTPBody [manager.requestSerializer setQueryStringSerializationWithBlock:^NSString *(NSURLRequest *request, NSDictionary *parameters, NSError *__autoreleasing *error) &#123; return soapStr; &#125;]; [manager POST:url parameters:soapStr success:^(NSURLSessionDataTask * _Nonnull task, id _Nonnull responseObject) &#123; // 把返回的二进制数据转为字符串 NSString *result = [[NSString alloc] initWithData:responseObject encoding:NSUTF8StringEncoding]; // 利用正则表达式取出&lt;return&gt;&lt;/return&gt;之间的字符串 NSRegularExpression *regular = [[NSRegularExpression alloc] initWithPattern:@"(?&lt;=return\\&gt;).*(?=&lt;/return)" options:NSRegularExpressionCaseInsensitive error:nil]; NSDictionary *dict = [NSDictionary dictionary]; for (NSTextCheckingResult *checkingResult in [regular matchesInString:result options:0 range:NSMakeRange(0, result.length)]) &#123; // 得到字典 dict = [NSJSONSerialization JSONObjectWithData:[[result substringWithRange:checkingResult.range] dataUsingEncoding:NSUTF8StringEncoding] options:NSJSONReadingMutableLeaves error:nil]; &#125; // 请求成功并且结果有值把结果传出去 if (success &amp;&amp; dict) &#123; success(dict); &#125; &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123; if (failure) &#123; failure(error); &#125; &#125;];&#125; 原文地址：OC用AFN做Soap请求webService 结束语差不多了，如果有什么问题指正欢迎大家留言。排版真的很丑，大家见谅，洗洗睡了。 Author: CoderJay 如需转载，请注明出处]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>AFN</tag>
        <tag>Soap</tag>
        <tag>WebService</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ASI 和 AFN 区别]]></title>
    <url>%2F2015%2F10%2F06%2FASI-%E5%92%8C-AFN-%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[一 底层实现 AFN的底层基于OC的NSURLConnection和NSURLSession ASI的底层基于纯C语言的CFNetwork框架 ASI的运行性能 高于 AFN 二 对服务器返回的数据处理 ASI没有直接提供对服务器数据处理的方式，直接返回data\string AFN提供了多种对服务器数据处理的方式 JSON处理 XML处理 其他处理 三 监听请求的过程 AFN提供了success和failure两个block来监听请求的过程（只能监听成功和失败） success : 请求成功后调用 failure : 请求失败后调用 ASI提供了3套方案，每一套方案都能监听请求的完整过程（监听请求开始、接收到响应头信息、接受到具体数据、接受完毕、请求失败） 成为代理，遵守协议，实现协议中的代理方法 成为代理，不遵守协议，自定义代理方法 设置block 四 在文件下载和文件上传的使用难易度 AFN 不容易监听下载进度和上传进度 不容易实现断点续传 一般只用来下载不大的文件 ASI 非常容易实现下载和上传 非常容易监听下载进度和上传进度 非常容易实现断点续传 下载或大或小的文件都行 五 ASI提供了更多的实用功能 控制圈圈要不要在请求过程中转 可以轻松地设置请求之间的依赖：每一个请求都是一个 NSOperation 对象 可以统一管理所有请求（还专门提供了一个叫做 ASINetworkQueue 来管理所有的请求对象） 暂停\恢复\取消所有的请求 监听整个队列中所有请求的下载进度和上传进度]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>网络协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OC 千位分隔符格式化数字]]></title>
    <url>%2F2015%2F08%2F16%2FOC-%E5%8D%83%E4%BD%8D%E5%88%86%E9%9A%94%E7%AC%A6%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[工作中总是碰到很多需求，比如金额需要以千位分隔的方式显示，这是OC版本转换方法，其它语言的可参考，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** 转换目标字符串为千位分隔显示 @param digitString 目标字符串 @return 转换结果字符串 */+ (NSString *)groupedThousandsDigitStringWithStr:(NSString *)digitString &#123; // 判断小数部位 NSRange rangeOfPoint = [digitString rangeOfString:@"."]; NSString *pointStr = @""; if (rangeOfPoint.length &gt;= 1) &#123; pointStr = [digitString substringFromIndex:rangeOfPoint.location]; &#125; // 去掉小数部位 digitString = [digitString substringToIndex:rangeOfPoint.location]; // 去掉小数位后长度小于3直接返回原字符 if (digitString.length &lt;= 3) return [digitString stringByAppendingString:pointStr]; NSMutableString *processString = [NSMutableString stringWithString:digitString]; NSInteger location = processString.length - 3; NSMutableArray *processArray = [NSMutableArray array]; while (location &gt;= 0) &#123; NSString *temp = [processString substringWithRange:NSMakeRange(location, 3)]; [processArray addObject:temp]; if (location &lt; 3 &amp;&amp; location &gt; 0) &#123; NSString *t = [processString substringWithRange:NSMakeRange(0, location)]; [processArray addObject:t]; &#125; location -= 3; &#125; NSMutableArray *resultsArray = [NSMutableArray array]; NSInteger k = 0; for (NSString *str in processArray) &#123; k++; NSMutableString *tmp = [NSMutableString stringWithString:str]; if (str.length &gt; 2 &amp;&amp; k &lt; processArray.count ) &#123; [tmp insertString:@"," atIndex:0]; [resultsArray addObject:tmp]; &#125; else &#123; [resultsArray addObject:tmp]; &#125; &#125; NSMutableString *resultString = [NSMutableString string]; for (NSInteger i = resultsArray.count - 1 ; i &gt;= 0; i--) &#123; NSString *tmp = [resultsArray objectAtIndex:i]; [resultString appendString:tmp]; &#125; return [resultString stringByAppendingString:pointStr];&#125;]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>格式化</tag>
        <tag>OC字符串</tag>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu 开启 ssh 登录]]></title>
    <url>%2F2013%2F04%2F02%2FUbuntu-%E5%BC%80%E5%90%AF-ssh-%E7%99%BB%E5%BD%95%2F</url>
    <content type="text"><![CDATA[电脑多了，总是需要切来切去，工作或者在家里都不止一台电脑，jenkins 构建机、网盘机等，linux 服务机我这用的基本都是 Ubuntu，记录下 Ubuntu 开启 ssh 登录。 查看是否安装了 ssh1ps -e | grep ssh 安装ssh-server服务1sudo apt-get install openssh-server 查看安装的服务1dpkg -l | grep ssh 再次ps -e | grep ssh查看 ssh 是否运行 远程登录测试1ssh user@ip]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Shell</tag>
        <tag>SSH</tag>
      </tags>
  </entry>
</search>
