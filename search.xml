<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Mac QuickLook配置]]></title>
    <url>%2F2022%2F05%2F18%2FMac-QuickLook%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[背景Mac 上的快速预览功能能很大程度上提高工作效率，系统默认支持一些常规的文件预览，一些第三方的文件就需要自己安装插件，但有些文件名后缀不被插件识别，但我们有时仅仅只是想文本预览，此时可以往第三方插件里添加支持，写此篇文章做个备忘。 手动安装放置插件目录1~/Library/QuickLook Mac 平台安装常用插件常用 QuickLook 插件很多都发布在了 homebrew，我们可以去 https://github.com/sindresorhus/quick-look-plugins 手动下载，也可以通过 homebrew 安装。 1brew install qlcolorcode qlstephen qlmarkdown quicklook-json qlimagesize suspicious-package apparency quicklookase qlvideo 更改了之后希望使插件生效123~ via ⬢ v18.0.0➜ qlmanage -rqlmanage: resetting quicklookd 10.15 Catalina 及以上处理如果 macOS 系统版本是 10.15 Catalina 及以上，且插件不能正常生效，试试 12xattr -r ~/Library/QuickLookxattr -d -r com.apple.quarantine ~/Library/QuickLook QLColorCode 类型支持扩展QLColorCode 插件可以方便以文本形式看一些文件，默认支持了很多文件类型，如果想添加更多文件类型支持，可以编辑其配置文件再使插件重新生效即可。其路径为： 1~/Library/QuickLook/QLColorCode.qlgenerator/Contents/Info.plist 在 Document Content Type Identifiers 数组下添加文件类型 查看文件信息123~ via ⬢ v18.0.0➜ mdls -name kMDItemContentType /Users/VanJay/Documents/Work/KuGou/ComposeSinger/KGComposeSinger/Podfile.lockkMDItemContentType = "dyn.ah62d4rv4ge80255drq" 记得 qlmanage -r 使插件生效 Windows 平台 QuickLook这么好用的功能如果在 Windows 能用就极好，有开发者开发了 Windows 版本的，可以试试。 https://github.com/QL-Win/QuickLook/]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>系统设置</tag>
        <tag>QuickLook</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 使用 cocoapods 组件化心得记录]]></title>
    <url>%2F2020%2F03%2F11%2FiOS-%E4%BD%BF%E7%94%A8-cocoapods-%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BF%83%E5%BE%97%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[背景2020年2月10日，在疫情的影响之下，公司只能远程开工，这天算是上班的第一天，上午召开了公司全体员工远程会议，宣贯了一些通知和公司计划。结论是：公司之前做的支付产品“ViPay”暂时停止步伐，转而进军其他领域，从宣贯至今，风头时而有变化，一会儿裁员一会又是做外包的，最后确切消息是要做一个超级 App，有点类似国内的支付宝和美团，所以之前我加了几百个小时班优化的客户端就这样夭折了，但是组件要抽出来做他用，还要为后期做容器接入第三方做准备，折腾了这么多天，记录一些小心得。 简介组件化的方案采用的是用 cocoapods 管理，搭建私有库，根据职责区分区分模块，因为项目还没真正开始，是正准备阶段，暂时是这么划分的： 1234567HDKit├── Chaos-specs 私有 cocoapods 仓库├── HDCashierKit 收银台，因为此块需要单独给第三方├── HDServiceKit 基础服务├── HDUIKit UI 组件├── HDVendorKit 对第三方库的二次加工或封装└── xmind 各模块脑图 少啰嗦，先看东西部分成果 四个库同时进行（因为相互间可能有依赖），为了能够快速验证一些想法和做法，我是这么放在一个 workspace 工作的 看看其中两个库的 podspecHDUIKit123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182Pod::Spec.new do |s| s.name = "HDUIKit" s.version = "0.4.5" s.summary = "混沌 iOS 项目组件库" s.description = &lt;&lt;-DESC HDUIKit 是一系列 iOS 组件的组成，用于快速在其他项目使用或者第三方接入 DESC s.homepage = "https://git.vipaylife.com/vipay/HDUIKit" s.license = 'MIT' s.author = &#123;"VanJay" =&gt; "wangwanjie1993@gmail.com"&#125; s.source = &#123;:git =&gt; "git@git.vipaylife.com:vipay/HDUIKit.git", :tag =&gt; s.version.to_s&#125; s.social_media_url = 'https://git.vipaylife.com/vipay/HDUIKit' s.requires_arc = true s.documentation_url = 'https://git.vipaylife.com/vipay/HDUIKit' s.screenshot = 'https://xxx.png' s.platform = :ios, '9.0' s.frameworks = 'Foundation', 'UIKit', 'CoreGraphics' s.source_files = 'HDUIKit/HDUIKit.h' s.pod_target_xcconfig = &#123; 'OTHER_LDFLAGS' =&gt; '-lObjC' &#125; s.subspec 'Core' do |ss| ss.source_files = 'HDUIKit/HDUIKit.h', 'HDUIKit/Core','HDUIKit/UIKitExtensions', 'HDUIKit/UIKitExtensions/*/*' ss.dependency 'HDUIKit/HDWeakObjectContainer' ss.dependency 'HDUIKit/HDLog' ss.dependency 'HDUIKit/HDRuntime' ss.frameworks = 'AVFoundation' end s.subspec 'MainFrame' do |ss| ss.source_files = 'HDUIKit/MainFrame' ss.dependency 'HDUIKit/HDNavigationBar' ss.dependency 'HDUIKit/HDAppTheme' ss.dependency 'HDUIKit/UIKitExtensions/UIImage' ss.resource_bundles = &#123;'HDUIKitMainFrameResources' =&gt; ['HDUIKit/MainFrame/Resources/*.*']&#125; end s.subspec 'HDNavigationBar' do |ss| ss.source_files = 'HDUIKit/MainFrame/HDNavigationBar', 'HDUIKit/MainFrame/HDNavigationBar/*/*' end s.subspec 'HDRuntime' do |ss| ss.source_files = 'HDUIKit/Core/Runtime','HDUIKit/UIKitExtensions/&#123;NSMethodSignature&#125;+HDUIKit.&#123;h,m&#125;' ss.dependency 'HDUIKit/HDLog' end s.subspec 'MethodSwizzle' do |ss| ss.source_files = 'HDUIKit/UIKitExtensions/NSObject/NSObject+HD_Swizzle.&#123;h,m&#125;' end s.subspec 'DispatchMainQueueSafe' do |ss| ss.source_files = 'HDUIKit/DispatchMainQueueSafe' end s.subspec 'HDAppTheme' do |ss| ss.source_files = 'HDUIKit/Theme' ss.dependency 'HDUIKit/UIKitExtensions/UIColor' end s.subspec 'HDWeakObjectContainer' do |ss| ss.source_files = 'HDUIKit/Components/HDWeakObjectContainer/HDWeakObjectContainer.&#123;h,m&#125;' end s.subspec 'WJFrameLayout' do |ss| ss.source_files = 'HDUIKit/WJFrameLayout' end s.subspec 'WJFunctionThrottle' do |ss| ss.source_files = 'HDUIKit/WJFunctionThrottle' end s.subspec 'HDLog' do |ss| ss.source_files = 'HDUIKit/Components/HDLog' end s.subspec 'HDCodeGenerator' do |ss| ss.source_files = 'HDUIKit/Vender/HDCodeGenerator', 'HDUIKit/Vender/HDCodeGenerator/*/*' end s.subspec 'UIKitExtensions' do |ss| ss.source_files = 'HDUIKit/UIKitExtensions', 'HDUIKit/UIKitExtensions/*/*' ss.dependency 'HDUIKit/Core' ss.subspec 'UIView' do |sss| sss.source_files = 'HDUIKit/UIKitExtensions/UIView' end ss.subspec 'NSString' do |sss| sss.source_files = 'HDUIKit/UIKitExtensions/NSString' end ss.subspec 'UIColor' do |sss| sss.source_files = 'HDUIKit/UIKitExtensions/UIColor' sss.dependency 'HDUIKit/UIKitExtensions/NSString' end ss.subspec 'UIImage' do |sss| sss.source_files = 'HDUIKit/UIKitExtensions/UIImage' sss.dependency 'HDUIKit/UIKitExtensions/NSString' end ss.subspec 'UIButton' do |sss| sss.source_files = 'HDUIKit/UIKitExtensions/UIButton' end end s.subspec 'Components' do |ss| ss.dependency 'HDUIKit/Core' ss.dependency 'HDUIKit/HDAppTheme' ss.subspec 'HDButton' do |sss| sss.source_files = 'HDUIKit/Components/HDButton' end ss.subspec 'HDCyclePagerView' do |sss| sss.source_files = 'HDUIKit/Components/HDCyclePagerView' end ss.subspec 'HDFloatLayoutView' do |sss| sss.source_files = 'HDUIKit/Components/HDFloatLayoutView' end ss.subspec 'HDGridView' do |sss| sss.source_files = 'HDUIKit/Components/HDGridView' end ss.subspec 'HDKeyBoard' do |sss| sss.source_files = 'HDUIKit/Components/HDKeyBoard' sss.dependency 'HDUIKit/Components/HDButton' sss.dependency 'HDUIKit/WJFrameLayout' end ss.subspec 'HDRatingStarView' do |sss| sss.source_files = 'HDUIKit/Components/HDRatingStarView' end ss.subspec 'HDTextView' do |sss| sss.source_files = 'HDUIKit/Components/HDTextView' sss.dependency 'HDUIKit/Components/MultipleDelegates' end ss.subspec 'HDTips' do |sss| sss.source_files = 'HDUIKit/Components/HDTips' sss.dependency 'HDUIKit/Components/ToastView' sss.dependency 'HDUIKit/Components/ProgressView' sss.resource_bundles = &#123;'HDUIKitTipsResources' =&gt; ['HDUIKit/Components/HDTips/Resources/*.*']&#125; end ss.subspec 'MultipleDelegates' do |sss| sss.source_files = 'HDUIKit/Components/MultipleDelegates' end ss.subspec 'ProgressView' do |sss| sss.source_files = 'HDUIKit/Components/ProgressView' end ss.subspec 'ToastView' do |sss| sss.source_files = 'HDUIKit/Components/ToastView', 'HDUIKit/Components/HDVisualEffectView' end ss.subspec 'HDActionAlertView' do |sss| sss.source_files = 'HDUIKit/Components/HDActionAlertView' sss.dependency 'HDUIKit/DispatchMainQueueSafe' end ss.subspec 'HDAlertView' do |sss| sss.source_files = 'HDUIKit/Components/HDAlertView' sss.dependency 'HDUIKit/Components/HDActionAlertView' sss.dependency 'HDUIKit/HDAppTheme' sss.dependency 'HDUIKit/WJFrameLayout' end ss.subspec 'NAT' do |sss| sss.source_files = 'HDUIKit/Components/NAT' sss.dependency 'FFToast', '~&gt; 1.2.0' sss.dependency 'HDUIKit/Components/HDAlertView' end endend HDServiceKit1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980Pod::Spec.new do |s| s.name = "HDServiceKit" s.version = "0.4.3" s.summary = "混沌 iOS 服务" s.description = &lt;&lt;-DESC HDServiceKit 是一系列服务以及能力，用于快速在其他项目使用或者第三方接入 DESC s.homepage = "https://git.vipaylife.com/vipay/HDServiceKit" s.license = 'MIT' s.author = &#123;"VanJay" =&gt; "wangwanjie1993@gmail.com"&#125; s.source = &#123;:git =&gt; "git@git.vipaylife.com:vipay/HDServiceKit.git", :tag =&gt; s.version.to_s&#125; s.social_media_url = 'https://git.vipaylife.com/vipay/HDServiceKit' s.requires_arc = true s.documentation_url = 'https://git.vipaylife.com/vipay/HDServiceKit' s.screenshot = 'https://xxx.png' s.platform = :ios, '9.0' s.frameworks = 'Foundation', 'UIKit' s.source_files = 'HDServiceKit/HDServiceKit.h' s.subspec 'HDCache' do |ss| ss.libraries = 'pthread' ss.source_files = 'HDServiceKit/HDCache', 'HDServiceKit/HDCache/*/*' ss.dependency 'YYModel', '~&gt; 1.0.4' ss.dependency 'UICKeyChainStore', '~&gt; 2.1.2' end s.subspec 'AntiCrash' do |ss| ss.requires_arc = ['HDServiceKit/AntiCrash/NSObjectSafe.h'] ss.source_files = 'HDServiceKit/AntiCrash' ss.dependency 'HDUIKit/MethodSwizzle' end s.subspec 'Location' do |ss| ss.source_files = 'HDServiceKit/Location', 'HDServiceKit/Location/*/*' ss.frameworks = 'CoreLocation', 'MapKit' ss.dependency 'HDUIKit/HDLog' end s.subspec 'FileOperation' do |ss| ss.source_files = 'HDServiceKit/FileOperation' end s.subspec 'HDReachability' do |ss| ss.source_files = 'HDServiceKit/HDReachability' end s.subspec 'HDPodAsset' do |ss| ss.source_files = 'HDServiceKit/HDPodAsset' end s.subspec 'HDWebViewHost' do |ss| ss.dependency 'HDServiceKit/FileOperation' ss.subspec 'Core' do |ss| ss.libraries = 'xml2', 'z' ss.frameworks = 'SafariServices', 'WebKit', 'MobileCoreServices' ss.xcconfig = &#123; "HEADER_SEARCH_PATHS" =&gt; ["$(SDKROOT)/usr/include/libxml2", "$(SDKROOT)/usr/include/libz"] &#125; ss.source_files = 'HDServiceKit/HDWebViewHost/Core', 'HDServiceKit/HDWebViewHost/Core/**/*.&#123;h,m&#125;' ss.resource_bundles = &#123;'HDWebViewHostCoreResources' =&gt; ['HDServiceKit/HDWebViewHost/Core/Resources/*.*']&#125; ss.dependency 'HDUIKit/MainFrame' ss.dependency 'HDServiceKit/HDReachability' ss.dependency 'HDUIKit/Components/HDTips' end ss.subspec 'RemoteDebug' do |ss| ss.source_files = 'HDServiceKit/HDWebViewHost/RemoteDebug', 'HDServiceKit/HDWebViewHost/RemoteDebug/GCDWebServer/**/*' ss.resource_bundles = &#123;'HDWebViewHostRemoteDebugResources' =&gt; ['HDServiceKit/HDWebViewHost/RemoteDebug/src/*']&#125; ss.dependency 'HDServiceKit/HDWebViewHost/Core' ss.dependency 'HDServiceKit/HDPodAsset' end ss.subspec 'Preloader' do |ss| ss.source_files = 'HDServiceKit/HDWebViewHost/Preloader/*/*' ss.resource_bundles = &#123;'HDWebViewHostPreloaderResources' =&gt; ['HDServiceKit/HDWebViewHost/Preloader/html/*.*']&#125; ss.dependency 'HDServiceKit/HDWebViewHost/Core' end endend 心得 subspec 的资源文件最好自己管理，不然如果 subspec 在被别处单独引入的时候，资源文件不会被拉取 一些分类文件，内部调用错综复杂，如果要考虑划分很细到每个 subspec 将痛苦不堪，建议这些文件统一放在 Core ，必要引入，如果使用了分类，记得添加配置 s.pod_target_xcconfig = { &#39;OTHER_LDFLAGS&#39; =&gt; &#39;-lObjC&#39; } cocoapods document 官方文档最新、最权威 提高效率如果你没有自己一套的便利快捷的工作流，光是文件夹和工程间切换就足以让大部分人头痛，而且还容易出错，一向懒得我在经历了一上午的折磨后就着手写脚本解放双手了。 自动生成头文件开发三方库时，往往会建立一个 import 了其他所有公用类的头文件，但是如果每增加一个功能或组件就要手动更新这个文件，实在太痛苦，可想而知，这是一项痛苦的工作，而且极度容易出错，所以我写了一个 python 脚本，在 xcode build 时自动触发，生成最新头文件，自动查找 podspec 文件，自动获取版本号，当然，也可以脱离 xcode build 执行，脚本内部做了简单判断，脚本内容如下： HeaderFileGenerator.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#!/usr/bin/python3# -*- coding: utf-8 -*-import os# 判断是否存在 podspec 文件def isExistPodspec(): allFiles = os.listdir(os.getcwd()) isExist = False for fileName in allFiles: if '.podspec' in fileName: isExist = True # 记得跳出循环 break else: isExist = False return isExist# 自动获取 podspec 文件def getPodspecFile(): listFile = os.listdir(os.getcwd()) # 文件后缀名，自动查找 file_extension = "podspec" for fileName in listFile: if fileName.endswith(file_extension): return fileName os.system("say 未找到" + file_extension + "文件") return "not found"# 自动获取版本号def getPodspecVersion(podspecFileName): podspec_path = os.getcwd() + '/' + podspecFileName versionLine = '' for line in open(podspec_path): if 's.version' in line: versionLine = line break version = '' splitStr = versionLine.split("\"") if len(splitStr) &gt; 1: version = splitStr[1] return versionif not isExistPodspec(): # xcode build 触发 # 回到上级目录 os.chdir(os.path.abspath(os.path.dirname(os.getcwd())))# podspec 文件podspecFileName = getPodspecFile()# 库名称podName = podspecFileName.split(".")[0]# 根目录ROOT_DIR_PATH = os.getcwd() + '/' + podName# 版本version = getPodspecVersion(podspecFileName)# 头文件名称HeaderFileFullName = podName + '.h'# 递归收集所有文件def fileListForDir(dir): fileList = [] for dir_path, subdir_list, file_list in os.walk(dir): # 隐私头文件目录不导入 if dir_path.find('Private') &gt; -1: print('过滤隐私目录:'+dir_path) continue # 可以在这里设置过滤不相关目录 if not(dir_path.find(".git") &gt; -1 or dir_path.find(".gitee") &gt; -1 or dir_path.find(".svn") &gt; -1 or dir_path.endswith('lproj') or dir_path.endswith('xcassets')): for fname in file_list: # if fname != HeaderFileFullName and (fname.lower().endswith(".h") or fname.lower().endswith(".c")): if fname != HeaderFileFullName and (fname.lower().endswith(".h")): full_path = os.path.join(dir_path, fname) # 这是全路径 # fileList.append(full_path + fname) fileList.append(fname) return fileListdef main(): print('开始生成头文件') print('根目录：' + ROOT_DIR_PATH) print('版本号：' + version) fileContent = '''//// %s.h// %s//// Created by VanJay on 2020/2/26.// Copyright © 2020 VanJay. All rights reserved.// This file is generated automatically.#ifndef %s_h#define %s_h#import &lt;UIKit/UIKit.h&gt;/// 版本号static NSString * const %s_VERSION = @"%s";''' % (podName, podName, podName, podName, podName, version) # 文件名列表 fileList = fileListForDir(ROOT_DIR_PATH) for filename in fileList: fileContent += '''#if __has_include("%s")#import "%s"#endif''' % (filename, filename) # 拼接尾部 fileContent += '#endif /* %s_h */' % (podName) # 写入文件 with open(ROOT_DIR_PATH + '/' + HeaderFileFullName, 'w') as file: print("生成头文件成功") file.write(fileContent)if __name__ == "__main__": main() 设置 Xcode build 触发在工程设置 Build Phases 点击加号选择 New Run Script Phase，重命名为Create Umbrella Header File（可选），输入内容： 123#!/bin/bash# 生成头文件python3 ../HeaderFileGenerator.py 脚本触发 也可在自动构建的脚本中触发，见下文 自动化发布 自动填写 commit log，自动打 tag，自动推送 tag 和对应分支代码到服务端 自动发布版本到 pod 私有库 自动打包成静态库 也可将自动自动更新头文件的脚本放置于此触发，内容如下： publish.sh 1234567891011121314151617181920212223242526272829303132333435363738394041424344 #!/bin/bash# 更新头文件python3 ./HeaderFileGenerator.pydirectory="$(pwd)"# 文件后缀名，自动查找file_extension="podspec"podspec_path=`find $directory -name "*.$file_extension" -maxdepth 1 -print`echo "podspec路径:$podspec_path"podspec_name=$(basename $podspec_path)echo "podspec名称:$podspec_name"# 获取版本号version=`grep -E "s.version |s.version=" $podspec_path | head -1 | sed 's/'s.version'//g' | sed 's/'='//g'| sed 's/'\"'//g'| sed 's/'\''//g' | sed 's/'[[:space:]]'//g'`echo "podspec版本:$version"echo "开始提交代码并打 tag：$version"filename=$(echo $podspec_name | cut -d . -f1)git rm -r --cached . -fgit add .git commit -m "published $filename $version"git push origin mastergit tag -d $versiongit push origin :refs/tags/$versiongit tag -a $version -m "$version"git push origin --tagsecho "提交及推送代码、tags 结束\n"echo "开始发布 $filename 版本 $version 到 Chaos"# 清除缓存pod cache clean --allpod repo push Chaos "$&#123;podspec_name&#125;" --allow-warnings --verbose --sources=https://github.com/CocoaPods/Specs.git,,your_private_pod_addressecho "发布 $filename 版本 $version 到 Chaos 结束\n"echo "开始打包 framework"pod package $&#123;podspec_name&#125; --no-mangle --exclude-deps --force --spec-sources=https://github.com/CocoaPods/Specs.git,your_private_pod_addressecho "打包 framework 结束\n" 快速验证 podspec 有效性 pod 仓库组件慢慢多了，每次需要发版都需要验证是否有错，如果每次都直接 pod lint，pod 会将所有的 subspec 都验证一遍，过程十分漫长，所以在确定已经开发的 subspec 没有问题的话，lint 的时候只需要验证正在开发的 subspec 有没有问题，这点只是做个提示，能够提高效率、节约时间，命令如下： 1pod lib lint --allow-warnings --verbose --sources=your_private_cocoapods_address,https://github.com/CocoaPods/Specs.git --subspec=subspec_name 专注业务这样一来，就可以把精力集中在编码和业务上，省去的时间可以多倒几杯水，记得，多喝水。每次写完新功能后，只需要执行： 1➜ sh ./publish.sh 就完事了。 关于 bundle如果使用 s.resource_bundles 让 pod 帮我们生成 bundle，注意 如果需要让所有 bundle 文件夹内文件在顶级目录（即同一级），匹配文件用 *.* 匹配： 1s.resource_bundles = &#123;'HDWebViewHostPreloaderResources' =&gt; ['HDServiceKit/HDWebViewHost/Preloader/html/*.*']&#125; 如果需要让所有 bundle 文件夹内文件保持原来的层级结构，匹配文件时后缀名不要 .*，正确使用如下： 1s.resource_bundles = &#123;'HDWebViewHostRemoteDebugResources' =&gt; ['HDServiceKit/HDWebViewHost/RemoteDebug/src/*']&#125; 这里要注意如果末尾的 /* 没写将产生另一个结果，你从该 bundle 获取资源都要在路径后拼接一个 src，所有记得写上，这样的话真实文件夹名称改变不会影响代码内获取路径。 获取 bundle附上目前个人觉得比较可靠的获取 bundle 的方法，能够兼容 Podfile 内是否使用 use_frameworks! 两种情况 123456789101112+ (NSBundle *)hd_WebViewHostCoreResources &#123; static NSBundle *resourceBundle = nil; if (!resourceBundle) &#123; NSBundle *mainBundle = [NSBundle mainBundle]; NSString *resourcePath = [mainBundle pathForResource:@"Frameworks/HDServiceKit.framework/HDWebViewHostCoreResources" ofType:@"bundle"]; if (!resourcePath) &#123; resourcePath = [mainBundle pathForResource:@"HDWebViewHostCoreResources" ofType:@"bundle"]; &#125; resourceBundle = [NSBundle bundleWithPath:resourcePath] ?: mainBundle; &#125; return resourceBundle;&#125; PS规范项目记得使用 clang-format 自动规范代码格式，毕竟看着不规范的代码难受的是自己。 pod package 需要先安装 cocoapods 插件 1sudo gem install cocoapods-packager 附录build 时自动从环境变量获取版本号，兼容 Xcode 11+123456789101112131415161718192021import xml.etree.cElementTree as ET# 自动获取版本号def autoFetchVersionNumber(): internal_version = '' # 从 Info.plist 中读取 HDServiceKit 的版本号，将其定义为一个 static const 常量以便代码里获取 infoFilePath = str(os.getenv('SRCROOT')) + \ '/%s/%s-Info.plist' % (HeaderFileName, HeaderFileName) infoTree = ET.parse(infoFilePath) infoDictList = list(infoTree.find('dict')) # 从 info.plist 获取版本号 for index in range(len(infoDictList)): element = infoDictList[index] if element.text == 'CFBundleShortVersionString': internal_version = infoDictList[index + 1].text break # Xcode 11 if internal_version.startswith('$'): internal_version = str(os.getenv('MARKETING_VERSION')) return internal_version]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>工程自动化</tag>
        <tag>iOS</tag>
        <tag>cocoapods</tag>
        <tag>组件化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[优雅得处理Xcode项目中的TODO、FIXME]]></title>
    <url>%2F2019%2F08%2F12%2F%E4%BC%98%E9%9B%85%E5%BE%97%E5%A4%84%E7%90%86Xcode%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84TODO%E3%80%81FIXME%2F</url>
    <content type="text"><![CDATA[背景在开发过程中，我们都会不时地写一些 // TODO: 和 // FIXME: 注释。有时我们这样做是因为我们知道代码可以做得更好，但暂时不确定如何做，有时由于 deadline 而没有时间编写最佳解决方案，而有时我们只是想着手处理更有趣的事情，这时我们只需在代码中标识一个 // TODO: 以便在将来某一天再处理。 痛点Xcode 默认无法自动识别这些标记，因为编辑器没有给我们强提示，所以即使有时我们立了 flag 过后也很容易忘记去实现，如下面情况所示： 解决办法利用 Xcode 工程设置 Build Phases 在 build 时执行自定义任务，点击 Build Phases 下 + 号，点击 New Run Script Phase，填入内容： 12345678KEYWORDS="STUB:|TODO:|FIXME:|DevTeam:|\?\?\?:" find "$&#123;SRCROOT&#125;" \( -name "*.h" -or -name "*.m" -or -name "*.swift" \) -not -path "$&#123;SRCROOT&#125;/Pods/*" -print0 | xargs -0 egrep --with-filename --line-number --only-matching "($KEYWORDS).*\$" | perl -p -e "s/($KEYWORDS)/1: warning: \$1/"KEYWORDS="ERROR:|XXX:|\!\!\!:" find "$&#123;SRCROOT&#125;" \( -name "*.h" -or -name "*.m" -or -name "*.swift" \) -not -path "$&#123;SRCROOT&#125;/Pods/*" -print0 | xargs -0 egrep --with-filename --line-number --only-matching "($KEYWORDS).*\$" | perl -p -e "s/($KEYWORDS)/1: error: \$1/"ERROR_OUTPUT=`find "$&#123;SRCROOT&#125;" \( -name "*.h" -or -name "*.m" -or -name "*.swift" \) -not -path "$&#123;SRCROOT&#125;/Pods/*" -print0 | xargs -0 egrep --with-filename --line-number --only-matching "($KEYWORDS).*\$" | perl -p -e "s/($KEYWORDS)/1: error: \$1/"`exit $&#123;#ERROR_OUTPUT&#125; 效果这时我们再看看效果，是不是友好多了。 建议在 TODO 等这些标记处中加上日期和作者，虽然 git 能够追溯，但是这样更直接，也就多占用几秒的时间。这使您和团队中的每个人都非常清楚 TODO 待了多长时间，以及是谁写的。目的不是追责，而是要问作者该待办事项是否仍然需要处理，以及在您使用的任何系统中是否有其它方式来跟踪必须完成的工作。 也可以从 git 中提取 TODO 的作者和日期，但这有时可能会出现问题，尤其是在移动了有 TODO 标记的代码的情况下，因为 TODO 将包含整个历史记录。一目了然，可以轻松获得有关 TODO 的基本信息。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>工程配置</tag>
        <tag>Xcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[彻底解决 iOS 导航栏样式控制问题]]></title>
    <url>%2F2019%2F07%2F01%2F%E5%BD%BB%E5%BA%95%E8%A7%A3%E5%86%B3-iOS-%E5%AF%BC%E8%88%AA%E6%A0%8F%E6%A0%B7%E5%BC%8F%E6%8E%A7%E5%88%B6%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[做 iOS 开发应该都知道，App 内导航栏样式控制一直是个问题，当 App 复杂起来后，每个界面的导航栏样式可能都不统一，包括背景颜色、是否隐藏导航栏、是否隐藏导航栏底部黑线等，如果前后两个界面样式不一致时，手势返回时（点击返回也会，只是太快不容易注意到），导航栏处就会出现明显的“断层”，极其丑陋，本文就是记录解决该问题，包含 Objective-C 和 Swift 5 的代码。 先看看效果对比 优化前 优化后 说明解决问题的核心是自定义导航控制器转场动画，每次 push 新界面时会对上一个界面“截图”，并维护这个存储的“截图”队列，覆写常用的 navigate 界面方法进行对应的维护处理，与系统一样对滑动速度做了处理，不一定是划过的临界值触发。 Show me the codeObjective-C，两个类，四个文件，包括头文件HDNavCAnimationController.h 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//// HDNavCAnimationController.h// customer//// Created by VanJay on 2019/6/6.// Copyright © 2018年 chaos network technology. All rights reserved.//#import &lt;UIKit/UIKit.h&gt;/** 导航栏操作类型 */#define ScreenWidth [UIScreen mainScreen].bounds.size.width#define ScreenHeight [UIScreen mainScreen].bounds.size.height@interface HDNavCAnimationController : NSObject &lt;UIViewControllerAnimatedTransitioning&gt;+ (instancetype)animationControllerWithOperation:(UINavigationControllerOperation)operation;+ (instancetype)animationControllerWithOperation:(UINavigationControllerOperation)operation navigationController:(UINavigationController *)navigationController;@property (nonatomic, assign) UINavigationControllerOperation navigationOperation;@property (nonatomic, weak) UINavigationController *navigationController;/** 导航栏Pop时删除了多少张截图（调用PopToViewController时，计算要删除的截图的数量） */@property (nonatomic, assign) NSInteger removeCount;/** 调用此方法删除数组最后一张截图 (调用pop手势或一次pop多个控制器时使用) */- (void)removeLastScreenShot;/** 移除全部屏幕截图 */- (void)removeAllScreenShot;/** 从截屏数组尾部移除指定数量的截图 */- (void)removeLastScreenShotWithNumber:(NSInteger)number;/** 移除指定索引的截图 */- (void)removeScreenShotAtIndex:(NSInteger)index;@end HDNavCAnimationController.m 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194//// HDNavCAnimationController.m// customer//// Created by VanJay on 2019/6/6.// Copyright © 2018年 chaos network technology. All rights reserved.//#import "HDNavCAnimationController.h"@interface HDNavCAnimationController ()@property (nonatomic, strong) NSMutableArray *screenShotArray;/** 所属的导航栏有没有TabBarController */@property (nonatomic, assign) BOOL isTabbarExist;@end@implementation HDNavCAnimationController+ (instancetype)animationControllerWithOperation:(UINavigationControllerOperation)operation navigationController:(UINavigationController *)navigationController &#123; HDNavCAnimationController *ac = [[HDNavCAnimationController alloc] init]; ac.navigationController = navigationController; ac.navigationOperation = operation; return ac;&#125;+ (instancetype)animationControllerWithOperation:(UINavigationControllerOperation)operation &#123; HDNavCAnimationController *ac = [[HDNavCAnimationController alloc] init]; ac.navigationOperation = operation; return ac;&#125;- (void)setNavigationController:(UINavigationController *)navigationController &#123; _navigationController = navigationController; UIViewController *beyondVC = self.navigationController.view.window.rootViewController; //判断该导航栏是否有TabBarController if (self.navigationController.tabBarController == beyondVC) &#123; _isTabbarExist = YES; &#125; else &#123; _isTabbarExist = NO; &#125;&#125;- (NSMutableArray *)screenShotArray &#123; if (!_screenShotArray) &#123; _screenShotArray = [[NSMutableArray alloc] init]; &#125; return _screenShotArray;&#125;- (NSTimeInterval)transitionDuration:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext &#123; return .25f;&#125;- (void)animateTransition:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext &#123; UIImageView *screentImgView = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, ScreenWidth, ScreenHeight)]; UIImage *screenImg = [self screenShot]; screentImgView.image = screenImg; // 取出fromViewController,fromView和toViewController，toView UIViewController *fromViewController = [transitionContext viewControllerForKey:UITransitionContextFromViewControllerKey]; UIViewController *toViewController = [transitionContext viewControllerForKey:UITransitionContextToViewControllerKey]; UIView *toView = [transitionContext viewForKey:UITransitionContextToViewKey]; CGRect fromViewEndFrame = [transitionContext finalFrameForViewController:fromViewController]; fromViewEndFrame.origin.x = ScreenWidth; CGRect fromViewStartFrame = fromViewEndFrame; CGRect toViewEndFrame = [transitionContext finalFrameForViewController:toViewController]; CGRect toViewStartFrame = toViewEndFrame; UIView *containerView = [transitionContext containerView]; if (self.navigationOperation == UINavigationControllerOperationPush) &#123; [self.screenShotArray addObject:screenImg]; [containerView addSubview:toView]; toView.frame = toViewStartFrame; UIView *nextVC = [[UIView alloc] initWithFrame:CGRectMake(ScreenWidth, 0, ScreenWidth, ScreenHeight)]; //将截图添加到导航栏的View所属的window上 [self.navigationController.view.window insertSubview:screentImgView atIndex:0]; nextVC.layer.shadowColor = [UIColor blackColor].CGColor; nextVC.layer.shadowOffset = CGSizeMake(-0.8, 0); nextVC.layer.shadowOpacity = 0.6; self.navigationController.view.transform = CGAffineTransformMakeTranslation(ScreenWidth, 0); [UIView animateWithDuration:[self transitionDuration:transitionContext] animations:^&#123; self.navigationController.view.transform = CGAffineTransformMakeTranslation(0, 0); screentImgView.center = CGPointMake(-ScreenWidth * 0.5, ScreenHeight * 0.5); &#125; completion:^(BOOL finished) &#123; [nextVC removeFromSuperview]; [screentImgView removeFromSuperview]; [transitionContext completeTransition:YES]; &#125;]; &#125; else if (self.navigationOperation == UINavigationControllerOperationPop) &#123; fromViewStartFrame.origin.x = 0; [containerView addSubview:toView]; UIImageView *lastVcImgView = [[UIImageView alloc] initWithFrame:CGRectMake(-ScreenWidth, 0, ScreenWidth, ScreenHeight)]; //若removeCount大于0 则说明Pop了不止一个控制器 if (_removeCount &gt; 0) &#123; for (NSInteger i = 0; i &lt; _removeCount; i++) &#123; if (i == _removeCount - 1) &#123; //当删除到要跳转页面的截图时，不再删除，并将该截图作为ToVC的截图展示 lastVcImgView.image = [self.screenShotArray lastObject]; _removeCount = 0; break; &#125; else &#123; [self.screenShotArray removeLastObject]; &#125; &#125; &#125; else &#123; lastVcImgView.image = [self.screenShotArray lastObject]; &#125; screentImgView.layer.shadowColor = [UIColor blackColor].CGColor; screentImgView.layer.shadowOffset = CGSizeMake(-0.8, 0); screentImgView.layer.shadowOpacity = 0.6; [self.navigationController.view.window addSubview:lastVcImgView]; [self.navigationController.view addSubview:screentImgView]; [UIView animateWithDuration:[self transitionDuration:transitionContext] animations:^&#123; screentImgView.center = CGPointMake(ScreenWidth * 3 * 0.5, ScreenHeight * 0.5); lastVcImgView.center = CGPointMake(ScreenWidth * 0.5, ScreenHeight * 0.5); &#125; completion:^(BOOL finished) &#123; //[self.navigationController setNavigationBarHidden:NO]; [lastVcImgView removeFromSuperview]; [screentImgView removeFromSuperview]; [self.screenShotArray removeLastObject]; [transitionContext completeTransition:YES]; &#125;]; &#125;&#125;- (void)removeLastScreenShot &#123; [self.screenShotArray removeLastObject];&#125;- (void)removeAllScreenShot &#123; [self.screenShotArray removeAllObjects];&#125;- (void)removeLastScreenShotWithNumber:(NSInteger)number &#123; for (NSInteger i = 0; i &lt; number; i++) &#123; [self.screenShotArray removeLastObject]; &#125;&#125;- (void)removeScreenShotAtIndex:(NSInteger)index &#123; if (self.screenShotArray.count - 1 &gt;= index) &#123; [self.screenShotArray removeObjectAtIndex:index]; &#125;&#125;- (UIImage *)screenShot &#123; // 将要被截图的view,即窗口的根控制器的view(必须不含状态栏,默认ios7中控制器是包含了状态栏的) UIViewController *beyondVC = self.navigationController.view.window.rootViewController; // 背景图片 总的大小 CGSize size = beyondVC.view.frame.size; // 开启上下文,使用参数之后,截出来的是原图（YES 0.0 质量高） UIGraphicsBeginImageContextWithOptions(size, YES, 0.0); // 要裁剪的矩形范围 CGRect rect = CGRectMake(0, 0, ScreenWidth, ScreenHeight); //注：iOS7以后renderInContext：由drawViewHierarchyInRect：afterScreenUpdates：替代 //判读是导航栏是否有上层的Tabbar 决定截图的对象 if (_isTabbarExist) &#123; [beyondVC.view drawViewHierarchyInRect:rect afterScreenUpdates:NO]; &#125; else &#123; [self.navigationController.view drawViewHierarchyInRect:rect afterScreenUpdates:NO]; &#125; // 从上下文中,取出UIImage UIImage *snapshot = UIGraphicsGetImageFromCurrentImageContext(); // 结束上下文(移除栈顶的基于当前位图的图形上下文) UIGraphicsEndImageContext(); // 返回截取好的图片 return snapshot;&#125;@end HDNavigationController.h 12345678910111213141516//// HDNavigationController.h// customer//// Created by VanJay on 2019/6/6.// Copyright © 2018年 chaos network technology. All rights reserved.//#import &lt;UIKit/UIKit.h&gt;@interface HDNavigationController : UINavigationController@property (nonatomic, strong) UIScreenEdgePanGestureRecognizer *panGestureRec;@end HDNavigationController.m 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318//// HDNavigationController.m// customer//// Created by VanJay on 2019/6/6.// Copyright © 2018年 chaos network technology. All rights reserved.//#import "HDNavigationController.h"#import "HDNavCAnimationController.h"#import "UtilMacro.h"// 临界滚动速度static float const limitDraggingSpeed = 800.f;#define ColorFromRGB(rgbValue) [UIColor colorWithRed:((float)((rgbValue &amp; 0xFF0000) &gt;&gt; 16)) / 255.0 green:((float)((rgbValue &amp; 0xFF00) &gt;&gt; 8)) / 255.0 blue:((float)(rgbValue &amp; 0xFF)) / 255.0 alpha:1.0]// 默认的将要变透明的遮罩的初始透明度(全黑)#define kDefaultAlpha 0.6// 当拖动的距离,占了屏幕的总宽高的3/4时, 就让imageview完全显示，遮盖完全消失#define kTargetTranslateScale 0.75@interface HDNavigationController () &lt;UIGestureRecognizerDelegate, UINavigationControllerDelegate&gt;@property (nonatomic, strong) UIImageView *screenshotImgView;@property (nonatomic, strong) UIView *coverView;@property (nonatomic, strong) NSMutableArray *screenshotImgs;@property (nonatomic, strong) UIImage *nextVCScreenShotImg;@property (nonatomic, strong) HDNavCAnimationController *animationController;@property (nonatomic, assign) CFAbsoluteTime beginDraggingTime; ///&lt; 记录用户开始拖动的时间@property (nonatomic, assign) CFAbsoluteTime endDraggingTime; ///&lt; 记录用户结束拖动的时间@property (nonatomic, assign) CGFloat beginDraggingOffsetX; ///&lt; 记录用户开始拖动的偏移量X值@property (nonatomic, assign) CGFloat endDraggingOffsetX; ///&lt; 记录用户结束拖动的偏移量X值@end@implementation HDNavigationController- (void)viewDidLoad &#123; [super viewDidLoad]; self.delegate = self; self.navigationBar.tintColor = ColorFromRGB(0x6F7179); self.view.layer.shadowColor = [UIColor blackColor].CGColor; self.view.layer.shadowOffset = CGSizeMake(-0.8, 0); self.view.layer.shadowOpacity = 0.6; // 1,创建Pan手势识别器,并绑定监听方法 _panGestureRec = [[UIScreenEdgePanGestureRecognizer alloc] initWithTarget:self action:@selector(panGestureRec:)]; _panGestureRec.edges = UIRectEdgeLeft; // 为导航控制器的view添加Pan手势识别器 [self.view addGestureRecognizer:_panGestureRec]; // 2.创建截图的ImageView _screenshotImgView = [[UIImageView alloc] init]; // app的frame是包括了状态栏高度的frame _screenshotImgView.frame = CGRectMake(0, 0, ScreenWidth, ScreenHeight); // 3.创建截图上面的黑色半透明遮罩 _coverView = [[UIView alloc] init]; // 遮罩的frame就是截图的frame _coverView.frame = _screenshotImgView.frame; // 遮罩为黑色 _coverView.backgroundColor = [UIColor blackColor]; // 4.存放所有的截图数组初始化 _screenshotImgs = [NSMutableArray array];&#125;- (nullable id&lt;UIViewControllerAnimatedTransitioning&gt;)navigationController:(UINavigationController *)navigationController animationControllerForOperation:(UINavigationControllerOperation)operation fromViewController:(UIViewController *)fromVC toViewController:(UIViewController *)toVC NS_AVAILABLE_IOS(7_0) &#123; self.animationController.navigationOperation = operation; self.animationController.navigationController = self; return self.animationController;&#125;- (HDNavCAnimationController *)animationController &#123; if (!_animationController) &#123; _animationController = [[HDNavCAnimationController alloc] init]; &#125; return _animationController;&#125;- (void)pushViewController:(UIViewController *)viewController animated:(BOOL)animated &#123; // 只有在导航控制器里面有子控制器的时候才需要截图 if (self.viewControllers.count &gt;= 1) &#123; // 调用自定义方法,使用上下文截图 [self screenShot]; &#125; [super pushViewController:viewController animated:animated];&#125;- (UIViewController *)popViewControllerAnimated:(BOOL)animated &#123; NSInteger index = self.viewControllers.count; NSString *className = nil; if (index &gt;= 2) &#123; className = NSStringFromClass(self.viewControllers[index - 2].class); &#125; if (_screenshotImgs.count &gt;= index - 1) &#123; [_screenshotImgs removeLastObject]; &#125; return [super popViewControllerAnimated:animated];&#125;- (NSArray&lt;UIViewController *&gt; *)popToViewController:(UIViewController *)viewController animated:(BOOL)animated &#123; NSInteger removeCount = 0; for (NSInteger i = self.viewControllers.count - 1; i &gt; 0; i--) &#123; if (viewController == self.viewControllers[i]) &#123; break; &#125; [_screenshotImgs removeLastObject]; removeCount++; &#125; _animationController.removeCount = removeCount; return [super popToViewController:viewController animated:animated];&#125;- (NSArray&lt;UIViewController *&gt; *)popToRootViewControllerAnimated:(BOOL)animated &#123; [_screenshotImgs removeAllObjects]; [_animationController removeAllScreenShot]; return [super popToRootViewControllerAnimated:animated];&#125;- (void)setViewControllers:(NSArray&lt;__kindof UIViewController *&gt; *)viewControllers &#123; // 获取当前 viewControllers NSArray&lt;__kindof UIViewController *&gt; *currentViewControllers = self.viewControllers; if (viewControllers.count != currentViewControllers.count) &#123; // 数量不一致，获取差异控制器，得到索引，移除截图 for (UIViewController *oldVC in currentViewControllers) &#123; if (![viewControllers containsObject:oldVC]) &#123; NSInteger index = [currentViewControllers indexOfObject:oldVC]; if (_screenshotImgs.count - 1 &gt;= index) &#123; [_screenshotImgs removeObjectAtIndex:index]; &#125; [_animationController removeScreenShotAtIndex:index]; &#125; &#125; &#125; [super setViewControllers:viewControllers];&#125;// 使用上下文截图,并使用指定的区域裁剪,模板代码- (void)screenShot &#123; // 将要被截图的view,即窗口的根控制器的view(必须不含状态栏,默认ios7中控制器是包含了状态栏的) UIViewController *beyondVC = self.view.window.rootViewController; // 背景图片 总的大小 CGSize size = beyondVC.view.frame.size; // 开启上下文,使用参数之后,截出来的是原图（YES 0.0 质量高） UIGraphicsBeginImageContextWithOptions(size, YES, 0.0); // 要裁剪的矩形范围 CGRect rect = CGRectMake(0, 0, ScreenWidth, ScreenHeight); //注：iOS7以后renderInContext：由drawViewHierarchyInRect：afterScreenUpdates：替代 //判读是导航栏是否有上层的Tabbar 决定截图的对象 if (self.tabBarController == beyondVC) &#123; [beyondVC.view drawViewHierarchyInRect:rect afterScreenUpdates:NO]; &#125; else &#123; [self.view drawViewHierarchyInRect:rect afterScreenUpdates:NO]; &#125; // 从上下文中,取出UIImage UIImage *snapshot = UIGraphicsGetImageFromCurrentImageContext(); // 添加截取好的图片到图片数组 if (snapshot) &#123; [_screenshotImgs addObject:snapshot]; &#125; // 结束上下文(移除栈顶的基于当前位图的图形上下文) UIGraphicsEndImageContext();&#125;// 监听手势的方法,只要是有手势就会执行- (void)panGestureRec:(UIScreenEdgePanGestureRecognizer *)panGestureRec &#123; // 如果当前显示的控制器已经是根控制器了，不需要做任何切换动画,直接返回 if (self.visibleViewController == self.viewControllers[0]) return; // 判断pan手势的各个阶段 switch (panGestureRec.state) &#123; case UIGestureRecognizerStateBegan: // 开始拖拽阶段 [self dragBegin]; break; case UIGestureRecognizerStateCancelled: case UIGestureRecognizerStateFailed: case UIGestureRecognizerStateEnded: // 结束拖拽阶段 [self dragEnd]; break; default: // 正在拖拽阶段 [self dragging:panGestureRec]; break; &#125;&#125;#pragma mark 开始拖动,添加图片和遮罩- (void)dragBegin &#123; // 重点,每次开始Pan手势时,都要添加截图imageview 和 遮盖cover到window中 [self.view.window insertSubview:_screenshotImgView atIndex:0]; [self.view.window insertSubview:_coverView aboveSubview:_screenshotImgView]; // 并且,让imgView显示截图数组中的最后(最新)一张截图 _screenshotImgView.image = [_screenshotImgs lastObject]; UIViewController *lastVC = self.viewControllers.lastObject; if (lastVC) &#123; // 隐藏键盘 [lastVC.view endEditing:YES]; &#125; // 记录用户开始拖动的时间 self.beginDraggingTime = CFDateGetAbsoluteTime((CFDateRef)[NSDate date]); // 记录用户开始拖动的偏移量Y值 self.beginDraggingOffsetX = 0;&#125;#pragma mark 正在拖动,动画效果的精髓,进行位移和透明度变化- (void)dragging:(UIPanGestureRecognizer *)pan &#123; // 得到手指拖动的位移 CGFloat offsetX = [pan translationInView:self.view].x; // 让整个view都平移 // 挪动整个导航view if (offsetX &gt; 0) &#123; self.view.transform = CGAffineTransformMakeTranslation(offsetX, 0); &#125; // 计算目前手指拖动位移占屏幕总的宽高的比例,当这个比例达到3/4时, 就让imageview完全显示，遮盖完全消失 double currentTranslateScaleX = offsetX / self.view.frame.size.width; if (offsetX &lt; ScreenWidth) &#123; _screenshotImgView.transform = CGAffineTransformMakeTranslation((offsetX - ScreenWidth) * 0.6, 0); &#125; // 让遮盖透明度改变,直到减为0,让遮罩完全透明,默认的比例-(当前平衡比例/目标平衡比例)*默认的比例 double alpha = kDefaultAlpha - (currentTranslateScaleX / kTargetTranslateScale) * kDefaultAlpha; _coverView.alpha = alpha;&#125;#pragma mark 结束拖动,判断结束时拖动的距离作相应的处理,并将图片和遮罩从父控件上移除- (void)dragEnd &#123; // 取出挪动的距离 CGFloat translateX = self.view.transform.tx; // 取出宽度 CGFloat width = self.view.frame.size.width; // 记录用户结束拖动的时间 self.endDraggingTime = CFDateGetAbsoluteTime((CFDateRef)[NSDate date]); // 记录用户结束拖动的偏移量Y值 self.endDraggingOffsetX = translateX; // 计算得到间隔时间 CFAbsoluteTime minusTime = self.endDraggingTime - self.beginDraggingTime; // 间隔offset CGFloat minusOffset = self.endDraggingOffsetX - self.beginDraggingOffsetX; float draggingSpeed = ABS(minusOffset) / minusTime; HDLog(@"滑动速度：%.0f", draggingSpeed); if (draggingSpeed &gt; limitDraggingSpeed || translateX &gt; ScreenWidth * 0.5) &#123; // 如果手指移动的距离超过了屏幕的一半，或者滑动速度达到临界值，往右边挪 [UIView animateWithDuration:0.25 animations:^&#123; // 让被右移的view完全挪到屏幕的最右边,结束之后,还要记得清空view的transform self.view.transform = CGAffineTransformMakeTranslation(width, 0); // 让imageView位移还原 self.screenshotImgView.transform = CGAffineTransformMakeTranslation(0, 0); // 让遮盖alpha变为0,变得完全透明 self.coverView.alpha = 0; &#125; completion:^(BOOL finished) &#123; // 重要~~让被右移的view完全挪到屏幕的最右边,结束之后,还要记得清空view的transform,不然下次再次开始drag时会出问题,因为view的transform没有归零 self.view.transform = CGAffineTransformIdentity; // 移除两个view,下次开始拖动时,再加回来 [self.screenshotImgView removeFromSuperview]; [self.coverView removeFromSuperview]; // 执行正常的Pop操作:移除栈顶控制器,让真正的前一个控制器成为导航控制器的栈顶控制器 [self popViewControllerAnimated:NO]; // 重要~记得这时候,可以移除截图数组里面最后一张没用的截图了 [self.animationController removeLastScreenShot]; &#125;]; &#125; else &#123; // 如果手指移动的距离还不到屏幕的一半, 或者滑动速度未达到临界值，恢复原样 [UIView animateWithDuration:0.25 animations:^&#123; // 重要~~让被右移的view弹回归位,只要清空transform即可办到 self.view.transform = CGAffineTransformIdentity; // 让imageView大小恢复默认的translation self.screenshotImgView.transform = CGAffineTransformMakeTranslation(-ScreenWidth, 0); // 让遮盖的透明度恢复默认的alpha 1.0 self.coverView.alpha = kDefaultAlpha; &#125; completion:^(BOOL finished) &#123; // 重要,动画完成之后,每次都要记得 移除两个view,下次开始拖动时,再添加进来 [self.screenshotImgView removeFromSuperview]; [self.coverView removeFromSuperview]; &#125;]; &#125;&#125;@end Swift 5，两个文件NavigationTransition.swift 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184//// NavigationTransition.swift// ViPay//// Created by VanJay on 2019/6/30.// Copyright © 2019 VanJay. All rights reserved.//import UIKitclass NavigationTransition: NSObject &#123; var navigationOperation: UINavigationController.Operation! weak var navigationController: UINavigationController? &#123; willSet &#123; let rootViewController = navigationController?.view.window?.rootViewController if rootViewController == navigationController?.tabBarController &#123; isTabbarExist = true &#125; else &#123; isTabbarExist = false &#125; &#125; &#125; /// 导航栏Pop时删除了多少张截图（调用PopToViewController时，计算要删除的截图的数量） var removeCount = 0 private lazy var screenShotArray = [UIImage]() /// 所属的导航栏有没有TabBarController private var isTabbarExist: Bool = false convenience init(operation: UINavigationController.Operation) &#123; self.init() navigationOperation = operation &#125; convenience init(operation: UINavigationController.Operation, navigationController: UINavigationController?) &#123; self.init() navigationOperation = operation self.navigationController = navigationController &#125; // MARK: - public methods /// 调用此方法删除数组最后一张截图 (调用pop手势或一次pop多个控制器时使用) func removeLastScreenShot() &#123; screenShotArray.removeLast() &#125; /// 移除全部屏幕截图 func removeAllScreenShot() &#123; screenShotArray.removeAll() &#125; /// 从截屏数组尾部移除指定数量的截图 func removeLastScreenShot(withNumber number: Int) &#123; for _ in 0 ..&lt; number &#123; screenShotArray.removeLast() &#125; &#125; /// 移除指定索引的截图 func removeScreenShot(at index: Int) &#123; guard screenShotArray.count - 1 &gt;= index else &#123; return &#125; screenShotArray.remove(at: index) &#125;&#125;extension NavigationTransition: UIViewControllerAnimatedTransitioning &#123; // MARK: - UIViewControllerAnimatedTransitioning func transitionDuration(using _: UIViewControllerContextTransitioning?) -&gt; TimeInterval &#123; return 0.25 &#125; func animateTransition(using transitionContext: UIViewControllerContextTransitioning) &#123; let screentImgView = UIImageView(frame: CGRect(x: 0, y: 0, width: UIScreen.width, height: UIScreen.height)) let screenImg = screenShot() screentImgView.image = screenImg // 取出fromViewController,fromView和toViewController，toView let fromViewController = (transitionContext.viewController(forKey: UITransitionContextViewControllerKey.from))! let toViewController = transitionContext.viewController(forKey: UITransitionContextViewControllerKey.to) let toView = transitionContext.view(forKey: UITransitionContextViewKey.to) var fromViewEndFrame = transitionContext.finalFrame(for: fromViewController) fromViewEndFrame.origin.x = UIScreen.width var fromViewStartFrame = fromViewEndFrame let toViewEndFrame = transitionContext.finalFrame(for: toViewController!) let toViewStartFrame = toViewEndFrame let containerView = transitionContext.containerView if navigationOperation == UINavigationController.Operation.push &#123; screenShotArray.append(screenImg) containerView.addSubview(toView!) toView?.frame = toViewStartFrame let nextVC = UIView(frame: CGRect(x: UIScreen.width, y: 0, width: UIScreen.width, height: UIScreen.height)) // 将截图添加到导航栏的View所属的window上 navigationController?.view.window?.insertSubview(screentImgView, at: 0) nextVC.layer.shadowColor = UIColor.black.cgColor nextVC.layer.shadowOffset = CGSize(width: -0.8, height: 0) nextVC.layer.shadowOpacity = 0.6 navigationController?.view.transform = CGAffineTransform(translationX: UIScreen.width, y: 0) UIView.animate(withDuration: transitionDuration(using: transitionContext), animations: &#123; self.navigationController?.view.transform = CGAffineTransform(translationX: 0, y: 0) screentImgView.center = CGPoint(x: -UIScreen.width * 0.5, y: UIScreen.height * 0.5) &#125;) &#123; _ in nextVC.removeFromSuperview() screentImgView.removeFromSuperview() transitionContext.completeTransition(true) &#125; &#125; else if navigationOperation == UINavigationController.Operation.pop &#123; fromViewStartFrame.origin.x = 0 containerView.addSubview(toView!) let lastVcImgView = UIImageView(frame: CGRect(x: UIScreen.width, y: 0, width: UIScreen.width, height: UIScreen.height)) // 若removeCount大于0 则说明Pop了不止一个控制器 if removeCount &gt; 0 &#123; for i in 0 ..&lt; removeCount &#123; if i == removeCount - 1 &#123; // 当删除到要跳转页面的截图时，不再删除，并将该截图作为ToVC的截图展示 lastVcImgView.image = screenShotArray.last removeCount = 0 break &#125; else &#123; screenShotArray.removeLast() &#125; &#125; &#125; else &#123; lastVcImgView.image = screenShotArray.last &#125; screentImgView.layer.shadowColor = UIColor.black.cgColor screentImgView.layer.shadowOffset = CGSize(width: -0.8, height: 0) screentImgView.layer.shadowOpacity = 0.6 navigationController?.view.window?.addSubview(lastVcImgView) navigationController?.view.window?.addSubview(screentImgView) UIView.animate(withDuration: transitionDuration(using: transitionContext), animations: &#123; screentImgView.center = CGPoint(x: UIScreen.width * 3 * 0.5, y: UIScreen.height * 0.5) lastVcImgView.center = CGPoint(x: UIScreen.width * 0.5, y: UIScreen.height * 0.5) &#125;) &#123; _ in lastVcImgView.removeFromSuperview() screentImgView.removeFromSuperview() self.screenShotArray.removeLast() transitionContext.completeTransition(true) &#125; &#125; &#125; func screenShot() -&gt; UIImage &#123; // 将要被截图的view,即窗口的根控制器的view(必须不含状态栏,默认ios7中控制器是包含了状态栏的) let rootViewController = navigationController?.view?.window?.rootViewController // 背景图片 总的大小 let size = rootViewController!.view.frame.size // 开启上下文,使用参数之后,截出来的是原图（YES 0.0 质量高） UIGraphicsBeginImageContextWithOptions(size, true, 0.0) // 要裁剪的矩形范围 let rect = CGRect(x: 0, y: 0, width: UIScreen.width, height: UIScreen.height) // 注：iOS7以后renderInContext：由drawViewHierarchyInRect：afterScreenUpdates：替代 // 判读是导航栏是否有上层的Tabbar 决定截图的对象 if isTabbarExist &#123; rootViewController?.view.drawHierarchy(in: rect, afterScreenUpdates: false) &#125; else &#123; navigationController?.view.drawHierarchy(in: rect, afterScreenUpdates: false) &#125; // 从上下文中,取出UIImage let snapshot = UIGraphicsGetImageFromCurrentImageContext() // 结束上下文(移除栈顶的基于当前位图的图形上下文) UIGraphicsEndImageContext() // 返回截取好的图片 return snapshot! &#125;&#125; NavigationController.swift 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297//// NavigationController.swift// ViPay//// Created by VanJay on 2019/6/30.// Copyright © 2019 VanJay. All rights reserved.//import UIKitclass NavigationController: UINavigationController &#123; /// 临界滚动速度 private let limitDraggingSpeed: CGFloat = 800.0 /// 默认的将要变透明的遮罩的初始透明度(全黑) private let kDefaultAlpha: CGFloat = 0.6 /// 当拖动的距离,占了屏幕的总宽高的 3/4 时, 就让imageview完全显示，遮盖完全消失 private let kTargetTranslateScale: CGFloat = 0.75 private var panGestureRec: UIScreenEdgePanGestureRecognizer! private var screenshotImgView: UIImageView! private var coverView: UIView! private var screenshotImgs: [UIImage]! private var nextVCScreenShotImg: UIImage? private lazy var animationController: NavigationTransition = &#123; NavigationTransition() &#125;() /// 记录用户开始拖动的时间 private var beginDraggingTime: TimeInterval = 0.0 /// 记录用户结束拖动的时间 private var endDraggingTime: TimeInterval = 0.0 /// 记录用户开始拖动的偏移量X值 private var beginDraggingOffsetX: CGFloat = 0.0 /// 记录用户结束拖动的偏移量X值 private var endDraggingOffsetX: CGFloat = 0.0 override func viewDidLoad() &#123; super.viewDidLoad() delegate = self navigationBar.tintColor = UIColor(hexString: "#6F7179") view.layer.shadowColor = UIColor.black.cgColor view.layer.shadowOffset = CGSize(width: -0.8, height: 0) view.layer.shadowOpacity = 0.6 // 1,创建Pan手势识别器,并绑定监听方法 let panGestureRec = UIScreenEdgePanGestureRecognizer(target: self, action: #selector(screenEdgeSwiped)) panGestureRec.edges = .left // 为导航控制器的view添加Pan手势识别器 view.addGestureRecognizer(panGestureRec) self.panGestureRec = panGestureRec // 2.创建截图的ImageView screenshotImgView = UIImageView() // app的frame是包括了状态栏高度的frame screenshotImgView.frame = CGRect(x: 0, y: 0, width: UIScreen.width, height: UIScreen.height) // 3.创建截图上面的黑色半透明遮罩 coverView = UIView() // 遮罩的frame就是截图的frame coverView.frame = screenshotImgView.frame // 遮罩为黑色 coverView.backgroundColor = .black // 4.存放所有的截图数组初始化 screenshotImgs = [UIImage]() &#125; // MARK: - event @objc func screenEdgeSwiped(_ recognizer: UIScreenEdgePanGestureRecognizer) &#123; // 如果当前显示的控制器已经是根控制器了，不需要做任何切换动画,直接返回 guard visibleViewController != viewControllers[0] else &#123; return &#125; // 判断pan手势的各个阶段 switch panGestureRec.state &#123; case .began: // 开始拖拽阶段 dragBegin() case .cancelled, .failed, .ended: // 结束拖拽阶段 dragEnd() default: // 正在拖拽阶段 dragging(recognizer: recognizer) &#125; &#125; // MARK: - override override func pushViewController(_ viewController: UIViewController, animated: Bool) &#123; // 只有在导航控制器里面有子控制器的时候才需要截图 if viewControllers.count &gt;= 1 &#123; // 调用自定义方法,使用上下文截图 screenShot() &#125; super.pushViewController(viewController, animated: animated) &#125; override func popViewController(animated: Bool) -&gt; UIViewController? &#123; let index = viewControllers.count if screenshotImgs.count &gt;= index - 1 &#123; screenshotImgs.removeLast() &#125; return super.popViewController(animated: animated) &#125; override func popToViewController(_ viewController: UIViewController, animated: Bool) -&gt; [UIViewController]? &#123; var removeCount = 0 var count = viewControllers.count - 1 while count &gt; 0 &#123; if viewController == viewControllers[count] &#123; break &#125; count = count - 1 removeCount = removeCount + 1 &#125; animationController.removeCount = removeCount return super.popToViewController(viewController, animated: animated) &#125; override func popToRootViewController(animated: Bool) -&gt; [UIViewController]? &#123; screenshotImgs.removeAll() animationController.removeAllScreenShot() return super.popToRootViewController(animated: animated) &#125; override func setViewControllers(_ viewControllers: [UIViewController], animated: Bool) &#123; // 获取当前 viewControllers let currentViewControllers = self.viewControllers if viewControllers.count != currentViewControllers.count &#123; // 数量不一致，获取差异控制器，得到索引，移除截图 for case let oldVC in currentViewControllers as [UIViewController] &#123; if !viewControllers.contains(oldVC) &#123; if let index = currentViewControllers.firstIndex(of: oldVC) &#123; if screenshotImgs.count - 1 &gt;= index &#123; screenshotImgs.remove(at: index) &#125; animationController.removeScreenShot(at: index) &#125; &#125; &#125; &#125; super.setViewControllers(viewControllers, animated: animated) &#125; // MARK: - provate methods /// 拖动开始 private func dragBegin() &#123; // 重点,每次开始Pan手势时,都要添加截图imageview 和 遮盖cover到window中 view.window?.insertSubview(screenshotImgView, at: 0) view.window?.insertSubview(coverView, aboveSubview: screenshotImgView) // 并且,让imgView显示截图数组中的最后(最新)一张截图 screenshotImgView.image = screenshotImgs.last if let lastVC = self.viewControllers.last &#123; // 隐藏键盘 lastVC.view.endEditing(true) &#125; // 记录用户开始拖动的时间 beginDraggingTime = Date().timeIntervalSince1970 // 记录用户开始拖动的偏移量Y值 beginDraggingOffsetX = 0 &#125; /// 拖动结束 private func dragEnd() &#123; // 取出挪动的距离 let translateX = view.transform.tx // 取出宽度 let width = view.frame.size.width // 记录用户结束拖动的时间 endDraggingTime = Date().timeIntervalSince1970 // 记录用户结束拖动的偏移量Y值 endDraggingOffsetX = translateX // 计算得到间隔时间 let minusTime = endDraggingTime - beginDraggingTime // 间隔offset let minusOffset = endDraggingOffsetX - beginDraggingOffsetX let draggingSpeed = abs(CGFloat(minusOffset)) / CGFloat(minusTime) printLog("滑动速度:\(draggingSpeed)") if draggingSpeed &gt; limitDraggingSpeed || translateX &gt; UIScreen.width * 0.5 &#123; // 如果手指移动的距离超过了屏幕的一半，或者滑动速度达到临界值，往右边挪 UIView.animate(withDuration: 0.25, animations: &#123; // 让被右移的view完全挪到屏幕的最右边,结束之后,还要记得清空view的transform self.view.transform = CGAffineTransform(translationX: width, y: 0) // 让imageView位移还原 self.screenshotImgView.transform = CGAffineTransform(translationX: 0, y: 0) // 让遮盖alpha变为0,变得完全透明 self.coverView.alpha = 0 &#125;) &#123; _ in // 重要~~让被右移的view完全挪到屏幕的最右边,结束之后,还要记得清空view的transform,不然下次再次开始drag时会出问题,因为view的transform没有归零 self.view.transform = CGAffineTransform.identity // 移除两个view,下次开始拖动时,再加回来 self.screenshotImgView.removeFromSuperview() self.coverView.removeFromSuperview() // 执行正常的Pop操作:移除栈顶控制器,让真正的前一个控制器成为导航控制器的栈顶控制器 _ = self.popViewController(animated: false) // 重要~记得这时候,可以移除截图数组里面最后一张没用的截图了 self.animationController.removeLastScreenShot() &#125; &#125; else &#123; // 如果手指移动的距离还不到屏幕的一半, 或者滑动速度未达到临界值，恢复原样 UIView.animate(withDuration: 0.25, animations: &#123; // 重要~~让被右移的view弹回归位,只要清空transform即可办到 self.view.transform = CGAffineTransform.identity // 让imageView大小恢复默认的translation self.screenshotImgView.transform = CGAffineTransform(translationX: -UIScreen.width, y: 0) // 让遮盖的透明度恢复默认的alpha 1.0 self.coverView.alpha = self.kDefaultAlpha &#125;) &#123; _ in // 重要,动画完成之后,每次都要记得 移除两个view,下次开始拖动时,再添加进来 self.screenshotImgView.removeFromSuperview() self.coverView.removeFromSuperview() &#125; &#125; &#125; /// 正在拖动 private func dragging(recognizer: UIScreenEdgePanGestureRecognizer) &#123; // 得到手指拖动的位移 let offsetX = recognizer.translation(in: view).x // 让整个view都平移 // 挪动整个导航view if offsetX &gt; 0 &#123; view.transform = CGAffineTransform(translationX: offsetX, y: 0) &#125; // 计算目前手指拖动位移占屏幕总的宽高的比例,当这个比例达到3/4时, 就让imageview完全显示，遮盖完全消失 let currentTranslateScaleX = offsetX / view.frame.size.width if offsetX &lt; UIScreen.width &#123; screenshotImgView.transform = CGAffineTransform(translationX: (offsetX - UIScreen.width) * 0.6, y: 0) &#125; // 让遮盖透明度改变,直到减为0,让遮罩完全透明,默认的比例-(当前平衡比例/目标平衡比例)*默认的比例 let alpha = kDefaultAlpha - currentTranslateScaleX / kTargetTranslateScale * kDefaultAlpha coverView.alpha = alpha &#125; private func screenShot() &#123; // 将要被截图的view,即窗口的根控制器的view(必须不含状态栏,默认ios7中控制器是包含了状态栏的) let rootViewController = view.window?.rootViewController // 背景图片 总的大小 let size = rootViewController?.view.frame.size // 开启上下文,使用参数之后,截出来的是原图（YES 0.0 质量高） UIGraphicsBeginImageContextWithOptions(size!, true, 0.0) // 要裁剪的矩形范围 let rect = CGRect(x: 0, y: 0, width: UIScreen.width, height: UIScreen.height) // 注：iOS7以后renderInContext：由drawViewHierarchyInRect：afterScreenUpdates：替代 // 判读是导航栏是否有上层的Tabbar 决定截图的对象 if tabBarController == rootViewController &#123; rootViewController?.view.drawHierarchy(in: rect, afterScreenUpdates: false) &#125; else &#123; view.drawHierarchy(in: rect, afterScreenUpdates: false) &#125; // 从上下文中,取出UIImage let snapshot = UIGraphicsGetImageFromCurrentImageContext() // 添加截取好的图片到图片数组 if snapshot != nil &#123; screenshotImgs.append(snapshot!) &#125; // 结束上下文(移除栈顶的基于当前位图的图形上下文) UIGraphicsEndImageContext() &#125;&#125;extension NavigationController: UINavigationControllerDelegate &#123; // MARK: - UINavigationControllerDelegate func navigationController(_: UINavigationController, animationControllerFor operation: UINavigationController.Operation, from _: UIViewController, to _: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? &#123; animationController.navigationOperation = operation animationController.navigationController = self return animationController &#125;&#125; 使用继承自导航控制器即可。可用 runtime 实现这套需求，但个人觉得没必要，对于开发，能正向常规完成的 ，尽量不使用逆向或者 hook 等方式，避免一些怪异 bug 的产生（一般不会）。]]></content>
      <categories>
        <category>iOS 开发</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>iOS</tag>
        <tag>Swift</tag>
        <tag>导航栏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[抓取 App Store和 Google Play 应用评论并写入 Excel]]></title>
    <url>%2F2019%2F06%2F29%2F%E6%8A%93%E5%8F%96-App-Store%E5%92%8C-Google-Play-%E5%BA%94%E7%94%A8%E8%AF%84%E8%AE%BA%E5%B9%B6%E5%86%99%E5%85%A5-Excel%2F</url>
    <content type="text"><![CDATA[这几天开始在利用业余时间用 Swift 5 重写公司项目，继上一次用 Swift 写项目隔了有两年了吧（中间陆续在学习），Swift 变得更加好用了，真是愈发嫌弃 OC，来新公司把所负责的 App 从规范到基础服务再到业务里外优化了一番，算是有所成果了。新项目到写得正 high，组长丢给我一个任务，产品经理需要竞品在 App Store 和 Google Play 的评论数据用于调研，简单实现了一番，趁热打铁，记录一下结果，以便日后需要。 想到第一方案在未做调研前，想到的第一方案是利用 Appium + mitmproxy + python 实现，想怎么抓就怎么抓，唰唰唰先代理看看，结果发现 App Store 启用网络代理后无法联网，原因是 SSL Pinning，然后就解决这个问题，找到 ssl-kill-switch2，可以解决这个问题，在越狱手机上安装了 deb 包，关闭 itunesstored 服务，发现并不生效: 123dpkg -i com.nablac0d3.sslkillswitch2_0.13.debps -ef | grep itunesstoredkill -s KILL 1170 看 Issues 确实在 iOS 11.4.1 上无法生效，可惜我的越狱设备正好是这个版本，该方案夭折。 调研第三方服务商既然一方案夭折，想想该需求市场上肯定有数据服务商，于是谷歌搜索了一 ha，果然前面几位都是“科学家”网站，进去看看，可以看到有广告 产品舆情 - WeTest腾讯质量开放平台 和 七麦数据 的，前者没去看，简单看了下后者，注册账号，两个问题 - 不能查看非中国区评论 - 不能自定义生成的 Excel 选项 于是，该方案 pass App Store 从官方渠道获取最近500条考虑到多款竞品在 App Store 对应国区的评论数均不足 500条，于是使用苹果官方提供的 API https://itunes.apple.com/rss/customerreviews/page=1/id=414478124/sortby=mostrecent/json?l=en&amp;&amp;cc=cn page 和 id 自行更改，该 API最多可以获取一个App的最近500条评论（每页最多50，最多10页），该方案顺利抓取数据，代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#!/usr/bin/python3# -*- coding: utf-8 -*-import requestsimport urllib.requestimport reimport xlsxwriterimport jsonimport osdef getHTMLText(url): response = urllib.request.urlopen(url) myjson = json.loads(response.read().decode()) return myjson # try: # r = requests.get(url) # r.raise_for_status() # r.encoding = r.apparent_encoding # return r.text # except: # return ''def main(): appid = input("请输入应用id号:") appName = input("请输入应用名称:") if not os.path.exists(appid): os.system('mkdir ' + appid) workbook = xlsxwriter.Workbook(appid + '/' + appName + '_comments.xlsx') worksheet = workbook.add_worksheet() format = workbook.add_format() format.set_border(1) format.set_border(1) format_title = workbook.add_format() format_title.set_border(1) format_title.set_bg_color('#cccccc') format_title.set_align('left') format_title.set_bold() title = ['作者', '标题', '评论内容', '版本', '评级', '投票'] # 设置单元格宽度 worksheet.set_column(0, 0, 30) worksheet.set_column(1, 1, 40) worksheet.set_column(2, 2, 100) worksheet.set_column(3, 3, 10) worksheet.set_column(4, 4, 10) worksheet.set_column(5, 5, 10) worksheet.write_row('A1', title, format_title) count = 0 total = 10 totalCount = 0 for n in range(total): url = 'https://itunes.apple.com/rss/customerreviews/page=' + \ str(n+1) + '/id=' + str(appid) + \ '/sortby=mostrecent/json?l=en&amp;&amp;cc=kh' print('当前地址：' + url) jsonText = getHTMLText(url) fileName = appid + '/' + str(n+1) + '.json' data_feed = jsonText['feed'] entry = data_feed['entry'] for i in range(len(entry)): value = entry[i] fixedIndex = i + 1 startRow = totalCount + 1 worksheet.write( startRow, 0, value['author']['name']['label'], format) worksheet.write(startRow, 1, value['title']['label'], format) worksheet.write(startRow, 2, value['content']['label'], format) worksheet.write( startRow, 3, value['im:version']['label'], format) worksheet.write( startRow, 4, value['im:rating']['label'], format) worksheet.write( startRow, 5, value['im:rating']['label'], format) totalCount = totalCount + 1 with open(fileName, 'w') as file: file.write(json.dumps(jsonText, sort_keys=True, indent=4, ensure_ascii=False)) count = count + 1 print("当前进度: &#123;:.2f&#125;%".format(count * 100 / total), end="\n\n") workbook.close()if __name__ == '__main__': main() Google Play App评论获取谷歌相比苹果而言这方面更加开放，App 数据获取 API 次数不限，而且有 现成的 npm 库，笔芯，感谢开源世界。新建个 node 项目，三下五除二实验了一下，库高效可用，于是开始简单分析数据编写代码，产出如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091'use strict';var gplay = require('google-play-scraper');var fs = require("fs");// const readline = require('readline').createInterface(&#123;// input: process.stdin,// output: process.stdout// &#125;)// readline.question(`请输入 apk 包名：`, (inputText) =&gt; &#123;// bundle_id = inputText// console.log(`包名： $&#123;bundle_id&#125;!`)// readline.close()// fs.mkdirSync(bundle_id)// gplay.reviews(&#123;// appId: bundle_id,// lang: 'kh'// &#125;)// .then((body) =&gt; &#123;// fs.writeFile(`$&#123;bundle_id&#125;/comments.json`, JSON.stringify(body), (err) =&gt; &#123;// if (err) &#123;// console.error(err);// return;// &#125;;// console.log("File has been created");// &#125;);// &#125;)// &#125;)var arr = [ &#123; 'bundle_id': 'com.pipay.app.android', 'name': 'PiPay'&#125;,// &#123;// 'bundle_id': 'com.aeon_cambodia.rielpay',// 'name': 'AEON Wallet'// &#125;,// &#123;// 'bundle_id': 'com.wingmoney.wingpay',// 'name': 'Wing Money'// &#125;,// &#123;// 'bundle_id': 'th.co.truemoney.wallet',// 'name': 'True Money'// &#125;]const total = 50for (let i = 0; i &lt; arr.length; i++) &#123; const object = arr[i] var bundle_id, name if (object.hasOwnProperty('bundle_id')) &#123; bundle_id = object['bundle_id']; if (!fs.existsSync(bundle_id)) &#123; fs.mkdirSync(bundle_id) &#125; &#125; if (object.hasOwnProperty('bundle_id')) &#123; name = object['name']; &#125; console.log(`包名：$&#123;bundle_id&#125; 应用名：$&#123;name&#125;`) for (let index = 0; index &lt; total; index++) &#123; gplay.reviews(&#123; appId: bundle_id, lang: 'kh', page: index &#125;) .then((body) =&gt; &#123; if (body.length &gt; 0) &#123; fs.writeFile(`$&#123;bundle_id&#125;/$&#123;index&#125;.json`, JSON.stringify(body), (err) =&gt; &#123; if (err) &#123; console.error(err); return; &#125;; console.log(`成功写入文件 $&#123;bundle_id&#125;/$&#123;index&#125;.json`); &#125;); &#125; else &#123; console.log('无更多评论') &#125; &#125;) &#125;&#125; 抓取后评论数据本地存档，如下： 1234567891011121314151617➜ ls th.co.truemoney.wallet0.json 35.json 61.json1.json 36.json 62.json10.json 37.json 63.json11.json 38.json 64.json12.json 39.json 65.json13.json 4.json 66.json14.json 40.json 67.json15.json 41.json 68.json16.json 42.json 69.json17.json 43.json 7.json18.json 44.json 70.json19.json 45.json 71.json2.json 46.json 72.json20.json 47.json 73.json21.json 48.json 74.json... 将数据生成 Excel 并简单美化for AppStore123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#!/usr/bin/python3# -*- coding: utf-8 -*-import xlsxwriterimport jsonimport osfrom googletrans import Translatorimport syssys.path.append("..")from mtranslate.mtranslate import translate# translator = Translator()# print(translator.translate('មិចញុមវាយលេខចូលហើយមិចក៏មិនអោយ', dest='zh-CN').text)arr = [&#123; 'id': '1234143591', 'name': 'PiPay' &#125;, &#123; 'id': '1328330562', 'name': 'AEON Wallet' &#125;, &#123; 'id': '1113286385', 'name': 'Wing Money' &#125;, &#123; 'id': '1162466939', 'name': 'True Money'&#125;]def translateToChinese(text): translator = Translator() try: return translator.translate(text, dest='zh-CN').text except print(0): return textdef main(): for item in arr: appid = item['id'] name = item['name'] # appid = input("请输入应用id号:") # name = input("请输入应用名称:") workbook = xlsxwriter.Workbook( str(appid) + '/' + name + '_comments.xlsx') worksheet = workbook.add_worksheet() format = workbook.add_format() format.set_border(1) format.set_border(1) format_title = workbook.add_format() format_title.set_border(1) format_title.set_bg_color('#cccccc') format_title.set_align('left') format_title.set_bold() title = ['作者', '标题', '评论内容', '版本', '评级', '投票'] # 设置单元格宽度 worksheet.set_column(0, 0, 30) worksheet.set_column(1, 1, 40) worksheet.set_column(2, 2, 100) worksheet.set_column(3, 3, 10) worksheet.set_column(4, 4, 10) worksheet.set_column(5, 5, 10) worksheet.write_row('A1', title, format_title) total = 50 totalCount = 0 for n in range(total): fileName = appid + '/' + str(n) + '.json' if not os.path.exists(fileName): continue with open(fileName, 'r') as file: result = json.load(file) data_feed = result['feed'] entry = data_feed['entry'] for i in range(len(entry)): value = entry[i] fixedIndex = i + 1 startRow = totalCount + 1 worksheet.write( startRow, 0, value['author']['name']['label'], format) worksheet.write(startRow, 1, value['title']['label'], format) worksheet.write( startRow, 2, translate(value['content']['label'], 'zh-CN'), format) # startRow, 2,value['content']['label'], format) worksheet.write( startRow, 3, value['im:version']['label'], format) worksheet.write( startRow, 4, value['im:rating']['label'], format) worksheet.write( startRow, 5, value['im:rating']['label'], format) totalCount = totalCount + 1 workbook.close()if __name__ == '__main__': main() for Google Play123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#!/usr/bin/python3# -*- coding: utf-8 -*-import xlsxwriterimport jsonimport osfrom googletrans import Translatorimport syssys.path.append("..")from mtranslate.mtranslate import translate# translator = Translator()# print(translator.translate('មិចញុមវាយលេខចូលហើយមិចក៏មិនអោយ', dest='zh-CN').text)# print(translate('មិចញុមវាយលេខចូលហើយមិចក៏មិនអោយ', 'zh-CN'))arr = [&#123; 'bundle_id': 'com.pipay.app.android', 'name': 'PiPay'# &#125;,# &#123; # 'bundle_id': 'com.aeon_cambodia.rielpay', # 'name': 'AEON Wallet'# &#125;,# &#123; # 'bundle_id': 'com.wingmoney.wingpay', # 'name': 'Wing Money'# &#125;,# &#123; # 'bundle_id': 'th.co.truemoney.wallet', # 'name': 'True Money'&#125;]def translateToChinese(text): translator = Translator() try: return translator.translate(text, dest='zh-CN').text except print(0): return textdef main(): for item in arr: bundle_id = item['bundle_id'] name = item['name'] # appid = input("请输入应用id号:") # appName = input("请输入应用名称:") workbook = xlsxwriter.Workbook( bundle_id + '/' + name + '_comments.xlsx') worksheet = workbook.add_worksheet() format = workbook.add_format() format.set_border(1) format.set_border(1) format_title = workbook.add_format() format_title.set_border(1) format_title.set_bg_color('#cccccc') format_title.set_align('left') format_title.set_bold() title = ['作者', '标题', '评论内容', '日期', '评分', '头像'] # 设置单元格宽度 worksheet.set_column(0, 0, 30) worksheet.set_column(1, 1, 30) worksheet.set_column(2, 2, 100) worksheet.set_column(3, 3, 20) worksheet.set_column(4, 4, 10) worksheet.set_column(5, 5, 120) worksheet.write_row('A1', title, format_title) total = 50 totalCount = 0 for n in range(total): fileName = bundle_id + '/' + str(n) + '.json' if not os.path.exists(fileName): continue with open(fileName, 'r') as file: result = json.load(file) entry = result for i in range(len(entry)): value = entry[i] fixedIndex = i + 1 startRow = totalCount + 1 worksheet.write( startRow, 0, value['userName'], format) worksheet.write( startRow, 1, value['title'], format) worksheet.write( startRow, 2, translate(value['text'], 'zh-CN'), format) worksheet.write( startRow, 3, value['date'], format) worksheet.write( startRow, 4, value['score'], format) worksheet.write( startRow, 5, value['userImage'], format) totalCount = totalCount + 1 workbook.close()if __name__ == '__main__': pass main() Excuse me？整理下数据发给产品，准备继续撸 Swift 搬砖了，产品又跟我说发现个大问题，几千条评论全是英语和高棉语，看不懂！！！好吧，给你翻译（谷歌翻译）。随便一 google，谷歌有免费的 python API 的开源库 googletrans，看看介绍 Googletrans is a free and unlimited python library that implemented Google Translate API. This uses the Google Translate Ajax API to make calls to such methods as detect and translate.Compatible with Python 2.7+ and 3.4+. (Note: Python 2 support will be dropped in the next major release.)For details refer to the API Documentation. 太棒了，还无限制，两三行代码就能使用，关键代码： 1234from googletrans import Translatortranslator = Translator()print(translator.translate('មិចញុមវាយលេខចូលហើយមិចក៏មិនអោយ', dest='zh-CN').text) 但数据量比较大，亲测使用该方式翻译速度较慢，于是找到 mtranslate ，其是对 googletrans的一个封装，可以稍微加快翻译速度，最后使用该库完成翻译，代码就几行： 123from mtranslate.mtranslate import translateprint(translate('មិចញុមវាយលេខចូលហើយមិចក៏មិនអោយ', 'zh-CN')) PS：翻译库 JavaScript 版本的可以使用 google-translate-api 效果图 完整 Demo 地址附上 github 完整项目地址]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
        <tag>JavaScript</tag>
        <tag>SEO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UITabBar 点击动画与切换 VC 动画实现]]></title>
    <url>%2F2019%2F06%2F09%2FUITabBar-%E7%82%B9%E5%87%BB%E5%8A%A8%E7%94%BB%E4%B8%8E%E5%88%87%E6%8D%A2-VC-%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[假如一个 APP 能带来良好的交互体验，那么它一定是”活的”。 效果图 show me the code. tabBarController 切换 selectedViewController 的动画添加12345678910111213141516171819- (BOOL)tabBarController:(UITabBarController *)tabBarController shouldSelectViewController:(UIViewController *)viewController &#123; NSUInteger shouldSelectIndex = [tabBarController.viewControllers indexOfObject:viewController]; if (tabBarController.selectedIndex == shouldSelectIndex) &#123; return YES; &#125; CATransition *animation = [CATransition animation]; animation.duration = 0.3; animation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut]; animation.type = kCATransitionPush; if (tabBarController.selectedIndex &gt; shouldSelectIndex) &#123; animation.subtype = kCATransitionFromLeft; &#125; else &#123; animation.subtype = kCATransitionFromRight; &#125; [[[tabBarController valueForKey:@"_viewControllerTransitionView"] layer] addAnimation:animation forKey:@"animation"]; return YES;&#125; 点击 UITabBarItem添加动画效果1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859- (void)tabBar:(UITabBar *)tabBar didSelectItem:(UITabBarItem *)item &#123; NSInteger index = [self.tabBar.items indexOfObject:item]; [self animationWithIndex:index];&#125;#pragma mark - private methods- (void)animationWithIndex:(NSInteger)index &#123; NSMutableArray *tabBarbuttonArray = [NSMutableArray array]; // 找到所有的 UITabBarButton for (UIView *tabBarButton in self.tabBar.subviews) &#123; if ([tabBarButton isKindOfClass:NSClassFromString(@"UITabBarButton")]) &#123; [tabBarbuttonArray addObject:tabBarButton]; &#125; &#125; // tabBarButton 排序 [tabBarbuttonArray sortUsingComparator:^NSComparisonResult(UIView *_Nonnull obj1, UIView *_Nonnull obj2) &#123; return CGRectGetMinX(obj1.frame) &gt; CGRectGetMinX(obj2.frame); &#125;]; UIView *tabbarBtn = tabBarbuttonArray[index]; // 找到UITabBarButton中的imageView，加动画 for (UIView *sub in tabbarBtn.subviews) &#123; if ([sub isKindOfClass:NSClassFromString(@"UITabBarSwappableImageView")]) &#123; [self preformAnimationForView:sub]; &#125; &#125;&#125;- (void)preformAnimationForView:(UIView *)view &#123; [view.layer addAnimation:[self scaleAnimation] forKey:nil];&#125;/** 重力效果弹跳 */- (CAKeyframeAnimation *)gravityElasticAnimation &#123; CAKeyframeAnimation *animation = [CAKeyframeAnimation animationWithKeyPath:@"transform.translation.y"]; animation.values = @[@0.0, @-4.15, @-7.26, @-9.34, @-10.37, @-9.34, @-7.26, @-4.15, @0.0, @2.0, @-2.9, @-4.94, @-6.11, @-6.42, @-5.86, @-4.44, @-2.16, @0.0]; animation.duration = 0.8; animation.beginTime = CACurrentMediaTime(); animation.removedOnCompletion = YES; return animation;&#125;/** 缩放动画 */- (CABasicAnimation *)scaleAnimation &#123; CABasicAnimation *animation = [CABasicAnimation animationWithKeyPath:@"transform.scale"]; animation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut]; animation.duration = 0.2; animation.repeatCount = 1; animation.removedOnCompletion = YES; animation.autoreverses = YES; animation.fromValue = @1; animation.toValue = @[@0.7, @1]; return animation;&#125; Swift 5 版本1234567891011121314151617181920212223242526272829303132333435extension BaseTabBarController: UITabBarControllerDelegate &#123; func tabBarController(_ tabBarController: UITabBarController, animationControllerForTransitionFrom _: UIViewController, to _: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? &#123; return TabBarTransition(viewControllers: tabBarController.viewControllers) &#125; private var scaleAnimation: CABasicAnimation &#123; let animation = CABasicAnimation(keyPath: "transform.scale") animation.timingFunction = CAMediaTimingFunction(name: .easeInEaseOut) animation.duration = 0.2 animation.repeatCount = 1 animation.isRemovedOnCompletion = true animation.autoreverses = true animation.fromValue = 1 animation.toValue = [0.7, 1] return animation &#125; override func tabBar(_ tabBar: UITabBar, didSelect item: UITabBarItem) &#123; let orderedTabBarItemViews: [UIView] = &#123; let interactionViews = tabBar.subviews.filter &#123; $0 is UIControl &#125; return interactionViews.sorted(by: &#123; $0.frame.minX &lt; $1.frame.minX &#125;) &#125;() guard let index = self.tabBar.items?.firstIndex(of: item), let imageView = orderedTabBarItemViews[index].subviews.first as? UIImageView else &#123; return &#125; // 找到UITabBarButton中的imageView，加动画 imageView.layer.add(scaleAnimation, forKey: nil) &#125;&#125; TabBarTransition.swift: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//// TabBarTransition.swift// ViPay//// Created by VanJay on 2019/6/30.// Copyright © 2019 VanJay. All rights reserved.//import UIKitclass TabBarTransition: NSObject, UIViewControllerAnimatedTransitioning &#123; let viewControllers: [UIViewController]? let transitionDuration: TimeInterval = 0.3 init(viewControllers: [UIViewController]?) &#123; self.viewControllers = viewControllers &#125; func transitionDuration(using _: UIViewControllerContextTransitioning?) -&gt; TimeInterval &#123; return transitionDuration &#125; func animateTransition(using transitionContext: UIViewControllerContextTransitioning) &#123; guard let fromVC = transitionContext.viewController(forKey: UITransitionContextViewControllerKey.from), let fromView = fromVC.view, let fromIndex = getIndex(forViewController: fromVC), let toVC = transitionContext.viewController(forKey: UITransitionContextViewControllerKey.to), let toView = toVC.view, let toIndex = getIndex(forViewController: toVC) else &#123; transitionContext.completeTransition(false) return &#125; let frame = transitionContext.initialFrame(for: fromVC) var fromFrameEnd = frame var toFrameStart = frame fromFrameEnd.origin.x = toIndex &gt; fromIndex ? frame.origin.x - frame.width : frame.origin.x + frame.width toFrameStart.origin.x = toIndex &gt; fromIndex ? frame.origin.x + frame.width : frame.origin.x - frame.width toView.frame = toFrameStart DispatchQueue.main.async &#123; transitionContext.containerView.addSubview(toView) UIView.animate(withDuration: self.transitionDuration, animations: &#123; fromView.frame = fromFrameEnd toView.frame = frame &#125;, completion: &#123; success in fromView.removeFromSuperview() transitionContext.completeTransition(success) &#125;) &#125; &#125; private func getIndex(forViewController vc: UIViewController) -&gt; Int? &#123; guard let vcs = self.viewControllers else &#123; return nil &#125; for (index, thisVC) in vcs.enumerated() &#123; if thisVC == vc &#123; return index &#125; &#125; return nil &#125;&#125;]]></content>
      <categories>
        <category>iOS 开发</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>UITabBar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cocoapods 私有库的搭建和使用]]></title>
    <url>%2F2019%2F04%2F01%2Fcocoapods-%E7%A7%81%E6%9C%89%E5%BA%93%E7%9A%84%E6%90%AD%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前言cocoapods是非常好用的一个iOS 依赖管理工具，使用它可以方便的管理和更新项目中所使用到的第三方库，以及将自己的项目中的公共组件交由它去管理，实现工程组件化。 创建私有 repo介绍什么是 repo？他是所有的Pods的一个索引，就是一个容器，所有的Pods都在这个里面，他实际是一个git仓库，但是当你使用了cocoapods后他会被clone到本地的 ~/.cocoapods/repos 目录下，可以进入到这个目录看到 master 文件夹就是这个官方的 repo。 创建 Specs git 仓库这个 Specs 用来管理自己的私有 pods ，类似于官方 https://github.com/cocoapods/Specs，我们也需要创建一个 git 仓库，只要你有访问权限，你可以把 git 仓库建在 github、coding、bitbucket 等，当然也可以建立在公司自己部署的 git 服务器（可以内网，只是到时 pod install 只在内网才能用）。cocoapod 官方的 pod repo名字叫 master，阿里云的叫 aliyun，这里举例使用 tianxu-Specs 作为repo 名，在 git 服务器上创建 tianxu-Specs repository： 关联远程 git Specs repository到本地 repo1234567➜ cd ~/.cocoapods/repos~/.cocoapods/repos➜ pod repo add tianxu git@your_git_url:wangwanjie/tianxu-Specs.gitCloning spec repo `tianxu` from `git@your_git_url:wangwanjie/tianxu-Specs.git`~/.cocoapods/repos took 4s 此时如果成功的话进入到 ~/.cocoapods/repos 目录下就可以看到WTSpecs这个目录了。至此第一步创建私有Spec repo完成。也可使用 pod repo list 查看。 12345678910111213141516➜ pod repo listmaster- Type: git (master)- URL: https://github.com/cocoapods/Specs.git- Path: /Users/VanJay/.cocoapods/repos/mastertianxufatal: ambiguous argument 'HEAD': unknown revision or path not in the working tree.Use '--' to separate paths from revisions, like this:'git &lt;command&gt; [&lt;revision&gt;...] -- [&lt;file&gt;...]'- Type: git (unknown)- URL: git@your_git_url:wangwanjie/tianxu-Specs.git- Path: /Users/VanJay/.cocoapods/repos/tianxu2 repos PS：如果有其他合作人员共同使用这个私有Spec repo的话在他有对应Git仓库的权限的前提下执行相同的命令添加这个Spec repo即可。 创建私有 podrepo 已经建立好了，接下来就是往里面放对应的 pod，也就是我们要使用的私有 pod，比如将网络封装层从项目抽出来作为公用组件，取名 TXNetwork， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657➜ cd ~/Documents/Work/ChaosDocuments/Work/Chaos➜ pod lib create TXNetworkCloning `https://github.com/cocoapods/pod-template.git` into `TXNetwork`.Configuring TXNetwork template.------------------------------To get you started we need to ask a few questions, this should only take a minute.If this is your first time we recommend running through with the guide: - https://guides.cocoapods.org/making/using-pod-lib-create.html ( hold cmd and click links to open in a browser. )What platform do you want to use?? [ iOS / macOS ] &gt; iOSWhat language do you want to use?? [ Swift / ObjC ] &gt; ObjcWould you like to include a demo application with your library? [ Yes / No ] &gt; YesWhich testing frameworks will you use? [ Specta / Kiwi / None ] &gt; SpectaWould you like to do view based testing? [ Yes / No ] &gt; NoWhat is your class prefix? &gt; TXRunning pod install on your new library.Analyzing dependenciesFetching podspec for `TXNetwork` from `../`Downloading dependenciesInstalling Expecta (1.0.6)Installing Specta (1.0.7)Installing TXNetwork (0.1.0)Generating Pods projectIntegrating client project[!] Please close any current Xcode sessions and use `TXNetwork.xcworkspace` for this project from now on.Sending statsPod installation complete! There are 3 dependencies from the Podfile and 3 total pods installed. Ace! you're ready to go! We will start you off by opening your project in Xcode open 'TXNetwork/Example/TXNetwork.xcworkspace'To learn more about the template see `https://github.com/cocoapods/pod-template.git`.To learn more about creating a new pod, see `http://guides.cocoapods.org/making/making-a-cocoapod`.Documents/Work/Chaos took 3m 45s pod 配置自身视情况而定，pod lib create 的问题根据该 pod 情况选择。 关联 pod 到远程 git 仓库在 git 服务器上创建 TXNetworking repository，关联。 123456cd TXNetworkTXNetwork on  master [?]➜ git remote add origin https://your_git_url/wangwanjie/TXNetworkingTXNetwork on  master [?] 添加代码把 pod 代码和资源文件对应放置到 TXNetwork/Classes 和 TXNetwork/Assets，完成之后打 tag 并推送代码。 提交代码到远程仓库123git add .git commit -m "Initial commit"git push origin master 给当前的版本加上tag，提交到远程仓库12git tag -a 0.1.0 -m 'v0.1.0' HEADgit push origin tag 0.1.0 编写 podspec建议参考cocoapods上面的来做，照着那些第三库的podspec文件写就行了，官方参考 这是该 demo 的 podspec: 1234567891011121314151617181920212223242526272829303132333435363738394041424344## Be sure to run `pod lib lint TXNetwork.podspec' to ensure this is a# valid spec before submitting.## Any lines starting with a # are optional, but their use is encouraged# To learn more about a Podspec see https://guides.cocoapods.org/syntax/podspec.html#Pod::Spec.new do |s| s.name = 'TXNetwork' s.version = '0.1.0' s.summary = '介绍 pod 的描述.'# This description is used to generate tags and improve search results.# * Think: What does it do? Why did you write it? What is the focus?# * Try to keep it short, snappy and to the point.# * Write the description between the DESC delimiters below.# * Finally, don't worry about the indent, cocoapods strips it! s.description = &lt;&lt;-DESC 介绍 pod 的详细描述。 DESC s.homepage = 'https://your_git_url/wangwanjie/TXNetworking' # s.screenshots = 'www.example.com/screenshots_1', 'www.example.com/screenshots_2' s.license = &#123; :type =&gt; 'MIT', :file =&gt; 'LICENSE' &#125; s.author = &#123; 'wangwanjie' =&gt; 'wangwanjie1993@gmail.com' &#125; s.source = &#123; :git =&gt; 'https://your_git_url/wangwanjie/TXNetworking.git', :tag =&gt; s.version.to_s &#125; # s.social_media_url = 'https://twitter.com/&lt;TWITTER_USERNAME&gt;' s.ios.deployment_target = '8.0' s.source_files = 'TXNetwork/Classes/**/*.&#123;h,m&#125;' # s.resource_bundles = &#123; # 'TXNetwork' =&gt; ['TXNetwork/Assets/*.png'] # &#125; s.public_header_files = 'TXNetwork/Classes/AFHTTPSessionManager+Retry.h' # s.frameworks = 'UIKit', 'MapKit' s.dependency 'AFNetworking', '~&gt; 3.0' s.requires_arc = trueend 验证 podspec如果填写有误，根据提示修改。 1234567891011121314pod lib lint --allow-warnings -&gt; TXNetwork (0.1.0) - NOTE | [TXNetwork/ObjcAssociatedObjectHelpers] xcodebuild: note: Using new build system - NOTE | [TXNetwork/ObjcAssociatedObjectHelpers] xcodebuild: note: Planning build - NOTE | [TXNetwork/ObjcAssociatedObjectHelpers] xcodebuild: note: Constructing build description - WARN | xcodebuild: /Users/VanJay/Documents/Work/Chaos/TXNetwork/TXNetwork/Classes/AFHTTPSessionManager+Retry.m:159:38: warning: this block declaration is not a prototype [-Wstrict-prototypes] - WARN | [iOS] xcodebuild: /Users/VanJay/Documents/Work/Chaos/TXNetwork/TXNetwork/Classes/AFHTTPSessionManager+Retry.m:151:172: warning: values of type 'NSInteger' should not be used as format arguments; add an explicit cast to 'long' instead [-Wformat] - WARN | [iOS] xcodebuild: /Users/VanJay/Documents/Work/Chaos/TXNetwork/TXNetwork/Classes/AFHTTPSessionManager+Retry.m:157:129: warning: values of type 'NSInteger' should not be used as format arguments; add an explicit cast to 'long' instead [-Wformat] - WARN | [iOS] xcodebuild: /Users/VanJay/Documents/Work/Chaos/TXNetwork/TXNetwork/Classes/AFHTTPSessionManager+Retry.m:182:118: warning: values of type 'NSInteger' should not be used as format arguments; add an explicit cast to 'long' instead [-Wformat]TXNetwork passed validation.TXNetwork on  master [!] took 23s 在 Example 执行验证 pod 是否可用12cd Examplepod install 向Spec repo提交podspec向Spec repo提交podspec需要确定podspec必须通过验证无误。 向我们的私有Spec repo提交podspec只需要一个命令： 1pod repo push tianxu TXNetwork.podspec --allow-warnings 检验 pod 是否可 search12345678pod search -&gt; TXNetwork (0.1.0) 介绍 pod 的描述. pod 'TXNetwork', '~&gt; 0.1.0' - Homepage: https://your_git_url/wangwanjie/TXNetworking - Source: https://your_git_url/wangwanjie/TXNetworking.git - Versions: 0.1.0 [tianxu repo] 使用私有 repo指定 Specs 的位置,自定义添加自己的podspec。公司内部使用 cocoapods， 官方 source 是隐式的需要的，一旦你指定了其他 source，Podfile 里你就需要也把官方的指定上。 12345678910source 'https://github.com/cocoapods/Specs.git' # 官方库source 'https://your_git_url/wangwanjie/tianxu-Specs.git' # 私有库target 'NewProject' do # Uncomment the next line if you're using Swift or would like to use dynamic frameworks # use_frameworks! # Pods for NewProject pod 'TXNetwork'end]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>pod</tag>
        <tag>cocoapods</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[免越狱钉钉远程打卡]]></title>
    <url>%2F2019%2F02%2F15%2F%E5%85%8D%E8%B6%8A%E7%8B%B1%E9%92%89%E9%92%89%E8%BF%9C%E7%A8%8B%E6%89%93%E5%8D%A1%2F</url>
    <content type="text"><![CDATA[请输入密码查看博客： 密码错误! 无内容显示! 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]]></content>
      <categories>
        <category>工具教程</category>
      </categories>
      <tags>
        <tag>免越狱</tag>
        <tag>钉钉远程打卡</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu 18.04 编译 Android 源码]]></title>
    <url>%2F2019%2F01%2F05%2FUbuntu%2018.04%20%E7%BC%96%E8%AF%91%20Android%20%E6%BA%90%E7%A0%81%2F</url>
    <content type="text"><![CDATA[Android 源码编译的四个流程: 源码下载; 构建编译环境; 编译源码; 模拟器运行 源码下载 首先确保自己已经安装了Git. 123sudo apt-get install git git config –global user.email “your_email” git config –global user.name “your_name” 使用清华大学镜像 Android 镜像使用帮助 首先要下载repo 工具 12345mkdir ~/binPATH=~/bin:$PATHcurl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repochmod a+x ~/bin/repo// 拒绝连接可以使用tuna的git-repo镜像,将地址换成清华大学的镜像地址，详情查看网址https://mirrors.tuna.tsinghua.edu.cn/help/git-repo/ 使用每月更新的初始化包（也可以传统的初始化方法，因为网络慢会下载失败，还是直接把初始化包下载下来再进行同步）下载地址 每月更新的初始化包 由于所有代码都是从隐藏的 .repo 目录中 checkout 出来的，所以只保留了 .repo 目录，下载后解压 再 repo sync 一遍即可得到完整的目录 使用方法如下: 123456wget -c https://mirrors.tuna.tsinghua.edu.cn/aosp-mo nthly/aosp-latest.tar # 下载初始化包tar xvf aosp-latest.tarcd AOSP # 解压得到的 AOSP 工程目录# 这时 ls 的话什么也看不到，因为只有一个隐藏的 .repo 目录repo sync # 正常同步一遍即可得到完整目录# 或 repo sync -l 仅checkout代码 同步完代码之后需要直接进行编译的话就是编译主分支的源码，如果需要特定版本，则需要自己切换分支，再次同步就切换到指定分支的源码了，执行以下命令（这里切换到8.0版本 支持设备 Pixel XL、Pixel）分支列表 代号、标记和细分版本号 12repo init -u git://mirrors.ustc.edu.cn/aosp/platform/manifest -b android-8.0.0_r2repo sync 构建编译环境硬件要求 64位的操作系统只能编译2.3.x以上的版本,如果你想要编译2.3.x以下的,那么需要32位的操作系统.磁盘空间越多越好,至少在100GB以上.意思就是,你可以去买个大点的硬盘了啊如果你想要在是在虚拟机运行linux,那么至少需要16GB的RAM/swap. 软件要求 安装 openJDK 8 12sudo apt-get updatesudo apt-get install openjdk-8-jdk 依赖设置: 12345678910sudo apt-get install libx11-dev:i386 libreadline6-dev:i386 libgl1-mesa-dev g++-multilib sudo apt-get install -y git flex bison gperf build-essential libncurses5-dev:i386 sudo apt-get install tofrodos python-markdown libxml2-utils xsltproc zlib1g-dev:i386 sudo apt-get install dpkg-dev libsdl1.2-dev libesd0-devsudo apt-get install git-core gnupg flex bison gperf build-essential sudo apt-get install zip curl zlib1g-dev gcc-multilib g++-multilib sudo apt-get install libc6-dev-i386 sudo apt-get install lib32ncurses5-dev x11proto-core-dev libx11-dev sudo apt-get install libgl1-mesa-dev libxml2-utils xsltproc unzip m4sudo apt-get install lib32z-dev ccache 一项一项安装太麻烦，你可以保存以下内容到install_dependency.sh 123456789101112# !/bin/bashsudo apt-get install libx11-dev:i386 libreadline6-dev:i386 libgl1-mesa-dev g++-multilib -y &amp;&amp;sudo apt-get install -y git flex bison gperf build-essential libncurses5-dev:i386 -y &amp;&amp;sudo apt-get install tofrodos python-markdown libxml2-utils xsltproc zlib1g-dev:i386 -y &amp;&amp;sudo apt-get install dpkg-dev libsdl1.2-dev libesd0-dev -y &amp;&amp;sudo apt-get install git-core gnupg flex bison gperf build-essential -y &amp;&amp;sudo apt-get install zip curl zlib1g-dev gcc-multilib g++-multilib -y &amp;&amp;sudo apt-get install libc6-dev-i386 -y &amp;&amp;sudo apt-get install lib32ncurses5-dev x11proto-core-dev libx11-dev -y &amp;&amp;sudo apt-get install libgl1-mesa-dev libxml2-utils xsltproc unzip m4 -y &amp;&amp;sudo apt-get install lib32z-dev ccache -y 给予执行权限 1chmod a+x ./install_dependency.sh 安装依赖 1./install_dependency.sh 依赖设置中有可能会出现“无法定位软件包 libesd0-dev” 这个问题解决方案： 1sudo vim /etc/apt/sources.list 添加镜像源 1deb http://archive.ubuntu.com/ubuntu/ trusty main universe restricted multiverse 然后 1sudo apt-get update 操作系统要求 Android版本 编译要求的Ubuntu最低版本 Android 6.0至AOSP master Ubuntu 14.04 Android 2.3.x至Android 5.x Ubuntu 12.04 Android 1.5至Android 2.2.x Ubuntu 10.04 JDK版本要求 Android版本 编译要求的JDK版本 AOSP的Android主线 OpenJDK 8 Android 7.x至android 8.0 OpenJDK 8 Android 5.x至android 6.0 Oracle JDK 7 Android 2.3.x至Android 4.4.x Oracle JDK 6 Android 1.5至Android 2.2.x Oracle JDK 5 官方编译环境搭建文档地址搭建编译环境 初始化编译环境 123source build/envsetup.sh 或者. build/envsetup.sh 选择目标 1lunch aosp_arm64-eng 该命令表示针对模拟器进行完整编译，并且所有调试功能均处于启用状态。如果您没有提供任何参数就运行命令，lunch 将提示您从菜单中选择一个目标。所有编译目标都采用 BUILD-BUILDTYPE 形式，其中 BUILD 是表示特定功能组合的代号。BUILDTYPE 是以下类型之一： 编译类型 使用情况 user 权限受限；适用于生产环境（没有root权和dedug等） userdebug 在user版本的基础上开放了root权限和debug权限 eng 开发工程师的版本,拥有最大的权限,此外还附带了许多debug工具 编译源码您可以使用make编译任何代码。GNUMake可以借助 -jN 参数处理并行任务，通常使用的任务数N介于编译时所用计算机上硬件线程数的1-2倍之间。例如，在一台双核 E5520 计算机（2 个 CPU，每个 CPU 4 个内核，每个内核2个线程）上，要实现最快的编译速度，可以使用介于make -j16 到 make -j32 之间的命令。 1make -j8 PS: 假如编译报错，直接把错误项往谷歌丢找答案编译完成运行依次输入以下命令（如果是在编译成功源码之后直接想运行模拟器，则直接输入emulator命令就行，因为前面编译源码已经输入过以上两条命令） 123. build/envsetup.shlunch(选择刚才你编译源码设置的目标版本)emulator 参考资料搭建编译环境 Build Aosp Extended on Ubuntu 18.04 (Bionic Beaver) Download Android Source Code and Build 动手实现Android源码（AOSP）的下载、编译、运行、导入、调试 Android 镜像使用帮助]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>Android</tag>
        <tag>Android source build</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu 18.04 添加、修改交换空间]]></title>
    <url>%2F2019%2F01%2F05%2FUbuntu-18-04-%E6%B7%BB%E5%8A%A0%E3%80%81%E4%BF%AE%E6%94%B9%E4%BA%A4%E6%8D%A2%E7%A9%BA%E9%97%B4%2F</url>
    <content type="text"><![CDATA[检查系统的交换信息查看是否已经存在swapfile 1sudo swapon --show 如果您没有收到任何输出，这意味着您的系统当前没有可用的交换空间。 您可以使用free实用程序验证没有活动交换： 1234tungee@tungee-Macmini:~$ free -h total used free shared buff/cache availableMem: 7.7G 6.0G 1.2G 97M 439M 1.3GSwap: 8.0G 4.1G 3.9G 检查硬盘驱动器分区上的可用空间在我们创建交换文件之前，我们将检查当前的磁盘使用情况，以确保我们有足够的空间。 通过输入： 12345678tungee@tungee-Macmini:~$ df -hFilesystem Size Used Avail Use% Mounted onudev 3.9G 0 3.9G 0% /devtmpfs 789M 2.0M 787M 1% /run/dev/sda2 234G 80G 142G 36% /tmpfs 3.9G 40M 3.9G 2% /dev/shmtmpfs 5.0M 4.0K 5.0M 1% /run/locktmpfs 3.9G 0 3.9G 0% /sys/fs/cgroup 在这种情况下，带有/在Mounted on列上的设备是我们的磁盘，确保高于我们将要创建的交换空间大小。虽然对交换空间的适当大小有很多意见，但这实际上取决于您的个人偏好和您的应用程序要求。 通常，等于或加倍系统RAM的量是一个很好的起点。 另一个好的经验法则是，如果您只是将其用作RAM后备，那么任何超过4G的交换都可能是不必要的。 修改swapfile如果第一步存在swapfile，则需要先禁用1sudo swapoff /swapfile 修改swapfile空间的大小为8G123sudo dd if=/dev/zero of=/swapfile bs=1M count=8192或者sudo fallocate -l 8G /swapfile 设置文件为swapfile类型1sudo mkswap /swapfile 修改权限我们需要锁定文件的权限，以便只有具有root权限的用户才能读取内容。 这可以防止普通用户访问该文件，这会产生重大的安全隐患。 通过键入以下内容使该文件只能由root访问： 1sudo chmod 600 /swapfile 键入以下命令验证权限更改： 12tungee@tungee-Macmini:~$ ls -lh /swapfile-rw------- 1 root root 8.0G Jan 5 14:29 /swapfile 启用swapfile1sudo swapon /swapfile 使交换文件永久化我们最近的更改已启用当前会话的交换文件。 但是，如果我们重新启动，服务器将不会自动保留交换设置。 我们可以通过将交换文件添加到/etc/fstab文件来更改此设置。 备份/etc/fstab文件，以防出现任何问题： 1sudo cp /etc/fstab /etc/fstab.bak 键入以下命令，将交换文件信息添加到/etc/fstab文件的末尾： 1echo '/swapfile none swap sw 0 0' | sudo tee -a /etc/fstab 接下来，我们将查看一些我们可以更新的设置以调整我们的交换空间。 调整您的交换设置（附）您可以配置一些选项，这些选项会在处理交换时对系统的性能产生影响。 调整Swappiness属性swappiness参数配置系统将数据从RAM交换到交换空间的频率。 这是介于0和100之间的值，表示百分比。 值接近于零时，除非绝对必要，否则内核不会将数据交换到磁盘。 请记住，与交换文件的交互是“昂贵的”，因为它们比与RAM的交互花费更长的时间，并且它们可能导致性能的显着降低。 告诉系统不要太依赖交换通常会使您的系统更快。 接近100的值将尝试将更多数据放入交换中以努力保持更多RAM空间。 根据应用程序的内存配置文件或服务器的使用情况，在某些情况下可能会更好。 我们可以通过输入以下内容来查看当前的swappiness值： 12tungee@tungee-Macmini:~$ cat /proc/sys/vm/swappiness60 对于桌面，swappiness设置为60并不是一个糟糕的值。 对于服务器，您可能希望将其移近0。 我们可以使用sysctl命令将swappiness设置为不同的值。 例如，要将swappiness设置为10，我们可以键入： 12tungee@tungee-Macmini:~$ sudo sysctl vm.swappiness=10vm.swappiness = 10 此设置将持续到下次重新引导。 我们可以通过在/etc/sysctl.conf文件中添加该行来自动设置此值： 1sudo vim /etc/sysctl.conf 在底部，您可以添加： 1vm.swappiness=10 完成后保存并关闭文件。 调整缓存压力设置您可能想要修改的另一个相关值是vfs_cache_pressure，此设置配置系统将选择多少缓存inode和dentry信息而不是其他数据。 基本上，这是关于文件系统的访问数据。 这通常是非常昂贵的查询和非常频繁的请求，所以这是你的系统缓存的一个很好的事情。 您可以通过再次查询proc文件系统来查看当前值： 12tungee@tungee-Macmini:~$ cat /proc/sys/vm/vfs_cache_pressure100 由于它当前已配置，我们的系统会过快地从缓存中删除inode信息。 我们可以通过键入以下内容将其设置为更保守的设置（如50）： 12tungee@tungee-Macmini:~$ sudo sysctl vm.vfs_cache_pressure=50vm.vfs_cache_pressure = 50 同样，这仅适用于我们当前的会话。 我们可以通过将其添加到配置文件来改变它，就像我们使用swappiness设置一样： 1sudo vim /etc/sysctl.conf 在底部，添加指定新值的行： 1vm.vfs_cache_pressure=50 完成后保存并关闭文件。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>swap 空间</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Appium + mitmproxy 全自动化抓取APP 数据]]></title>
    <url>%2F2018%2F12%2F29%2FAppium-mitmproxy-%E5%85%A8%E8%87%AA%E5%8A%A8%E5%8C%96%E6%8A%93%E5%8F%96APP-%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[背景公司新接到一个某某公司的一个项目需求，其中有一个子项是抓取诸如今日头条、网易新闻、腾讯新闻等新闻类 APP 的新闻，远端根据一个关键词或者一个主账号名称查找获取关于该关键词的所有新闻或主账号下的所有文章，通过简单的抓包分析，发现只有少数 APP 网络请求参数未做签名处理，像这类的能直接分析 url 和 param，利用 python 全自动化获取数据，但是大部分比如网易新闻这类 APP 安全级别较高，参数做了加密或者签名校验，服务端也有同一签名的请求访问次数限制，所以在这样的情况下想要直接获取通过外部调用获取数据几乎变得不可能。 分析在以上的背景之下，简单分析和调研之后，觉得有以下办法可以获取到那些请求加密的 APP 的数据，如下： 逆向分析该 APP，揪出加密方法及对应的逻辑，第三方使用同样的逻辑加密请求参数获取数据； 寻找该新闻 APP 在 WEB 端的接口，同样也能获取到数据； 对 APP 使用网络代理，使用手机获取新闻，使用中间人攻击（MITM）获取数据 并做对应处理。 这三个方案中，第一种，难度最大，因为了解所有明白，以我的逆向水平暂时达不到，虽然可行，但暂时不考虑；第二种，经验证，很多在 APP 端有的接口在 WEB 端没有，也放弃；第三种，面临几个问题，因为整个过程要全自动化，所以这个操作使用获取新闻的过程要自动，手机获取到新闻后数据抓取的过程要自动，这就意味着不能使用 Wireshark、Charles、Fiddler 等抓包工具人为干预，要解决这两个问题，即要解决这两个问题： 使用脚本自动化 UI 操作 代理软件能与脚本交互 为解决第一个问题，可以使用Appium，Github主页 Q：Appium 是什么？A：Appium 是一个自动化测试开源工具，支持 iOS 平台和 Android 平台上的原生应用，web 应用和混合应用。 “移动原生应用”是指那些用 iOS 或者 Android SDK 写的应用。 “移动 web 应用”是指使用移动浏览器访问的应用（Appium 支持 iOS 上的 Safari 和 Android 上的 Chrome）。 “混合应用”是指原生代码封装网页视图——原生代码和 web 内容交互。比如，我们在微信里可以查看网页，可以通过网页应用买电影票等。 Appium 适配了与诸如 JAVA、Python、Javascript、Ruby 等众多语言的交互，我选择 Python，即：Appium + python 为解决第二个问题，找到了两个解决方案，第一个是 mitmproxy，Github主页，第二个是AnyProxy，Github主页，这两个都是开放式的HTTP/HTTPS代理服务，后者是阿里巴巴基于 Node.js 开发的一款开源代理服务，前者是一款免费开源的可交互的HTTP/HTTPS代理服务，可与 Python 交互，且功能更强大，我选择了后者，即：mitmproxy + python 编码方案已经确定了，就开始看文档进行编码工作，过程与细节就不写了，直接上成果。 自动操作 UI 部分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176#!/usr/bin/python3from appium import webdriverfrom selenium.webdriver.support.ui import WebDriverWaitfrom selenium.webdriver.support import expected_conditions as ECfrom selenium.webdriver.common.by import Byfrom appium.webdriver.common.touch_action import TouchActionimport timeimport sysimport getoptimport jsonimport osimport seleniumimport argparseplatformName = 'iOS'deviceName = 'iPhone 6s'bundleId = 'com.netease.news'udid = 'your_uuid'automationName = 'XCUITest'xcodeOrgId = 'your_ xcodeOrgId'xcodeSigningId = 'your_certificate_name'driverServer = 'http://127.0.0.1:4723/wd/hub'class Input: type = '' keyWord = ''class NeteaseNewsSpider(): def __init__(self): self.desired_caps = &#123; 'platformName': platformName, 'deviceName': deviceName, 'bundleId': bundleId, 'udid': udid, 'automationName': automationName, 'clearSystemFiles': True, &#125; self.driver = webdriver.Remote(driverServer, self.desired_caps) def tearDown(self): self.driver.quit() def performActionForKeyword(self, keyWord): driver = self.driver wait = WebDriverWait(driver, 300) time.sleep(5) try: el1 = wait.until(EC.presence_of_element_located( (By.XPATH, '//XCUIElementTypeApplication[@name=\"网易新闻\"]/XCUIElementTypeWindow[1]/XCUIElementTypeOther/XCUIElementTypeOther/XCUIElementTypeOther/XCUIElementTypeOther/XCUIElementTypeOther/XCUIElementTypeOther/XCUIElementTypeOther/XCUIElementTypeOther[1]/XCUIElementTypeButton[1]'))) except selenium.common.exceptions.NoSuchElementException: pass el1.click() time.sleep(0.5) TouchAction(self.driver).tap(x=206, y=44).perform() print('输入目标关键词：%s' % keyWord) el3 = wait.until(EC.presence_of_element_located( (By.XPATH, '//XCUIElementTypeApplication[@name=\"网易新闻\"]/XCUIElementTypeWindow[1]/XCUIElementTypeOther/XCUIElementTypeOther/XCUIElementTypeOther/XCUIElementTypeOther/XCUIElementTypeOther/XCUIElementTypeOther/XCUIElementTypeOther/XCUIElementTypeOther[1]/XCUIElementTypeOther/XCUIElementTypeTextField'))) el3.send_keys(keyWord) print('点击搜索按钮') el3.send_keys('\n') def findForKeyWord(self, keyWord): self.performActionForKeyword(keyWord) time.sleep(0.5) print('动作结束') os.system('say 动作结束') def findForUser(self, keyWord): driver = self.driver self.performActionForKeyword(keyWord) time.sleep(0.5) # 点击用户 print('点击用户') el1 = driver.find_element_by_xpath( "//XCUIElementTypeOther[@name=\"i\"]/XCUIElementTypeOther[1]/XCUIElementTypeOther[4]") el1.click() time.sleep(0.5) # 点击用户第一个 if self.isExistElement(By.XPATH, '//XCUIElementTypeOther[@name=\"i\"]/XCUIElementTypeOther[2]/XCUIElementTypeOther[1]/XCUIElementTypeOther[1]/XCUIElementTypeImage'): print('点击用户列表第一个') el2 = driver.find_element_by_xpath( "//XCUIElementTypeOther[@name=\"i\"]/XCUIElementTypeOther[2]/XCUIElementTypeOther[1]/XCUIElementTypeOther[1]/XCUIElementTypeImage") el2.click() else: print('没有相关用户') os.system('say 无相关用户') time.sleep(0.5) print('动作结束') os.system('say 动作结束') def scrollUp(self): self.driver.execute_script("mobile: scroll", &#123;"direction": "down"&#125;) def isExistElement(self, identifyBy, c): ''' 判断元素是否存在 用法: isExistElement(By.XPATH,"//a") ''' time.sleep(0.5) flag = None try: if identifyBy == "id": #self.driver.implicitly_wait(60) self.driver.find_element_by_id(c) elif identifyBy == "xpath": self.driver.find_element_by_xpath(c) elif identifyBy == "class": self.driver.find_element_by_class_name(c) elif identifyBy == "link text": self.driver.find_element_by_link_text(c) elif identifyBy == "partial link text": self.driver.find_element_by_partial_link_text(c) elif identifyBy == "name": self.driver.find_element_by_name(c) elif identifyBy == "tag name": self.driver.find_element_by_tag_name(c) elif identifyBy == "css selector": self.driver.find_element_by_css_selector(c) flag = True except selenium.common.exceptions.NoSuchElementException: flag = False finally: return flagdef spiderForKeyWord(keyWord): print('查找关键词：%s' % keyWord) spider = NeteaseNewsSpider() spider.findForKeyWord(keyWord)def spiderForUser(keyWord): print('查找用户：%s' % keyWord) spider = NeteaseNewsSpider() spider.findForUser(keyWord)def main(): type = Input.type keyWord = Input.keyWord if type == 'keyword': spiderForKeyWord(keyWord) elif type == 'user': spiderForUser(keyWord)if __name__ == "__main__": description = u"自动化 UI 操作，查找网易新闻" parser = argparse.ArgumentParser(description=description) parser.add_argument('-k', dest='keyWord', type=str, help='必填:关键词名字', required=True) parser.add_argument('-t', dest='type', type=str, choices=["keyword", "user"], help='必填:查找类型', required=True) args = parser.parse_args() Input.type = args.type Input.keyWord = args.keyWord main() 代理部分分析和保存数据addons.py1234567#!/usr/bin/python3import jokeraddons = [ joker.Joker()] common.py123456789101112131415161718192021222324252627282930313233343536373839#!/usr/bin/python3import osWORKING_DIR = "/Users/VanJay/Documents/Work/Tungee/新闻APP搜索接口破解情况/ant.git/netease_news_suite/"DataBasePath = WORKING_DIR + 'data'DataBaseKeywordPath = WORKING_DIR + 'data/' + 'Keyword'DataBaseUserPath = WORKING_DIR + 'data/' + 'User'AppiumPath = WORKING_DIR + 'appium'MitmproxyPath = WORKING_DIR + 'mitmproxy'SearchConfigPath = WORKING_DIR + 'currentSearchConfig.json'NeteaseAccountJSON = '/neteaseAccount.json'NeteaseAccountArticleJSON = '/neteaseAccountArticle.json'def getParamValue(url, key): defaultValue = None list = [i.split("=")[-1] for i in url.split("?", 1) [-1].split("&amp;") if i.startswith(key + "=")] if len(list) &gt; 0: value = list[0] if value != '': return value else: return defaultValue else: return defaultValuedef solveDirDependency(): if not os.path.exists(DataBasePath): os.system('mkdir ' + DataBasePath)def solveDestSearchOpDep(word): path = DataBasePath + '/' + word if not os.path.exists(path): os.system('mkdir ' + path) return path Joker.py123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299#!/usr/bin/python3import jsonimport mitmproxy.httpfrom mitmproxy import ctx, httpimport osimport shutilfrom common import getParamValue, solveDirDependency, solveDestSearchOpDepfrom common import SearchConfigPath, NeteaseAccountJSON, NeteaseAccountArticleJSONclass Joker: def __init__(self): self.netease_news_host = 'c.m.163.com' self.search_url = 'https://c.m.163.com/search/comp2/' self.re_search_url = self.search_url + 'MA%3D%3D/' self.relatedArticleURL = 'https://c.m.163.com/nc/recommend/relate/article/' self.hotDiscussURL = 'https://c.m.163.com/reader/api/recommend/viewpoints?docid=' self.articlePrefix = 'https://c.m.163.com/news/a/' self.videoArticlePrefix = 'https://c.m.163.com/news/v/' self.commentURLPreFix = 'https://comment.api.163.com/api/v1/products/a2869674571f77b5a0867c3d71db5856/threads/' self.commentURLSuffFix = '/app/comments/hotModuleList?ibc=newsappios' self.netesaeAccountProfileURL = 'https://c.m.163.com/uc/api/visitor/v3/simple/profile' self.neteaseAccountArticleURL = 'https://c.m.163.com/nc/subscribe/list/' self.newsTypeConfig = &#123; 'zonghe': &#123;'folderName': 'ZongHe'&#125;, 'shipin': &#123;'folderName': 'Video'&#125;, 'tuji': &#123;'folderName': 'Picture'&#125;, 'yonghu': &#123;'folderName': 'User'&#125; &#125; # self.currentNewsType = 'zonghe' # self.keyword = '关键词' # self.searchType = 'keyword' def request(self, flow: mitmproxy.http.HTTPFlow): request = flow.request url = request.scheme + '://' + request.host + request.path # 网易新闻的搜索关键词接口 if url.startswith(self.search_url): ctx.log.info("关键词搜索地址: %s " % request.pretty_url) def response(self, flow: mitmproxy.http.HTTPFlow): # 忽略非目标相关地址 if not flow.request.host in [self.netease_news_host, 'comment.api.163.com']: return request = flow.request path = request.path url = request.scheme + '://' + request.host + path # 搜索（包含全新搜索和分页搜索加载） self.dealingWithSearchResult(flow, path, url) # 相关文章 self.dealingRelatedArticles(flow, path, url) # 正在热议 self.dealingArticleHotDiscuss(flow, path, url) # 文章热评 self.dealingComments(flow, path, url) # 订阅号 self.dealingNeteaseAccount(flow, path, url) # 订阅号文章 self.dealingNeteaseAccountArticle(flow, path, url) def dealingWithSearchResult(self, flow: mitmproxy.http.HTTPFlow, path, url): if url.startswith(self.search_url): paramValue = getParamValue(url, 'tabname') self.currentNewsType = 'zonghe' if paramValue == None else paramValue # 搜索结果去掉为你推荐和网页结果 content = flow.response.get_content() contentJson = json.loads(content) contentJson['boxes'] = [] # 只要不是搜索用户就去掉网易号 if not self.currentNewsType == 'yonghu': contentJson['topic'] = &#123;&#125; flow.response.set_content((json.dumps(contentJson)).encode()) doc = &#123;&#125; docResultList = [] topic = &#123;&#125; topicResultList = [] if 'doc' in contentJson: doc = contentJson['doc'] if 'result' in doc: docResultList = doc['result'] if 'topic' in contentJson: topic = contentJson['topic'] if 'result' in topic: topicResultList = topic['result'] # 读取当前关键词 if not os.path.exists(SearchConfigPath): os.system('say 搜索配置不存在，请确认') exit() # 检查依赖 solveDirDependency() with open(SearchConfigPath, 'r') as file: fileJson = json.load(file) self.keyword = fileJson['keyword'] self.searchType = fileJson['type'] # 创建目标文件夹 self.currentSavePath = solveDestSearchOpDep(self.keyword) print('currentSavePath:' + self.currentSavePath) # 点击了重新搜索，而不是分页的继续搜索 if url.startswith(self.re_search_url): print('点击了重新搜索') if self.currentNewsType != 'yonghu': with open(self.getCurrentSearchTypePath() + '/doc.json', 'w') as file: file.write(json.dumps(doc, sort_keys=True, indent=4, ensure_ascii=False)) with open(self.getCurrentSearchTypePath() + '/result.json', 'w') as file: for item in docResultList: item['postURL'] = self.articlePrefix + item['postid'] + \ '.html?spss=newsapp&amp;from=singlemessage' file.write(json.dumps( docResultList, sort_keys=True, indent=4, ensure_ascii=False)) else: # 用户 with open(self.getCurrentSearchTypePath() + '/topic.json', 'w') as file: file.write(json.dumps(topic, sort_keys=True, indent=4, ensure_ascii=False)) with open(self.getCurrentSearchTypePath() + '/result.json', 'w') as file: for item in topicResultList: if 'ename' in item: item['profileURL'] = self.netesaeAccountProfileURL + item['ename'] + \ '.html?spss=newsapp&amp;from=singlemessage' file.write(json.dumps( topicResultList, sort_keys=True, indent=4, ensure_ascii=False)) # 网易新闻的搜索关键词接口(分页继续加载) else: print('分页继续搜索') if self.currentNewsType != 'yonghu': # 读取已保存数据 with open(self.getCurrentSearchTypePath() + '/result.json', 'r') as file: oldResult = json.load(file) # 拼接新数据 newResultList = oldResult + docResultList with open(self.getCurrentSearchTypePath() + '/result.json', 'w') as file: for item in newResultList: item['postURL'] = self.articlePrefix + item['postid'] + \ '.html?spss=newsapp&amp;from=singlemessage' file.write(json.dumps( newResultList, sort_keys=True, indent=4, ensure_ascii=False)) else: # 用户 # 读取已保存数据 with open(self.getCurrentSearchTypePath() + '/result.json', 'r') as file: oldResult = json.load(file) # 拼接新数据 newResultList = oldResult + topicResultList with open(self.getCurrentSearchTypePath() + '/result.json', 'w') as file: for item in newResultList: if 'ename' in item: item['profileURL'] = self.netesaeAccountProfileURL + item['ename'] + \ '.html?spss=newsapp&amp;from=singlemessage' file.write(json.dumps( newResultList, sort_keys=True, indent=4, ensure_ascii=False)) def dealingRelatedArticles(self, flow: mitmproxy.http.HTTPFlow, path, url): if url.startswith(self.relatedArticleURL): skipID = find_between(url, self.relatedArticleURL, '.html') if not os.path.exists(self.getCurrentSearchTypePath() + '/releatedoc'): os.system( 'mkdir ' + self.getCurrentSearchTypePath() + '/releatedoc') content = flow.response.get_content() contentJson = json.loads(content) releatedocList = contentJson['releatedoc'] releatedocSkipName = self.getCurrentSearchTypePath() + '/releatedoc/' + \ skipID + '.json' with open(releatedocSkipName, 'w') as file: for item in releatedocList: if item['type'] == 'doc': item['postURL'] = self.articlePrefix + item['docID'] + \ '.html?spss=newsapp&amp;from=singlemessage' elif item['type'] == 'video': item['postURL'] = self.videoArticlePrefix + item['docID'] + \ '.html?spss=newsapp&amp;from=singlemessage' file.write(json.dumps(releatedocList, sort_keys=True, indent=4, ensure_ascii=False)) def dealingArticleHotDiscuss(self, flow: mitmproxy.http.HTTPFlow, path, url): if url.startswith(self.hotDiscussURL): paramArr = path.split('?')[1].split('&amp;') docID = paramArr[len(paramArr) - 1].split('=')[1] find_between(url, self.relatedArticleURL, '.html') if not os.path.exists(self.getCurrentSearchTypePath() + '/ hotDiscuss'): os.system( 'mkdir ' + self.getCurrentSearchTypePath() + '/hotDiscuss') content = flow.response.get_content() contentJson = json.loads(content) hotDiscuss = contentJson['data'] if hotDiscuss != None: hotDiscussName = self.getCurrentSearchTypePath() + '/hotDiscuss/' + \ docID + '.json' with open(hotDiscussName, 'w') as file: file.write(json.dumps(hotDiscuss, sort_keys=True, indent=4, ensure_ascii=False)) def dealingComments(self, flow: mitmproxy.http.HTTPFlow, path, url): if url.startswith(self.commentURLPreFix): postID = find_between( url, self.commentURLPreFix, self.commentURLSuffFix) if not os.path.exists(self.getCurrentSearchTypePath() + '/hotCommentList'): os.system('mkdir ' + self.getCurrentSearchTypePath() + '/hotCommentList') content = flow.response.get_content() contentJson = json.loads(content) hotCommentList = contentJson['hotCommentList'] if hotCommentList != None: hotCommentListItemName = self.getCurrentSearchTypePath() + \ '/hotCommentList/' + postID + '.json' with open(hotCommentListItemName, 'w') as file: file.write(json.dumps(hotCommentList, sort_keys=True, indent=4, ensure_ascii=False)) def dealingNeteaseAccount(self, flow: mitmproxy.http.HTTPFlow, path, url): if url.startswith(self.netesaeAccountProfileURL): content = flow.response.get_content() contentJson = json.loads(content) if contentJson != None: hotCommentListItemName = self.getCurrentSearchTypePath() + NeteaseAccountJSON with open(hotCommentListItemName, 'w') as file: file.write(json.dumps( contentJson, sort_keys=True, indent=4, ensure_ascii=False)) def dealingNeteaseAccountArticle(self, flow: mitmproxy.http.HTTPFlow, path, url): if url.startswith(self.neteaseAccountArticleURL): ename = find_between(url, self.neteaseAccountArticleURL, '/all') content = flow.response.get_content() contentJson = json.loads(content) print('网易号:' + ename + '，用户名：' + contentJson['subscribe_info']['tname']) tagList = contentJson['tab_list'] for item in tagList: item['postURL'] = self.articlePrefix + item['postid'] + \ '.html?spss=newsapp&amp;from=singlemessage' if contentJson != None: hotCommentListItemName = self.getCurrentSearchTypePath() + NeteaseAccountArticleJSON with open(hotCommentListItemName, 'w') as file: file.write(json.dumps( contentJson, sort_keys=True, indent=4, ensure_ascii=False)) def load(self, entry: mitmproxy.addonmanager.Loader): ctx.log.info("addon 第一次加载") def done(self): ctx.log.info("addon 关闭或被移除，又或者 mitmproxy 本身关闭") def getRelatedArticleRequestURL(self, skipID): return self.relatedArticleURL + skipID + '.html' def getHotDiscussRequestURL(self, docID): return self.hotDiscussURL + docID def getCommentRequestURL(self, postID): return self.commentURLPreFix + postID + self.commentURLSuffFix def getCurrentSearchTypePath(self): path = self.currentSavePath + '/' + \ self.newsTypeConfig[self.currentNewsType]['folderName'] if not os.path.exists(path): os.system('mkdir ' + path) return pathdef find_between(s, first, last): try: start = s.index(first) + len(first) end = s.index(last, start) return s[start:end] except ValueError: return "" 写本地服务用户获取数据写一个基于 Flask 的服务，就两个接口： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#!/usr/bin/python3import syssys.path.append("..")from netease_news_suite.mitmproxy.common import DataBasePath, SearchConfigPath, AppiumPath, NeteaseAccountJSON, NeteaseAccountArticleJSONfrom flask import Flask, jsonify, requestfrom werkzeug.serving import run_with_reloaderfrom gevent import monkeyfrom gevent.pywsgi import WSGIServerfrom libs.foo import fooimport osimport jsonmonkey.patch_all()app = Flask(__name__)app.debug = Trueapp.secret_key = 'news_demo'# 获取关键词@app.route('/api/getArticlesForKeyword', methods=['GET'])def getArticlesForKeyword(): # 获取参数 keyword = request.args.get('keyword') # 设置搜索配置 setSearchConfig(keyword, 'keyword') os.chdir(AppiumPath) os.system('say 开始查找关键词' + keyword + '的新闻') os.system(f'python3 neteaseNewsSpider_iOS.py -k &#123;keyword&#125; -t keyword') articleList = [] # 获取文章列表 resultPath = DataBasePath + '/' + keyword + '/ZongHe/result.json' if os.path.exists(resultPath): with open(resultPath, 'r') as outfile: articleList = json.load(outfile) return jsonify(result=articleList), 200# 获取用户@app.route('/api/getInfoForUser', methods=['GET'])def getInfoForUser(): # 获取参数 keyword = request.args.get('keyword') # 设置搜索配置 setSearchConfig(keyword, 'user') os.chdir(AppiumPath) os.system('say 开始查找用户' + keyword + '的新闻') os.system(f'python3 neteaseNewsSpider_iOS.py -k &#123;keyword&#125; -t user') netesaeAccountInfo = &#123;&#125; netesaeAccountArticleInfo = &#123;&#125; # 获取用户信息 netesaeAccountInfoPath = DataBasePath + '/' + \ keyword + '/User' + NeteaseAccountJSON if os.path.exists(netesaeAccountInfoPath): with open(netesaeAccountInfoPath, 'r') as outfile: netesaeAccountInfo = json.load(outfile) # 获取用户文章列表 netesaeAccountArticleInfoPath = DataBasePath + '/' + \ keyword + '/User' + NeteaseAccountArticleJSON if os.path.exists(netesaeAccountArticleInfoPath): with open(netesaeAccountArticleInfoPath, 'r') as outfile: netesaeAccountArticleInfo = json.load(outfile) # 文章不存在处理 if not 'tab_list' in netesaeAccountArticleInfo: netesaeAccountArticleInfo['tab_list'] = [] return jsonify(subscriptionInfo=netesaeAccountInfo, subscriptionArticleInfo=netesaeAccountArticleInfo), 200def setSearchConfig(keyword, type): config = &#123; "keyword": keyword, "type": type, &#125; with open(SearchConfigPath, 'w') as file: file.write(json.dumps( config, sort_keys=True, indent=4, ensure_ascii=False))http_server = WSGIServer(('0.0.0.0', 12000), app)@run_with_reloaderdef run_server(): http_server.serve_forever() 界面部分客户端这步非必需，也可简单使用 postman 或浏览器直接调用测试，这里只是为了方便给客户展示效果。用 nw.js 或 Electron 生成一个跨平台的桌面应用，这里直接展示效果。 控制&amp;服务端 手机端 讨论这个示例是用的 iPhone 完成的，当然用安卓真机或安卓模拟器都是可以的，我都有尝试，模拟器试了夜神模拟器和网易 MUMU 模拟器，但是用这个方案有障碍，就是部分新闻 APP 在检测到系统启用了网络代理后不进入应用或者不加载数据，也就意味着这个方案被夭折，但是如果这个项目真要形成，最终肯定是要服务器跑安卓模拟器或者真机设备来完成数据采集，因为全部使用 iPhone 的话，一不能使用 iOS 模拟器安装第三方APP，二必须要有 Mac 环境，大批量的话成本过于高昂，所以我暂时想到的是可以逆向 apk，hook 类似于检测是否启用了网络代理的判断函数，每次都返回”未使用代理”，或者修改安卓系统本身这样的系统 api，让所有 APP 都检测不到系统使用了网络代理，当然了，这只是我的猜想，具体检测逻辑尚未调研，个人认为这里说的第一种可行性很高，有难度但是不大，至少可以预知比逆向得到请求参数加密的方法和逻辑简单太多，如果你有更好的方案，欢迎留言讨论。]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>自动化</tag>
        <tag>Python</tag>
        <tag>抓包</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 动态调整分区大小]]></title>
    <url>%2F2018%2F11%2F06%2FLinux-%E5%8A%A8%E6%80%81%E8%B0%83%E6%95%B4%E5%88%86%E5%8C%BA%E5%A4%A7%E5%B0%8F%2F</url>
    <content type="text"><![CDATA[背景Ubuntu根分区\空间告急，即将使用完毕 先清理出一定空间移除不再需要的软件包1sudo apt autoremove 清理Ubuntu中的APT缓存 你可以使用以下命令查看此缓存的大小： 1sudo du -sh /var/cache/apt 删除之 1sudo apt clean 清理缩略图缓存1rm -rf ~/.cache/thumbnails/* 手动删除老旧Linux内核首先使用如下命令列出当前 Ubuntu 中所有已经安装的 Linux Kernel： 1sudo dpkg --list 'linux-image*'* 删除旧版内核与删除任何其他软件包一样： 1sudo apt remove linux-image-VERSION 请自行将上述 VERSION 替换为要清除的内核版本，系统极客建议保持至少两个或三个最新版本内核，这样在无法使用最新内核启动系统时至少还有那么几个可替代品救急 删除多余的孤立包首先我们要说说什么是 Ubuntu 系统中的孤立包（也叫多余的包）：假设你安装了一个名为 myprogram 的软件包，而这个包又依赖于 mylib 库，这个库通常在安装 myprogram 时便会自动安装到系统当中。当你卸载 myprogram 应用时，mylib 库可能仍然保留在系统中。 此种情况下，mylib 就会成为一个孤立的包。 gtkorphan 这款图形化应用可以可以轻松找出并删除 Ubuntu 系统中的孤立包，先使用如下终端命令进行安装： 1sudo apt install gtkorphan 安装好后在「多余的包」选项卡中即可对查找、删除孤立包 使用GUI工具释放Ubuntu空间Stacer地址，下载 deb 包安装打开、使用 调整分区、根目录扩容我的是多系统，安装了 WIndows 10 、Deepin 15.8 和 Ubuntu 18.04，Ubuntu 根分区只给了10G，home 给了50，但是用不完，目标，从home起始位置分10个G给根分区（根分区在 home 分区之前）。由于根分区和 home 都被 Ubuntu 在使用，所以无法在 Ubuntu 中操作本身使用的根分区和home分区，所以应该到外部操作。 工具gparted GParted is a free partition manager that enables you to resize, copy, and move partitions without data loss. 思路一在其它 Linux 系统中操作 Ubuntu 磁盘，不同版本 Linux 安装 gparted 命令如下： Linux 发行版本 安装命令 Debian sudo apt-get install gparted Fedora su -c “yum install gparted” Mageia sudo urpmi gparted OpenSUSE sudo zypper install gparted Ubuntu sudo apt-get install gparted Deepin sudo apt-get install gparted 安装后执行 1sudo gparted 使用软件，方法同大多数磁盘分区调整工具 思路二如果本机没有多系统（对于方案一，硬盘拆下来接到其它机器也是可以的），由于gparted官方提供了可启动的刻录镜像，我们直接下载iSO镜像刻录至CD或者USB设备，从该启动盘启动即可操作 Ubuntu 所使用的分区 比如当前最新的桌面版是 gparted-live-0.33.0-1-amd64.iso，你可以下载该镜像刻录至 U 盘，随后从 U 盘启动进行操作 PS：刻录可使用 Etcher ，全平台使用 注意修改系统所在分区或引导所在分区存在无法启动被修改的分区的系统的风险，建议新手或者以防万一，对系统做一个完整备份，这里是一些免费磁盘和分区工具，可以完整备份分区或磁盘，使用方法自行看文档。 Clonezilla doClone FSArchiver G4L g4u Partimage Partclone]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>分区调整</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jenkins master-slave 的应用及 iOS 项目持续集成]]></title>
    <url>%2F2018%2F10%2F12%2FJenkins%20master-slave%20%E7%9A%84%E5%BA%94%E7%94%A8%E5%8F%8A%20iOS%20%E9%A1%B9%E7%9B%AE%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%2F</url>
    <content type="text"><![CDATA[背景在公司一台服务机上搭建了Jenkins，Linux环境，主要用于WEP 前端、Android、iOS的CI服务，在没有过多去了解的情况下，我想当然的以为如果要打包 iOS，Jenkins宿主机系统环境必须是MacOS，因为知道除了Mac，其它系统均无法打包iOS或Mac应用程序（当然这点在目前看来仍然是对的），于是在公司那台硬盘只剩下可怜巴巴的20G空间的Mac mini上安装了Jenkins，叫安卓同事把他的Jenkins job又重新放在了Mac mini上，本想着事情就这么不完美的收尾了，今天忽然在群里看见开发者朋友讨论Jenkins说到Jenkins支持master-slave（主从）模式，支持非宿主机作为一个Node节点为其服务，一脸蒙蔽，又要把Jenkins放回Ubuntu，让这台mini单独为iOS打包服务。 新建Node节点机基本设置步骤 Manage Jenkins -&gt; Manage Nodes -&gt; New Node；取名，比如叫slave-iOS，勾选Permanent Agent，下一步；看说明填写： Name： 节点机名称 Description: 节点机描述 of executors：节点机最大job并发数 Remote root directory : 节点机用于存放workspace的目录，确保你要使用的用户有该目录的读写权限，比如设置为/Users/VanJay/Documents/Work/tungee/jenkins Labels：标签，用于Jenkins查找Node Usage：自行选择， Use this node as much as possible：最大程序使用 Only build jobs with label expressions matching this node：只在使用该节点机才使用 Launch method：连接节点机的方式 Launch agent agents via SSH：通过SSH连接 Host：节点机IP Credentials：凭据，自行添加，如果使用Username with password，记得把验证策略下面这项选第三项 Host Key Verification Strategy： Known hosts file Verification Strategy：把master`ssh公钥拷贝到slave机known_hosts` Manually provided key Verification Strategy:手动提供 key Manually trusted key Verification Strategy：手动信任 Non verifying Verification Strategy：不验证 Launch agent via execution of command on the master：指定shell 脚本连接 AvailabilityL slave机可用性 Keep this agent online as much as possible：让slave尽可能在线 Take this agent online according to a schedule：根据计划保持在线 Take this agent online when in demand, and offline when idle：需要时在线，闲置时离线 Node Properties：节点机属性设置可以在slave机上设置工具位置和环境变量 Environment variables：自定义环境变量，比如可以导出PATH=$PATH:/usr/local/bin Tool Locations：工具位置：比如可以设置JDK目录/Library/Java/JavaVirtualMachines/jdk1.8.0_91.jdk/Contents/Home 使用slave机器在job里General项下勾选Restrict where this project can be run，指定slave机label就可以使用了。 事情总不会那么一帆风顺使用slave机器后你会发现原本在slave本机跑没事的shell在这里可能有问题，基本都是commomand not fuond，都是命令找不到，那就export这些命令，把整个/usr/local/bin或者/usr/bin加进去（没必要，个人建议用到什么加什么）。比如加入报pod command not found，在slave机运行which pod： 12☁ blog [master] ⚡ which pod/usr/local/bin/pod 嵌入环境变量安装Inject environment variables插件，安装方法可在本博客搜索 Ubuntu-18-04-搭建-Jenkins 查看文章。 正常shell打包123456789101112131415161718192021222324source ~/.alias# 清除上一次生成的 beta 包rm -rf $&#123;OUTPUT_FOLDER&#125;export LANG=en_US.UTF-8PODS_DIR="Pods"if [[ -d "$PODS_DIR" ]]; then rm -rf "$PODS_DIR"fisetproxypod installunsetproxy# 解锁 keychainsecurity default-keychain -s login.keychainsecurity unlock-keychain -p "123456." login.keychainfastlane beta source ~/.alias是为了能找到setproxy和unsetproxy `shell翻墙加快pod install速度，必须解锁keychain`，否则无法正常签名，导致构建失败，如果是在本机操作则不需要这两项。 fastlane 内容只编写了打beta和release包 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116fastlane_version "2.28.3"default_platform :iosscheme_name = "DongKe"workspace = 'DongKe.xcworkspace'configuration_Debug = 'Debug'configuration_Release = 'Release'export_method_ad_hoc = 'ad-hoc'export_method_appstore = 'app-store'team_id = 'TEAM_ID'username = 'xxx@xxx.com'app_identifier = 'app_identifier'platform :ios do before_all do # cocoapods end desc "截图" lane :snap do snapshot( scheme: scheme_name ) frameit(white: true, path: 'fastlane/screenshots') end lane :test do end desc "打包测试包" lane :beta do |options| #根据传入参数version设置app的版本号 # increment_version_number(version_number: option[:version]) # #自动增加build号 # increment_build_number # 获取是第几轮测试 # test_turn = options[:test_turn] # 自动运行测试工具 # scan # 崩溃分析 # crashlytics #证书签名 # sigh( # adhoc: true, # output_path: 'fastlane/mobileprovision' # ) #编译打包 version = get_info_plist_value(path: "#&#123;scheme_name&#125;/Info.plist", key: "CFBundleShortVersionString") build = get_info_plist_value(path: "#&#123;scheme_name&#125;/Info.plist", key: "CFBundleVersion") output_directory = File.expand_path("..", Dir.pwd) + File::Separator + 'build/beta/' + Time.now.strftime('%Y-%m-%d') output_name = "#&#123;scheme_name&#125;_#&#123;build&#125;_#&#123;export_method_ad_hoc&#125;_#&#123;Time.now.strftime('%Y-%m-%d %H%M')&#125;.ipa" gym( silent: true, clean: true, buildlog_path: "fastlane/fastlane_log", workspace: workspace, scheme: scheme_name, configuration: configuration_Release, output_directory: output_directory, output_name: output_name, export_method: export_method_ad_hoc, export_xcargs: "-allowProvisioningUpdates" ) # 上传到 fir # sh "fir publish #&#123;output_directory&#125;/#&#123;output_name&#125; -V -Q" end desc "打包正式包" lane :release do |options| #证书签名 # sigh( # adhoc: false, # output_path: './fastlane/mobileprovision' # ) #编译打包 version = get_info_plist_value(path: "#&#123;scheme_name&#125;/Info.plist", key: "CFBundleShortVersionString") build = get_info_plist_value(path: "#&#123;scheme_name&#125;/Info.plist", key: "CFBundleVersion") output_directory = File.expand_path("..", Dir.pwd) + File::Separator + 'build/release/' + Time.now.strftime('%Y-%m-%d') output_name = "#&#123;scheme_name&#125;_#&#123;build&#125;_#&#123;export_method_appstore&#125;_#&#123;Time.now.strftime('%Y-%m-%d %H%M')&#125;.ipa" gym( silent: true, clean: true, buildlog_path: "fastlane/fastlane_log", workspace: workspace, scheme: scheme_name, configuration: configuration_Release, output_directory: output_directory, output_name: output_name, export_method: export_method_appstore, export_xcargs: "-allowProvisioningUpdates" ) end lane :all do |options| beta release end after_all do |lane| end error do |lane, exception| endend]]></content>
      <categories>
        <category>工程自动化</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
        <tag>CI</tag>
        <tag>持续集成</tag>
        <tag>工程自动化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu 18.04 LTS 安装部署 Seafile]]></title>
    <url>%2F2018%2F10%2F01%2FUbuntu-18-04-LTS-%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2-Seafile%2F</url>
    <content type="text"><![CDATA[背景新入职的公司内部同步一些文件使用的 Seafile，没部署远程，只使用的内网，由于这个 seafile 是一个前同事搭建的（之前的 iOSer，我来替代他了，阴差阳错。。。），可能那时他也不是太熟吧，把文件存放目录放在了安装位置的挂载分区，导致长时间使用下来，该分区磁盘空间满了，无法继续运行，于是我简单 google 了一番，开始转移目录，找到了 seafile-data 目录之后，发现查看都没权限，包括 cp -R、mv 都无法运行，直接给了755权限，mv seafile-data 目录至新目录，更改 seafile.ini 文件，指向新目录，重启 seafile，发现 seafile 已经无法启动……下意识重启一下电脑，还是不行，这时看下禅道，测试又提了一堆 BUG，就先放下开始修 BUG 了。第二天早上过来继续，发现系统都进不去了，登录界面无法输入密码，没办法只好命令行登入系统，再次 google 了解到 seafile 存放文件的形式类似于 svn 或 git ，也是那种打散存放并内部记录 state 和带有 commit log 的，看到了官方有修复工具，尝试无果，放弃了，系统也崩了（多年linux 经验解决不了，尝试了几个小时，google 了解到貌似是 Ubuntu 16.04 LTS 的 bug 所致，有个旧内核依赖怎么都干不掉，导致所有的 dpkg -i 都运行不了），这台机器上安装了 jenkins 和 seafile，问过了别无其他，心想 jenkins 我也熟练部署了，只能硬着头皮去跟组长说要重装系统，于是有了这篇文章。 重装系统下载 Ububtu 系统，选了最新的长期支持版本 18.04，UI 大改了，看了挺喜欢，安排下载。这步没啥说，随便拿了个5年前的捣鼓用的 4G U盘，在 mac 制作了一个 Ubuntu 的安装盘。从 U盘启动，安装系统。 安装 Seafile 服务器端更新下系统12apt-get update apt-get upgrade 安装 python 2.7 及其它依赖由于 seafile 使用的 py 2.7，但 Ubuntu 默认集成的是 3+ 版本，所以要安装。 123apt-get install pythonapt-get install python2.7 libpython2.7 python-setuptools python-pil python-ldap python-urllib3 ffmpeg python-pip python-mysqldb python-memcachepip install pillow moviepy 安装 Mariadb1sudo apt install mariadb-server 开始安装 seafile下载 Seafile 服务器端程序去 Seafile官方下载地址 复制 服务器端 -&gt; Linux 服务器端 -&gt; 64bit 链接，比如现在最新的是 http://seafile-downloads.oss-cn-shanghai.aliyuncs.com/seafile-server_6.2.5_x86-64.tar.gz，目录的话建议安装到 /opt 下面，但是数据目录使用磁盘空间比较大的地方，比如我这边是是安装位置和数据目录都放在了 /home/data/seafile 下，过程如下： 12345cd /homemkdir -p data/seafile &amp;&amp; cd data/seafilewget http://seafile-downloads.oss-cn-shanghai.aliyuncs.com/seafile-server_6.2.5_x86-64.tar.gztar -xzf seafile-server_*mkdir installed &amp;&amp; mv seafile-server_6.2.5_x86-64.tar.gz installed 安装 seafile 服务端因为依赖环境和数据库都已经安装好了，这边我是使用的 Mariadb，所以用的是 seafile 写好的 setup-seafile-mysql.sh 脚本进行 setup，中间会提示你输入 seafile-data 数据存放目录，记得输入你指定的目录，比如我这里应该填/home/data/seafile/seafile-data，当然如果你已经在/home/data/seafile/seafile-server-6.2.5则直接 Enter 默认即可，它会自动去上层目录创建seafile-data目录。 12cd seafile-server-6.2.5sudo ./setup-seafile-mysql.sh 一路按引导完成，根据提示，输入服务器名、IP、数据目录（默认为../seafile-data）、seahub 端口、seafile-server监听端口（默认8082，不可更改），ifconfig 查看自己内网 ip，查完成之后确认设置，目录会变成如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152vanjay@VanJay:/home/data$ sudo tree -L 3.└── seafile ├── ccnet │ ├── ccnet.sock │ ├── misc │ ├── mykey.peer │ └── seafile.ini ├── conf │ ├── ccnet.conf │ ├── seafdav.conf │ ├── seafile.conf │ ├── seahub_settings.py │ └── seahub_settings.pyc ├── installed │ └── seafile-server_6.2.5_x86-64.tar.gz ├── logs │ ├── ccnet.log │ ├── controller.log │ ├── seafile.log │ ├── seahub.log │ └── seahub_django_request.log ├── pids │ ├── ccnet.pid │ └── seaf-server.pid ├── seafile-data │ ├── commits │ ├── fs │ ├── httptemp │ ├── library-template │ ├── storage │ └── tmpfiles ├── seafile-server-6.2.5 │ ├── check_init_admin.py │ ├── reset-admin.sh │ ├── runtime │ ├── seaf-fsck.sh │ ├── seaf-fuse.sh │ ├── seaf-gc.sh │ ├── seafile │ ├── seafile.sh │ ├── seahub │ ├── seahub.sh │ ├── setup-seafile-mysql.py │ ├── setup-seafile-mysql.sh │ ├── setup-seafile.sh │ └── upgrade ├── seafile-server-latest -&gt; seafile-server-6.2.5 └── seahub-data └── avatars22 directories, 26 files 启动/停止 Seafile启动Seafile-server和Seahub，第一次启动会提示建立管理员账号。 12./seafile.sh start./seahub.sh start &lt;端口号&gt; 此时通过浏览器本地访问 localhost:端口号，应该可以出现登录页面。如果出现网页乱码，可以删除/tmp/seahub_cache再重启seahub，即可恢复正常。 常用命令： 关闭 12./seahub.sh stop # 停止 Seahub./seafile.sh stop # 停止 Seafile 进程 重启 12./seafile.sh restart # 停止当前的 Seafile 进程，然后重启 Seafile./seahub.sh restart # 停止当前的 Seahub 进程，并在 8000 端口重新启动 Seahub 使用 pgrep 命令检查 seafile/seahub 进程是否还在运行中 12pgrep -f seafile-controller # 查看 Seafile 进程pgrep -f "seahub" # 查看 Seahub 进程 使用 pkill 命令杀掉相关进程 12pkill -f seafile-controller # 结束 Seafile 进程pkill -f "seahub" # 结束 Seafile 进程 配置防火墙本地可以访问了，但从外部访问就不行了，需要配置下防火墙，当然你也直接关闭防火墙。 开关防火墙 12ufw disable # 关闭ufw enable # 开启 也可添加端口，端口8082，必须添加，这是 seafile-file 端口，不可更改。8000为 seahub 默认监听端口，如果自定义 seahub 监听端口，这里记得添加。 12345firewall-cmd --permanent --add-port=8000/tcpfirewall-cmd --permanent --add-port=8082/tcpfirewall-cmd --permanent --add-service httpfirewall-cmd --reloadfirewall-cmd --list-all 安装 Ubuntu Seafile 客户端开始使用吧。 123sudo add-apt-repository ppa:seafile/seafile-clientsudo apt-get updatesudo apt-get install seafile-gui 添加执行用户和配置目录权限123useradd vanjay -s /sbin/nologin -d /home/data/seafilechown -R vanjay:vanjay /home/data/seafile/chown -R vanjay:vanjay /tmp/seahub_cache/ 配置开机自启动 Seafile对于运行 systemd 的系统（例如 Debian 8 以及更新的版本，Ubuntu 15.04以及更新的版本），创建 systemd 服务管理文件（注意自行更改 User 、Group 和Seafile 路径） 创建 seafile service 1sudo vim /etc/systemd/system/seafile.service 注意！注意！注意！ 这里有个大坑，花了我一个晚上去解决！由于官方提供了开机启动 service 脚本，一般都是直接拿来用，改改路径用户名就好，但是！我在 Ubuntu 18.04 开机启动 seafile 上花了整整一个晚上！，systemctl status seafile查看服务状态，由于 seafile 启动依赖数据库，所以需要先等待数据库服务启动完毕再启动，我这安装的是 mariadb ，所以要在 After 后面加上 mariadb.service，重启正常自启了，阿弥陀佛！ 123456789101112131415[Unit]Description=Seafile# add mysql.service or postgresql.service depending on your database to the line belowAfter=network.target mariadb.service[Service]Type=oneshotExecStart=/home/data/seafile/seafile-server-latest/seafile.sh startExecStop=/home/data/seafile/seafile-server-latest/seafile.sh stopRemainAfterExit=yesUser=vanjayGroup=vanjay[Install]WantedBy=multi-user.target 创建 seahub service 1sudo vim /etc/systemd/system/seahub.service 输入如下内容，用户、用户组、路径改为自己的 seafile 路径。 123456789101112131415[Unit]Description=Seafile hubAfter=network.target seafile.service[Service]# change start to start-fastcgi if you want to run fastcgiExecStart=/home/data/seafile/seafile-server-latest/seahub.sh startExecStop=/home/data/seafile/seafile-server-latest/seahub.sh stopUser=vanjayGroup=vanjayType=oneshotRemainAfterExit=yes[Install]WantedBy=multi-user.target 设置服务开机自启动123sudo systemctl daemon-reloadsudo systemctl enable seafilesudo systemctl enable seahub 配置邮件通知服务编辑你 seafile 目录下的 conf/seahub_settings.py文件，比如我这里应该 vim /home/data/seafile/conf/seahub_settings.py，加入如下内容，我只尝试了阿里企业邮箱和 qq 邮箱，仅供参考，EMAIL_HOST 填写发送邮件服务器，EMAIL_PORT 填写发送邮件服务器端口，改完重启 seafile 生效。 QQ 邮箱，EMAIL_HOST_PASSWORD 是授权码，去 qq 邮箱设置获取。1234567EMAIL_USE_SSL = TrueEMAIL_HOST = 'smtp.qq.com'EMAIL_HOST_USER = 'your_qq_number@qq.com'EMAIL_HOST_PASSWORD = 'your_auth_code'EMAIL_PORT = '465'DEFAULT_FROM_EMAIL = EMAIL_HOST_USERSERVER_EMAIL = EMAIL_HOST_USER 阿里企业邮箱，EMAIL_HOST_PASSWORD 是邮箱密码。1234567EMAIL_USE_SSL = FalseEMAIL_HOST = 'smtp.mxhichina.com'EMAIL_HOST_USER = 'username@xxx.com'EMAIL_HOST_PASSWORD = 'your_password'EMAIL_PORT = '25'DEFAULT_FROM_EMAIL = EMAIL_HOST_USERSERVER_EMAIL = EMAIL_HOST_USER 致谢参考链接： Seafile 中文文档 搭建一个属于自己的Seafile网盘]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
        <tag>Seafile</tag>
        <tag>个人云盘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 开发从 Array 生成特定分隔符隔开的 String]]></title>
    <url>%2F2018%2F10%2F01%2FiOS-%E5%BC%80%E5%8F%91%E4%BB%8E-Array-%E7%94%9F%E6%88%90%E7%89%B9%E5%AE%9A%E5%88%86%E9%9A%94%E7%AC%A6%E9%9A%94%E5%BC%80%E7%9A%84-String%2F</url>
    <content type="text"><![CDATA[从一个String Array 或者 Object Array 生成字符串，使用特定的分隔符隔开，起始和末尾不需要分隔符，当传入的是对象的时候，需要指定Object 中 String 的 key 字符串，效果如下图所示： 直接看代码，只是备忘。 头文件123456789101112131415161718//// TGStringTool.h// DongKe//// Created by VanJay on 2018/9/30.// Copyright © 2018 DongKe. All rights reserved.//#import &lt;Foundation/Foundation.h&gt;NS_ASSUME_NONNULL_BEGIN@interface TGStringTool : NSObject+ (NSString *)stringWithStringArr:(NSArray&lt;NSString *&gt; *)arr separatedStr:(NSString *)separatedStr;+ (NSString *)stringWithArr:(NSArray&lt;id&gt; *)arr valueKey:(NSString *)key separatedStr:(NSString *)separatedStr;@endNS_ASSUME_NONNULL_END 实现文件123456789101112131415161718192021222324252627282930313233343536373839404142434445//// TGStringTool.m// DongKe//// Created by VanJay on 2018/9/30.// Copyright © 2018 DongKe. All rights reserved.//#import &quot;TGStringTool.h&quot;@implementation TGStringTool+ (NSString *)stringWithStringArr:(NSArray&lt;NSString *&gt; *)arr separatedStr:(NSString *)separatedStr &#123; NSMutableString *temp = [NSMutableString string]; if (arr.count &gt; 0) &#123; [arr enumerateObjectsUsingBlock:^(NSString *_Nonnull str, NSUInteger idx, BOOL *_Nonnull stop) &#123; if (str.length &gt; 0) &#123; [temp appendString:str]; if (idx &lt; arr.count - 1) &#123; [temp appendString:separatedStr]; &#125; &#125; &#125;]; &#125; return temp;&#125;+ (NSString *)stringWithArr:(NSArray&lt;id&gt; *)arr valueKey:(NSString *)key separatedStr:(NSString *)separatedStr &#123; NSMutableString *temp = [NSMutableString string]; if (arr.count &gt; 0) &#123; [arr enumerateObjectsUsingBlock:^(id _Nonnull obj, NSUInteger idx, BOOL *_Nonnull stop) &#123; if ([obj respondsToSelector:NSSelectorFromString(key)]) &#123; NSString *str = [obj valueForKey:key]; if (str.length &gt; 0) &#123; [temp appendString:str]; if (idx &lt; arr.count - 1) &#123; [temp appendString:separatedStr]; &#125; &#125; &#125; &#125;]; &#125; return temp;&#125;@end]]></content>
      <categories>
        <category>iOS 开发</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>iOS</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 数字转 xx 万 xx 亿]]></title>
    <url>%2F2018%2F09%2F30%2FiOS-%E6%95%B0%E5%AD%97%E8%BD%AC-xx-%E4%B8%87-xx-%E4%BA%BF%2F</url>
    <content type="text"><![CDATA[App 开发显示 XX 万 xx 亿APP开发中界面显示很多地方需要显示数字，但是如果数字过大，可能会有将数字显示成 xx 万、xx 百万、xx 亿的需求，简单封装了一下，备忘，以便日后使用。 这是声明文件，调用者可以决定保留几位小数，是否需要四舍五入，也可依据代码自行扩展方法。 12345678910111213141516171819202122232425// TGCaculateNumberTool.h// Tungee//// Created by VanJay on 2018/8/22.// Copyright © 2018年 Tungee. All rights reserved.//#import &lt;Foundation/Foundation.h&gt;typedef NS_ENUM(NSInteger, TGCNRoundingMode) &#123; TGCNRoundingModeUpAndDown = 0, ///&lt; 四舍五入 TGCNRoundingModeOnlyUp, ///&lt; 只入不舍 TGCNRoundingModeOnlyDown, ///&lt; 只舍不入&#125;;@interface TGCaculateNumberTool : NSObject/** 返回数字描述 @param number 数字 @param toFixed 保留小数位数 @param roundingMode 是否四舍五入 */+ (NSString *)stringFromNumber:(double)number toFixedCount:(NSInteger)toFixed roundingMode:(TGCNRoundingMode)roundingMode;@end 这是实现文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102// TGCaculateNumberTool.m// Tungee//// Created by VanJay on 2018/8/22.// Copyright © 2018年 Tungee. All rights reserved.//#import &quot;TGCaculateNumberTool.h&quot;@implementation TGCaculateNumberToolstatic NSNumberFormatter *formater;static NSDictionary *configDict;+ (void)initialize &#123; if (self == [TGCaculateNumberTool class]) &#123; formater = [[NSNumberFormatter alloc] init]; // 可自行扩展 configDict = @&#123; @&quot;wan&quot;: @&#123; @&quot;unit&quot;: @&quot;万&quot;, @&quot;dividend&quot;: @(10000.0) &#125;, @&quot;yi&quot;: @&#123; @&quot;unit&quot;: @&quot;亿&quot;, @&quot;dividend&quot;: @(100000000.0) &#125;, @&quot;wanYi&quot;: @&#123; @&quot;unit&quot;: @&quot;万亿&quot;, @&quot;dividend&quot;: @(1000000000000.0) &#125; &#125;; &#125;&#125;+ (NSString *)stringFromNumber:(double)number toFixedCount:(NSInteger)toFixed roundingMode:(TGCNRoundingMode)roundingMode &#123; NSString *output; formater.maximumFractionDigits = toFixed; if (roundingMode == TGCNRoundingModeUpAndDown) &#123; formater.roundingMode = NSNumberFormatterRoundHalfEven; // 四舍五入 &#125; else if (roundingMode == TGCNRoundingModeOnlyUp) &#123; formater.roundingMode = NSNumberFormatterRoundCeiling; // 只入不舍 &#125; else if (roundingMode == TGCNRoundingModeOnlyDown) &#123; formater.roundingMode = NSNumberFormatterRoundFloor; // 只舍不入 &#125; else &#123; // 默认 formater.roundingMode = NSNumberFormatterRoundHalfEven; // 四舍五入 &#125; // 如果要五入恰好传入临界值，则h对该值加1，换单位，避免出现10000万这样情况 if (formater.roundingMode == NSNumberFormatterRoundHalfEven || formater.roundingMode == NSNumberFormatterRoundCeiling) &#123; if (number == 9999 || number == 99999999 || number == 999999999999) &#123; number = number + 1; &#125; &#125; if (number &lt;= 0) &#123; output = @&quot;0&quot;; &#125; else if (number &lt;= 9999) &#123; output = [NSString stringWithFormat:@&quot;%@&quot;, [formater stringFromNumber:@(number)]]; &#125; else if (number &lt;= 99999999) &#123; // 9999999 double value = (double)number / [configDict[@&quot;wan&quot;][@&quot;dividend&quot;] doubleValue]; output = [NSString stringWithFormat:@&quot;%@%@&quot;, [formater stringFromNumber:@(value)], configDict[@&quot;wan&quot;][@&quot;unit&quot;]]; &#125; else if (number &lt;= 999999999999) &#123; // 999999999999 double value = (double)number / [configDict[@&quot;yi&quot;][@&quot;dividend&quot;] doubleValue]; output = [NSString stringWithFormat:@&quot;%@%@&quot;, [formater stringFromNumber:@(value)], configDict[@&quot;yi&quot;][@&quot;unit&quot;]]; &#125; else &#123; double value = (double)number / [configDict[@&quot;wanYi&quot;][@&quot;dividend&quot;] doubleValue]; output = [NSString stringWithFormat:@&quot;%@%@&quot;, [formater stringFromNumber:@(value)], configDict[@&quot;wanYi&quot;][@&quot;unit&quot;]]; &#125; return output;&#125;/** 计算特定小数位数 @param input 输入数字 @param toFixed 保留小数位数 @param isRounded 是否四舍五入 *///+ (double)roundFloat:(double)input toFixedCount:(NSInteger)toFixed rounded:(BOOL)isRounded &#123;//// double scale = 1;// if (toFixed == 0) &#123;// scale = 1;// &#125; else if (toFixed == 1) &#123;// scale = 10;// &#125; else if (toFixed == 2) &#123;// scale = 100;// &#125; else if (toFixed == 3) &#123;// scale = 1000;// &#125; else if (toFixed == 4) &#123;// scale = 10000;// &#125;// if (isRounded) &#123;// return (floorf(input * scale + 0.5)) / scale;// &#125; else &#123;// return (floorf(input * scale - 0.5)) / scale;// &#125;//&#125;@end]]></content>
      <categories>
        <category>iOS 开发</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Objective</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu 18.04 搭建 Jenkins]]></title>
    <url>%2F2018%2F09%2F12%2FUbuntu-18-04-%E6%90%AD%E5%BB%BA-Jenkins%2F</url>
    <content type="text"><![CDATA[前言 工欲善其事，必先利其器 打包是开发过程中必不可少的一步，随着项目的壮大，打包时间越来越长，如果一直手动操作，浪费时间不说，还容易出错。记录一下安装Jenkins的过程，以备不时之需。 环境（要求） 宿主机系统：Ubuntu 18.04 root用户最高权限 步骤安装 JAVAJenkins是基于JAVA的应用程序，所以要先安装Java OpenJDK。 添加源安装包software-properties-common，添加java OpenJDK PPA仓库源 12sudo apt install software-properties-common apt-transport-https -ysudo add-apt-repository ppa:openjdk-r/ppa -y 安装JAVA 81sudo apt install openjdk-8-jdk -y 检查 JAVA 是否安装成功1java -version 安装 JenkinsJenkins提供Ubuntu安装包，从该仓库安装 添加Jenkins签名1wget -q -O - https://pkg.jenkins.io/debian-stable/jenkins.io.key | sudo apt-key add 添加Jenkins仓库添加稳定版1sudo apt-add-repository "deb https://pkg.jenkins.io/debian-stable binary/" 添加最新版1sudo apt-add-repository "deb http://pkg.jenkins-ci.org/debian binary/" 更新apt，安装Jenkins12sudo apt updatesudo apt install jenkins -y 启动Jenkins并加入开机自启12systemctl start jenkinssystemctl enable jenkins 检查Jenkins是否启动Jenkins已经启动，默认端口是8080,检查一下是否已运行 1netstat -plntu 配置防火墙1234ufw allow sshufw allow httpufw allow httpsufw enable 如果需要从外部机器打开Jenkins，记得开启防火墙端口，以默认8080端口为例 123sudo firewall-cmd --permanent --add-port=8080/tcpsudo firewall-cmd --reloadsudo firewall-cmd --list-all 启动Jenkins浏览器打开localhost:8080，不出意外进入Jenkins界面了，Jenkins会有一个初始的管理密码，查看： 1cat /var/lib/jenkins/secrets/initialAdminPassword 安装推荐的插件复制该密码到浏览器，将进入到Jenkins初始化界面，按照指引安装推荐的插件，等待结束。如果一直提示网络离线，请确保没有使用 VPN，如果用了Shadowsocks，走PAC模式都不行，请关闭。 安装其它插件正常联网安装如果网络一直没问题的话，在jenkins内可以安装插件就在 Manage Jenkins -&gt; Manage Plugins -&gt; Available里面搜索想要安装的插件，安装完后记得重启Jenkins，如果网络一直不好，可以选择下面的方式离线安装。 离线下载安装去 https://plugins.jenkins.io 下载Jenkins插件，下载好后在Jenkins页面安装，在 Manage Jenkins -&gt; Manage Plugins -&gt; Advanced -&gt; Upload Plugin里上传安装。这里建议安装Environment Injector Plugin、build-name-setter，第一个是在构建时可以在运行时引入环境变量，在master-slave模式下尤为有用，第二个是可以动态修改构建名称，默认的是#1、#2 这样直接根据构建次数命名的非常不直观，自定义以后就能实现类似于DongKe_ad_hoc_#9_origin/ftr-1.5.0_bbeec66325a14413ae17257793028ceb5cd6204b这样非常直观的名称。 使用 Jenkins新建 Item开始使用，具体使用方法谷歌，其实不难。也可以查看 WIKI。 注意点如果更改了用户组，记得修改权限，否则Jenkins将抛出IO error无法启动。比如本来/var/lib/jenkins目录所有者是usera，现在需要更改为userb所有： 123sudo chown -R userb:userb /var/lib/jenkins# 修改权限，我是直接给了777sudo chmod -R 777 /var/lib/jenkins]]></content>
      <categories>
        <category>工程自动化</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
        <tag>CI</tag>
        <tag>持续集成</tag>
        <tag>工程自动化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[更改 React Native 默认 ios、android 项目文件夹]]></title>
    <url>%2F2018%2F09%2F10%2F%E6%9B%B4%E6%94%B9-React-Native-%E9%BB%98%E8%AE%A4-ios%E3%80%81android-%E9%A1%B9%E7%9B%AE%E6%96%87%E4%BB%B6%E5%A4%B9%2F</url>
    <content type="text"><![CDATA[背景来到新公司也有一个月了，完成 iOS 端洞客项目V1.3.0-V1.4.0的升级，虽然只是一个小版本的升级，但我在熟悉项目过程当中发现项目垃圾代码实在太多了，别说我了，一般的接锅人看了也难以忍受，在痛苦了几天之后我默默拉了一个新 git 分支改起来，使用 clang format规范化了整个项目的代码，后面结合git hook在git commit前自动reformat代码，这一步可以说是非常爽了。直到今天，我之前简单看了一下，check out到我改之前和改之后的代码，少了有5000+行代码，删除了几十个类文件，但里面还是充斥着大量的垃圾或者不合理的代码。开发完1.4.0，稍微看起来闲了一两天，被个喜欢行使小权利的前端小组长安装研习 React Native，准备接入原生项目，暂时用于替换一个改动比较频繁的详情页，之前就有自己学习过，但是都忘光了，又复习一遍，趁热记录一些小 tip。 接入原生 OC 项目这一步我会专门写一篇 blog 来记录，因为还是有踩几个坑的。 更改 iOS 和 Android 项目名本来原生开发的好好的，顶层文件夹用的是项目名，要接入 RN，用的方案也是 RN 顶层文件夹包含安卓和 iOS 项目，但 RN 默认只认 ios 和 android 两个文件夹作为项目路径，google 了一番找了找官方文档没看到有关于这里的自定义，看看 cli 里有没有相关 help，看了下，确实有，如下： 查看react-native cli帮助123456789101112131415161718☁ mobile-dongke-RN [RN-integration] ⚡ react-native run-ios --help react-native run-ios [options] builds your app and starts it on iOS simulator Options: --simulator [string] Explicitly set simulator to use (default: iPhone 6) --configuration [string] Explicitly set the scheme configuration to use --scheme [string] Explicitly set Xcode scheme to use --project-path [string] Path relative to project root where the Xcode project (.xcodeproj) lives. The default is 'ios'. (default: ios) --device [string] Explicitly set device to use by name. The value is not required if you have a single device connected. --udid [string] Explicitly set device to use by udid --no-packager Do not launch packager while building --verbose Do not use xcpretty even if installed --port [number] (default: 8081) --config [string] Path to the CLI configuration file -h, --help output usage information 看到可以通过设置--project-path参数来设置关联 XCode 项目的根文件夹，可以看到这里还可以指定模拟器类型，默认使用的是iPhone 6，挺不喜欢的，这里也改了，我们可以通过运行如下命令查看本机有哪些模拟器可以使用： 查看本机可用模拟器1234567891011121314151617181920212223242526☁ ~ xcrun simctl list devices== Devices ==-- iOS 8.1 -- iPhone 4s (E62E0A29-BCEE-4BB1-B27C-1D5CC225C6B0) (Shutdown) iPhone 5 (2D4FE14B-E33D-491C-B919-3352FA32B03A) (Shutdown) iPhone 5s (A90FF130-CDE8-4D60-AEFE-9DAA4ACA8F9A) (Shutdown) iPhone 6 (518A2EFE-1AD8-47AD-B5AC-F2424D55444D) (Shutdown) iPhone 6 Plus (4BFB145F-1D34-4BE9-9A1B-2EBED4F11DEC) (Shutdown) iPad 2 (83D02E68-7184-4ABF-B6D6-33A9CA056BF0) (Shutdown) iPad Retina (5D2B27ED-87F1-4ADD-8333-31FE4B239EDA) (Shutdown) iPad Air (07AC87B1-9C9B-4645-975E-861CFFB323A3) (Shutdown)-- iOS 10.0 -- iPhone 5 (43372734-B0C6-4C7B-85C0-DFC41F9B9883) (Shutdown) iPhone 5s (5D88D6F2-4683-4DC2-8FBA-7F762683E22C) (Shutdown) iPhone 6 (CFFB2105-C2A6-4EEC-91F2-2F805F0F94DF) (Shutdown) iPhone 6 Plus (C4B1BC99-AF7B-4F11-8752-DA5C18676428) (Shutdown) iPhone 6s (2D4D0793-6794-4AAF-BC82-BC7313D749D1) (Shutdown) iPhone 6s Plus (BBA3565D-3705-419F-9ABE-994C218B27B0) (Shutdown) iPhone SE (4DB18D89-DA99-4D66-9B18-7ED30A0D9491) (Shutdown) iPad Air (50E6ADA1-B589-43D1-A3A9-B653EC43D298) (Shutdown) iPad Air 2 (15331EA9-7F84-4D63-B36E-FE15C5F89E96) (Shutdown) iPad Pro (9.7 inch) (6A23335C-9A5A-4B84-B671-1F60E5A0E1D0) (Shutdown) iPad Pro (12.9 inch) (451FBDD2-AD2D-4E53-8025-DEA420376618) (Shutdown)-- iOS 12.0 -- iPhone 5s (89879C1B-D07C-4D4E-BC62-6525A9BB4B7B) (Shutdown) iPhone 6 (D437284B-3464-4F81-9AA7-A19690B80892) (Shutdown) 编写简单的 Shell，省去每次敲烦恼这样我们选自己想使用的模拟器、自定义项目路径这两件都 OK 了，最后我们可以编写一个 Shell 脚本，就不用每次都要手敲了，在 RN 项目根路径下运行： 123☁ mobile-dongke-RN [RN-integration] ⚡ touch run-ios-iPhone_8.sh☁ mobile-dongke-RN [RN-integration] ⚡ echo -e "#\!/bin/bash\n\nreact-native run-ios --project-path "./puma" --simulator "iPhone 8"" &gt;&gt; run-ios-iPhone_8.sh☁ mobile-dongke-RN [RN-integration] ⚡ chmod +x run-ios-iPhone_8.sh 使用Shell脚本启动iOS项目下次运行直接运行run-ios-iPhone_8.sh就好了，当然你也可以直接从 XCode 启动项目。 1☁ mobile-dongke-RN [RN-integration] ⚡ ./run-ios-iPhone_8.sh 安卓端项目路径自定义同理我们可以运行react-native run-android --help查看帮助，可以看到可以通过指定--root参数来设置，读者可以根据帮助自行设置。 123456789101112131415161718192021☁ mobile-dongke-RN [RN-integration] ⚡ react-native run-android --help react-native run-android [options] builds your app and starts it on a connected Android emulator or device Options: --install-debug --root [string] Override the root directory for the android build (which contains the android directory) (default: ) --flavor [string] --flavor has been deprecated. Use --variant instead --variant [string] --appFolder [string] Specify a different application folder name for the android source. (default: app) --appId [string] Specify an applicationId to launch after build. (default: ) --appIdSuffix [string] Specify an applicationIdSuffix to launch after build. (default: ) --main-activity [string] Name of the activity to start (default: MainActivity) --deviceId [string] builds your app and starts it on a specific device/simulator with the given device id (listed by running "adb devices" on the command line). --no-packager Do not launch packager while building --port [number] (default: 8081) --terminal [string] Launches the Metro Bundler in a new window using the specified terminal path. (default: ) --config [string] Path to the CLI configuration file -h, --help output usage information]]></content>
      <categories>
        <category>React Native</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[在已有 OC 项目无痛集成 React Native]]></title>
    <url>%2F2018%2F09%2F03%2F%E5%9C%A8%E5%B7%B2%E6%9C%89-OC-%E9%A1%B9%E7%9B%AE%E6%97%A0%E7%97%9B%E9%9B%86%E6%88%90-React-Native%2F</url>
    <content type="text"><![CDATA[基本要求 对 Cocoapods 使用熟悉 熟悉 Mac 基本操作 解决问题的基本功 官方示例这是官方给出的教程，集成到现有原生应用，按照这个集成的跑起来没啥问题，但是后期等你用了一些组件，或原生或 RN 的，比如自定义 UIView 给 RN 用，RN 里用的第三方的 component 调用了原生的 API，官方的这些默认的 pod 库就是缺少一些的，跑项目会出一些莫名其妙的问题，我在用了react-navigation后各种运行时红屏报错问题，错误提示也看不出个所以然来，折腾好久才解决问题，这里我将直接记录主要过程和注意点，以备不时之需。 踩坑后的做法 根据官方给出的搭建开发环境配置好环境 这时已经装好了react-native-cli，随便init一个新项目出来 创建一个文件夹，准备用来存放集成 RN 的项目，比如 ProjectIntegrateRN 拷贝app.json、node_modules、package.json 文件\文件夹 到ProjectIntegrateRN文件夹 拷贝原来的 OC\Swift 项目至 ProjectIntegrateRN文件夹 这里假设项目已经使用了 Cocoapods 管理第三方库，进入原生OC\Swift项目根目录，执行： 1☁ puma [RN-integration] vim Podfile 加入React Native的依赖： 12345678910111213141516171819202122232425262728293031def rnpods pod 'React', :path =&gt; "../node_modules/react-native", :subspecs =&gt; [ "Core", "ART", "RCTActionSheet", "RCTAnimation", # FlatList和原生动画功能需要此模块 "RCTCameraRoll", "RCTGeolocation", "RCTImage", "RCTNetwork", "RCTText", "RCTVibration", "RCTWebSocket", # 调试功能需要此模块 "DevSupport", # 如果RN版本 &gt;= 0.43，则需要加入此行才能开启开发者菜单 "CxxBridge", # 如果RN版本 &gt;= 0.47则加入此行 # 在这里继续添加你所需要的其他RN模块 #'RCTAdSupport', 'RCTPushNotification', 'RCTSettings', 'RCTLinkingIOS'] # 如果你的RN版本 &gt;= 0.42.0，则加入下面这行 pod 'yoga', :path =&gt; "../node_modules/react-native/ReactCommon/yoga" # 如果RN版本 &gt;= 0.45则加入下面三个第三方编译依赖 pod 'DoubleConversion', :podspec =&gt; "../node_modules/react-native/third-party-podspecs/DoubleConversion.podspec" pod 'Folly', :podspec =&gt; "../node_modules/react-native/third-party-podspecs/Folly.podspec" pod 'glog', :podspec =&gt; "../node_modules/react-native/third-party-podspecs/glog.podspec" pod 'RNVectorIcons', :path =&gt; '../node_modules/react-native-vector-icons'end 开始使用把rnpods加入到 Target &quot;your_scheme&quot; ，pod update或者pod install等结束，不出意外的话应该能跑了. 更改默认 node 端口RN项目目录执行： 1☁ puma [RN-integration] mvim node_modules/react-native/local-cli/server/server.js CTRL+F查找 8081 替换为你想要的端口，比如换成 6666 。 原生代码里记得更改，比如 OC 项目里这样改： 12345678910111213141516NSURL *jsCodeLocation;// nodejsCodeLocation = [NSURL URLWithString:@&quot;http://localhost:6666/src/index.bundle?platform=ios&quot;];// 如果打包或真机，使用下面这个// jsCodeLocation = [NSURL URLWithString:[[NSBundle mainBundle] pathForResource:@&quot;index.jsbundle&quot; ofType:nil]];_rnView = [[RCTRootView alloc] initWithBundleURL:jsCodeLocation moduleName:@&quot;DongKe&quot; initialProperties: @&#123; @&quot;enterpriseID&quot;: self._id, @&quot;source&quot;: @(self.source) &#125; launchOptions:nil];]]></content>
      <categories>
        <category>iOS 开发</category>
      </categories>
      <tags>
        <tag>React Native</tag>
        <tag>Hybrid</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS里关于block的一些理解]]></title>
    <url>%2F2018%2F06%2F18%2FiOS%E9%87%8C%E5%85%B3%E4%BA%8Eblock%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[介绍block实际上就是Objective-C语言对于闭包的实现。block配合上dispatch_queue，可以方便地实现简单的多线程编程和异步编程。（闭包是一个函数（或指向函数的指针），再加上该函数执行的外部的上下文变量（有时候也称作自由变量）。） block的写法回传值(^名字)(参数列); 1234567// 声明一个square的Block Pointer，其所指向的Block有一个int输入和int输出 typedef int (^square)(int); // 将Block实体指定给square square = ^(int a)&#123; return a * a; &#125;; // 调用方法，感觉是是不是很像function的用法？ int result = square(5); NSLog(@"%d", result); 当其作为Object-C method的传入值的话，需要把类型写在变量前面，然后加上小括号。比如下面这种写法： 12// square参数的类型是int(^)(int) -(void)objcMethod:(int(^)(int))square; block阵列的使用 1234567891011&#123; void (^blocks[3])(void); for (NSInteger i = 0; i &lt; 3; i++) &#123; blocks[i] = ^&#123; NSLog(@"Hello:%i", i); &#125;; &#125; blocks[0](); // result:Hello:0 blocks[1](); // result:Hello:1 blocks[2](); // result:Hello:2&#125; 存取变量 Block将使用到的、作用域附近的变量的值建立一份快照拷贝到栈上。 读取和Block pointer同一个Scope的变量值： 1234567&#123; int outA = 8; int (^myPtr)(int) = ^(int a)&#123; return outA + a;&#125;; //block里面可以读取同一类型的outA的值 int result = myPtr(3); // result is 11 NSLog(@"result=%d", result); &#125; 下面这一段代码就不一样了 1234567&#123; int outA = 8; int (^myPtr)(int) = ^(int a)&#123; return outA + a;&#125;;//block里面可以读取同一类型的outA的值 outA = 5; // 在调用myPtr之前改变outA的值 int result = myPtr(3); // result的值仍然是11，并不是8 NSLog(@"result=%d", result); &#125; 为什么result 的值仍然是11？而不是8呢？事实上，myPtr在其主体中用到的outA这个变量值的时候做了一个copy的动作，把outA的值copy下来，在Block中作为常量使用。所以，之后outA即使换成了新的值，对于myPtr里面copy的值是没有影响的。（类似于深拷贝） 需要注意的是，这里copy的值是变量的值，如果它是一个记忆体的位置（地址），换句话说，就是这个变量是个指针的话，它的值是可以在block里被改变的。(相当于浅拷贝，拷贝的只是一个指针地址，对象地址还是没变的) 123456&#123; NSMutableArray \*mutableArray = [NSMutableArray arrayWithObjects:@"one", @"two", @"three", nil]; int result = ^(int a)&#123;[mutableArray removeLastObject]; return a*a;&#125;(5); NSLog(@"test array :%@", mutableArray); &#125; // 原本mutableArray的值是&#123;@"one",@"two",@"three"&#125;，在block里面被更改mutableArray后，就变成&#123;@"one", @"two"&#125;了。 直接存取static类型的变量 因为全局变量或静态变量在内存中的地址是固定的，Block在读取该变量值的时候是直接从其所在内存读出，获取到的是最新值，而不是在定义时copy的常量。 12345678&#123; static int outA = 8; int (^myPtr)(int) = ^(int a)&#123;return outA + a;&#125;; outA = 5; int result = myPtr(3); //result的值是8，因为outA是static类型的变量 (该变量在全局数据区分配内存,但作用域还是局部作用域) NSLog(@"result=%d", result); &#125; Block Variable类型的变量 在某个变量前面如果加上修饰字“__block”的话（注意，block前面有两个下划线），这个变量就称作block variable。基本类型的Block变量等效于全局变量、或静态变量。即将“外部变量”在栈中的内存地址放到了堆中。 那么在block里面就可以任意修改此变量的值，如下代码： 123456789101112131415&#123; __block int num = 5; NSLog(@"定义前：%p", &amp;num); int (^myPtr)(int) = ^(int a)&#123; NSLog(@"block内部：%p", &amp;num); return num++; &#125;; int (^myPtr2)(int) = ^(int a)&#123; NSLog(@"block内部：%p", &amp;num); return num++; &#125;; int result = myPtr(0); //result的值为5，num的值为6 result = myPtr2(0); //result的值为6，num的值为7 NSLog(@"定义后：%p", &amp;num); NSLog(@"result=%d", result); &#125; 输出（我们看到num进入block之后内存地址其实改变了，也就是block 内部的变量会被 copy 到堆区）： 123452016-09-12 16:24:16.622 test[20146:972930] 定义前：0x7fff5caf0a782016-09-12 16:24:16.623 test[20146:972930] block内部：0x7ff539c0b1a82016-09-12 16:24:16.623 test[20146:972930] block内部：0x7ff539c0b1a82016-09-12 16:24:16.623 test[20146:972930] 定义后：0x7ff539c0b1a82016-09-12 16:24:16.623 test[20146:972930] result=6 weak–strong dance（避免循环引用） 使用方将self或成员变量加入block之前要先将self变为__weak在多线程环境下（block中的weakSelf有可能被析构的情况下），需要先将self转为strong指针，避免在运行到某个关键步骤时self对象被析构。以上两条合起来有个名词叫weak–strong dance 以下是使用weak–strong dance的经典代码 1234567891011__weak __typeof(self)weakSelf = self和__strong __typeof(weakSelf)strongSelf = weakSelf// AFNetworking经典代码__weak __typeof(self)weakSelf = self;AFNetworkReachabilityStatusBlock callback = ^(AFNetworkReachabilityStatus status) &#123; __strong __typeof(weakSelf)strongSelf = weakSelf; strongSelf.networkReachabilityStatus = status; if (strongSelf.networkReachabilityStatusBlock) &#123; strongSelf.networkReachabilityStatusBlock(status); &#125;&#125;; 其中用到了typeof(self)，这里涉及几个知识点： a. typeof、typeof、typeof的区别恩~~他们没有区别，但是这牵扯一段往事，在早期C语言中没有typeof这个关键字，typeof、typeof__是在C语言的扩展关键字的时候出现的。typeof是现代GNU C++的关键字，从Objective-C的根源说，他其实来自于C语言，所以AFNetworking使用了继承自C的关键字。 b.对于老的LLVM编译器上面这句话会编译报错，所以在很早的ARC使用者中流行typeof(&amp;*self)这种写法，原因如下大致说法是老LLVM编译器会将typeof转义为 XXX类名 const strong的strong和前面的__weak关键字对指针的修饰又冲突了，所以加上&amp;对指针的修饰。 第四、五、六行，如果不转成strongSelf而使用weakSelf，后面几句话中，有可能在第四句执行之后self的对象可能被析构掉，然后后面的StausBlock没有执行，导致逻辑错误。 最后第五行，使用前对block判空。 // 以下代码是对weak typeof(self)weakSelf = self// 和strong typeof(weakSelf)strongSelf = weakSelf的宏定义 123456789101112131415161718192021222324252627282930#ifndef weakify #if DEBUG #if __has_feature(objc_arc) #define weakify(object) autoreleasepool&#123;&#125; __weak __typeof__(object) weak##_##object = object; #else #define weakify(object) autoreleasepool&#123;&#125; __block __typeof__(object) block##_##object = object; #endif #else #if __has_feature(objc_arc) #define weakify(object) try&#123;&#125; @finally&#123;&#125; &#123;&#125; __weak __typeof__(object) weak##_##object = object; #else #define weakify(object) try&#123;&#125; @finally&#123;&#125; &#123;&#125; __block __typeof__(object) block##_##object = object; #endif #endif#endif#ifndef strongify #if DEBUG #if __has_feature(objc_arc) #define strongify(object) autoreleasepool&#123;&#125; __typeof__(object) object = weak##_##object; #else #define strongify(object) autoreleasepool&#123;&#125; __typeof__(object) object = block##_##object; #endif #else #if __has_feature(objc_arc) #define strongify(object) try&#123;&#125; @finally&#123;&#125; __typeof__(object) object = weak##_##object; #else #define strongify(object) try&#123;&#125; @finally&#123;&#125; __typeof__(object) object = block##_##object; #endif #endif#endif 12345678910// 使用方法@weakify(self);AFNetworkReachabilityStatusBlock callback = ^(AFNetworkReachabilityStatus status) &#123; @strongify(self) if(!self)return; self.networkReachabilityStatus = status; if (self.networkReachabilityStatusBlock) &#123; self.networkReachabilityStatusBlock(status); &#125;&#125;; 避免循环引用为什么会发生循环引用呢？ 因为对象obj在Block被copy到堆上的时候自动retain了一次。因为Block不知道obj什么时候被释放，为了不在Block使用obj前被释放，Block retain了obj一次，在Block被释放的时候，obj被release一次。retain cycle问题的根源在于Block和obj可能会互相强引用，互相retain对方，这样就导致了retain cycle，最后这个Block和obj就变成了孤岛，谁也释放不了谁。 会发生循环引用例子的demo 使用系统的某些block api 使用系统的某些block api（如UIView的block版本写动画时），是否也考虑引用循环问题？ 答案来自招聘一个靠谱的iOS第39题，个人测试了一下，感觉是有错误的，我下面代码已注释错误的地方。 系统的某些block api中，UIView的block版本写动画时不需要考虑，但也有一些api 需要考虑： 所谓“引用循环”是指双向的强引用，所以那些“单向的强引用”（block 强引用 self ）没有问题，比如这些： 1[UIView animateWithDuration:duration animations:^&#123; [self.superview layoutIfNeeded]; &#125;]; 1[[NSOperationQueue mainQueue] addOperationWithBlock:^&#123; self.someProperty = xyz; &#125;]; 1234567// 会发生循环引用[[NSNotificationCenter defaultCenter] addObserverForName:@"someNotification" object:nil queue:[NSOperationQueue mainQueue] usingBlock:^(NSNotification * notification) &#123; self.someProperty = xyz; &#125;]; 但如果你使用一些参数中可能含有 ivar 的系统 api ，如 GCD 、NSNotificationCenter就要小心一点：比如GCD 内部如果引用了 self，而且 GCD 的其他参数是 ivar，则要考虑到循环引用，比如以下这些： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 不会发生循环引用dispatch_group_async(_operationsGroup, _operationsQueue, ^&#123; [self doSomething]; [self doSomethingElse];&#125; );// 不会发生循环引用__weak __typeof__(self) weakSelf = self;dispatch_group_async(_operationsGroup, _operationsQueue, ^&#123; __typeof__(self) strongSelf = weakSelf; [strongSelf doSomething]; [strongSelf doSomethingElse];&#125; );// 会发生循环引用[[NSNotificationCenter defaultCenter] addObserverForName:@"someNotification" object:nil queue:[NSOperationQueue mainQueue] usingBlock:^(NSNotification * notification) &#123; self.someProperty = xyz; &#125;]; // 会发生循环引用_observer = [[NSNotificationCenter defaultCenter] addObserverForName:@"someNotification" object:nil queue:[NSOperationQueue mainQueue] usingBlock:^(NSNotification * notification) &#123; self.someProperty = xyz; &#125;]; // 不会发生循环引用__weak __typeof__(self) weakSelf = self;[[NSNotificationCenter defaultCenter] addObserverForName:@"someNotification" object:nil queue:nil usingBlock:^(NSNotification *note) &#123; __typeof__(self) strongSelf = weakSelf; strongSelf.someProperty = xyz; &#125;];// 不会发生循环引用__weak __typeof__(self) weakSelf = self;_observer = [[NSNotificationCenter defaultCenter] addObserverForName:@"someNotification" object:nil queue:nil usingBlock:^(NSNotification *note) &#123; __typeof__(self) strongSelf = weakSelf; strongSelf.someProperty = xyz; &#125;]; 参考http://www.cnblogs.com/zhangyang17/p/4667621.html]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>Block</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[购买BanwagonHOST VPS自建Shadowsocks记录]]></title>
    <url>%2F2017%2F07%2F28%2F%E8%B4%AD%E4%B9%B0BanwagonHOST-VPS%E8%87%AA%E5%BB%BAShadowsocks%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[前言 不能畅游墙外没法好好生活和工作 本来手里有着五六个 Shadowsocks 帐号，但体验都不佳，一直也没怎么用，是因为一直使用公司搭建的 Cisco Anyconnect，科学上网后百兆带宽可以满速使用，速度虽快，但是客户端软件默认是全局代理的，虽然可以走IP route list达到和Shadowsocks的PAC同样的作用，但效果慎微，而且IP要自己去填，所以公司IT直接没搞这个route list，因为我们大部分电脑和手机APP都在墙内，这就导致在使用了Cisco Anyconnect后大部分电脑或者手机上的APP网络访问困难，常开VPN还是需要Shadowsocks等可根据 PAC清单自动代理 或者 分应用代理 的一类软件。 主题废话有点多，进入主题。前几日群里的前辈在群里说道自搭的Shadowsocks在使用了Google提出的TCP拥塞控制新算法——BBR之后，解决了以下两个问题： 1. 在有一定丢包率的网络链路上充分利用带宽； 2. 降低网络链路上的 buffer 占用率，从而降低延迟。 正好有时间，大佬说的又激发了我的兴趣，我决定自己也搭一个玩玩，也以备不时之需，经历这一天，也总结了个人认为最省事的路线，以下是步骤记录。 购买VPS在请教了群里的前辈购买何档次的BanwagonHOST VPN之后，购买了19.99$/年的方案，这是购买地址：BanwagonHOST，这里注意两点，第一点：购买时注意买基于KVM的，而不是OpenVZ，KVM是新推出的，只了解了大体不同，想知道具体差异自行Google，一般来说，买新架构就没错了；第二点：在选择Location时，最好选择美国洛杉矶节点Los Angeles，别问为什么，前人经验，至于是QNET还是MCOM，自行谷歌这二者差异，有人汇总对比了这两种方案，不同城市的ping值有高有低，总体来说QNET稍好，所以我购买的是它。 重装系统付款购买成功后，进入当前页面的Services-My Services菜单下，找到你新购买的Product/Service，进入控制面板KiviVM Control Panel，界面很简单，每个功能浏览一下之后开始吧，预装的貌似是Cent OS 6，重装成你想要的系统吧，根据提示来，很easy。我个人比较习惯Ubuntu，所以安装了面板上支持的最新版本的Ubuntu 16.04 x86_64，面板里有一键安装Shadowsocks Server和ShadowsocksR Server功能，但个人不推荐，没啥别的原因，因为感觉不受我控制。装好后会提示你生成了一个随机的ROOT密码，记下来。执行以下步骤： 1.回到你的电脑，用你自己的方式`SSH`登陆到你的`VPS`，我用的`iTerm`，输入`ssh root@your_vps_ip_address -p your_vps_port`（本地要配置好`RSA`），默认密码是前面保存的随机密码。 2.默认ROOT密码不好记，登陆成功后输入`passwd`输入两次新的`ROOT`密码更改密码。 3.`Ubuntu`的话更新下系统，分别执行`apt-get update`和`apt-get upgrade`（不必须但建议） 安装Shadowsocks安装的方式有很多，我独爱个人认为最优的那种，执行以下命令： 123wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocksR.shchmod +x shadowsocksR.sh./shadowsocksR.sh 2&gt;&amp;1 | tee shadowsocksR.log 你也可以用&amp;&amp;连接一次性执行，按提示完成即可。 安装Google bbr一、如果你的VPS是基于KVM的，运行以下命令： 123wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.shchmod +x bbr.sh./bbr.sh 按照提示安装完成，安装完成后，检测是否成功安装： 1sysctl net.ipv4.tcp_available_congestion_control 输出的信息包含bbr就Ok了，一般为net.ipv4.tcp_available_congestion_control = bbr cubic reno 二、如果你不小心购买了基于OpenVZ的VPS，运行这个： 123wget https://raw.githubusercontent.com/kuoruan/shell-scripts/master/ovz-bbr/ovz-bbr-installer.shchmod +x ovz-bbr-installer.sh./ovz-bbr-installer.sh 这个连提示都是中文的，按照提示安装完成即可，安装完成使用看说明，检测是否安装成功： 1ping 10.0.0.2 如果能通，说明 bbr 已经启动,然后检查 iptables 规则: 1234567891011121314iptables -t nat -nLChain PREROUTING (policy ACCEPT)target prot opt source destinationLKL_IN all -- 0.0.0.0/0 0.0.0.0/0 Chain POSTROUTING (policy ACCEPT)target prot opt source destination Chain OUTPUT (policy ACCEPT)target prot opt source destination Chain LKL_IN (1 references)target prot opt source destinationDNAT tcp -- 0.0.0.0/0 0.0.0.0/0 tcp dpt:8989 to:10.0.0.2 里面有相应的端口规则。 使用Shadowsocks使用对应的客户端使用的你的Shadowsocks吧，怎么使用自行搜索。想着就那么几个步骤，还是写了这么多。。。 后记我购买时不小心买成了OpenVZ的，请教了群里的一位前辈之后告诉我联系客服，我便邮件联系官方退款了，购买了新的基于KVM，服务态度非常好，值得点赞。供参考，希望能帮到有需要的朋友。 参考资料搬瓦工(Bandwagonhost)搭建Shadowsocks并优化速度 OpenVZ 平台 Google BBR 一键安装脚本]]></content>
      <categories>
        <category>VPN</category>
      </categories>
      <tags>
        <tag>Mac使用</tag>
        <tag>BanwagonHOST</tag>
        <tag>Shadowsocks</tag>
        <tag>科学上网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Wap APP开发心得]]></title>
    <url>%2F2017%2F05%2F03%2FWap-APP%E5%BC%80%E5%8F%91%E5%BF%83%E5%BE%97%2F</url>
    <content type="text"><![CDATA[经过了一个多月，加班加点，总算完成基本完成了这个Wap APP，可以作为 Version one 面见客户了，感受不多。 MUI 结合 Hbuilder 使用 HTML5+ 开发APP整体来说还是挺顺畅的，虽然文档不完整，但是有开发经验的一眼看过去就知道怎么用了，以后做些不是大型的APP或许会成为我的首选。 算来这也算是我第三次做一个完整的 Wap 类型的 APP了，总体来说这次是最满意的，前面两个都是用的 JSP，很多特性也是依赖其完成的，但这次是纯原生页面，实现了做这个之前感觉很难的问题（至少去年这个时候感觉好难），当然了，这中间少不了 5+ 和 MUI 的功劳，遗憾的是没用上 Vue，忙的时候总是感叹自己时间不够，太多想学的东西没时间学，但些许零碎的空闲时间一有了又无法埋头去学，这样不好啊~ 这个 APP 先发布 iOS 端， 安卓端还有些许适配问题，相信这次之后，对Wap 开发 APP 能够有一个比较深的认识。]]></content>
      <categories>
        <category>APP开发</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>MUI</tag>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MUI webview选项卡 首次只加载首页，点击触发打开页面]]></title>
    <url>%2F2017%2F04%2F15%2FMUI%20webview%E9%80%89%E9%A1%B9%E5%8D%A1%20%E9%A6%96%E6%AC%A1%E5%8F%AA%E5%8A%A0%E8%BD%BD%E9%A6%96%E9%A1%B5%EF%BC%8C%E7%82%B9%E5%87%BB%E8%A7%A6%E5%8F%91%E6%89%93%E5%BC%80%E9%A1%B5%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[MUI 官方的 Demo 的加载 webview 选项卡的逻辑是一次创建全部的选项卡，只默认显示默认创建的页面，这个页面逻辑没必要这么复杂，扩展性也不强，修改一处多处要修改，我做了简单修改，直接修改数据源，就可以达到更改全部的效果。 直接上全部代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;Main&lt;/title&gt; &lt;script type="text/javascript" src="../js/config.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="../js/helper.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="../js/common-head.js"&gt;&lt;/script&gt; &lt;link rel="stylesheet" href="../css/main.css"&gt; &lt;/head&gt; &lt;body&gt; &lt;nav class="mui-bar mui-bar-tab"&gt; &lt;a class="mui-tab-item"&gt; &lt;span class="mui-icon iconfont icon-zuanshi"&gt;&lt;/span&gt; &lt;span class="mui-tab-label"&gt;&lt;/span&gt; &lt;/a&gt; &lt;a class="mui-tab-item"&gt; &lt;span class="mui-icon iconfont icon-8"&gt;&lt;/span&gt; &lt;span class="mui-tab-label"&gt;&lt;/span&gt; &lt;/a&gt; &lt;a class="mui-tab-item"&gt; &lt;span class="mui-icon iconfont icon-zoushi"&gt;&lt;/span&gt; &lt;span class="mui-tab-label"&gt;&lt;/span&gt; &lt;/a&gt; &lt;a class="mui-tab-item"&gt; &lt;span class="mui-icon iconfont icon-yonghuming"&gt;&lt;/span&gt; &lt;span class="mui-tab-label"&gt;&lt;/span&gt; &lt;/a&gt; &lt;/nav&gt; &lt;script type="text/javascript" charset="utf-8"&gt; //mui初始化 mui.init(); var subpage_style = &#123; top: '0px', bottom: '60px' &#125;; var subPages = [&#123; href: 'wonderfulRecommend.html', style: subpage_style, id: config.pageID.wonderfulRecommend, name: "精彩推荐" &#125;, &#123; href: 'lotteryHall.html', style: subpage_style, id: config.pageID.lotteryHall, name: "购彩大厅" &#125;, &#123; href: 'drawTrend-pullRefresh.html', style: subpage_style, id: config.pageID.drawTrend_pullRefresh, name: "开奖走势" &#125;, &#123; href: 'myLottery.html', style: subpage_style, id: config.pageID.myLottery, name: "我的彩票" &#125; ] // 默认显示页面 var defaultPageIndex = 0; mui.ready(function() &#123; // 动态添加 href 和名称 var tabBarItems = document.getElementsByClassName('mui-tab-item'); for(var i = 0; i &lt; tabBarItems.length; i++) &#123; var tabBarItem = tabBarItems[i]; // 设置目标页面 tabBarItem.setAttribute('href', subPages[i].href); // 设置索引 tabBarItem.setAttribute('index', i); // 设置文字标题 var tab_item_label = tabBarItem.querySelector('.mui-tab-label'); tab_item_label.innerHTML = subPages[i].name; // 默认激活的 mui-tab-item if(i == defaultPageIndex) &#123; tabBarItem.classList.add('mui-active'); &#125; &#125; &#125;) //创建子页面，首个选项卡页面显示，其它均隐藏； mui.plusReady(function() &#123; var self = plus.webview.currentWebview(); var defaultPage = plus.webview.create(subPages[defaultPageIndex].href, subPages[defaultPageIndex].id, subPages[defaultPageIndex].style); self.append(defaultPage); &#125;); var activeTab = subPages[defaultPageIndex].id; mui('.mui-bar-tab').on('tap', 'a', function(e) &#123; var targetTab = this.getAttribute('href'); if(targetTab == activeTab) &#123; return; &#125; var index = this.getAttribute('index'); log(index); // 先获取 var destPage = plus.webview.getWebviewById(subPages[index].id); if(destPage) &#123; destPage.show(); &#125; else &#123; var self = plus.webview.currentWebview(); var sub = plus.webview.create(targetTab, subPages[index].id, subPages[index].style); self.append(sub); &#125; //隐藏当前; plus.webview.hide(activeTab); //这里应该是关闭页面，不知道隐藏与关闭区别有多大 //更改当前活跃的选项卡 activeTab = targetTab; &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>MUI</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 主动选择 option]]></title>
    <url>%2F2017%2F04%2F11%2FJavaScript-%E4%B8%BB%E5%8A%A8%E9%80%89%E6%8B%A9-option%2F</url>
    <content type="text"><![CDATA[主动选择 select 中的 option 123456789// 获取默认typevar defaultType = '1';var typeSelect = document.getElementById("type");for(var i = 0; i &lt; typeSelect.options.length; i++) &#123; if(typeSelect.options[i].value === defaultType) &#123; typeSelect.selectedIndex = i; break; &#125;&#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Python脚本半自动化iOS企业版包更新]]></title>
    <url>%2F2017%2F03%2F25%2F%E4%BD%BF%E7%94%A8Python%E8%84%9A%E6%9C%AC%E5%8D%8A%E8%87%AA%E5%8A%A8%E5%8C%96iOS%E4%BC%81%E4%B8%9A%E7%89%88%E5%8C%85%E6%9B%B4%E6%96%B0%2F</url>
    <content type="text"><![CDATA[背景在我之前一篇文章里 iOS企业内部应用分发 讲述了 iOS 企业帐号打包的 ipa 分发，但是如果每次 ipa 更新，重新上传 *.ipa 后还要手动编辑 *.plist 的新的 ipa 的 url 和包的相关信息，这就和打包一样（使用 fastlane），是毫无技术含量但是花时间的事情，作为一个爱偷懒的人，我总是想利用自身所学或者一些工具来代替我做一些重复又没技术含量的事，在本文涉及的这件事里，显然，脚本要派上用场，最终选用了 Python 而没有用 Bash —- 从 ipa 读取相关信息并写入到目的 plist。Python 只是业余，如您有建议或改进，欢迎留言评论指出，感激不尽！ 直接上代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#!/usr/bin/python3#coding:utf-8 import zipfile, plistlib, sys, re, os.path, iosys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8')global plist_root # Info.plistglobal ipa_name # ipa 名称def analyze_ipa_with_plistlib(ipa_path): global plist_root ipa_file = zipfile.ZipFile(ipa_path) plist_path = find_plist_path(ipa_file) plist_data = ipa_file.read(plist_path) plist_root = plistlib.loads(plist_data) print_ipa_info (plist_root) def find_plist_path(zip_file): name_list = zip_file.namelist() pattern = re.compile(r'Payload/[^/]*.app/Info.plist') for path in name_list: m = pattern.match(path) if m is not None: return m.group()def print_ipa_info(plist_root): print ('\n' + '源 ipa 包信息:') CFBundleDisplayName = '' isCFBundleDisplayNameExist = True try: CFBundleDisplayName = plist_root['CFBundleDisplayName'] except: print ('CFBundleDisplayName 不存在，将获取 CFBundleName') isCFBundleDisplayNameExist = False if isCFBundleDisplayNameExist != True: try: CFBundleDisplayName = plist_root['CFBundleName'] except: print ('CFBundleName 不存在') print ('Display Name: %s' % CFBundleDisplayName) print ('Bundle Identifier: %s' % plist_root['CFBundleIdentifier']) print ('Version: %s' % plist_root['CFBundleShortVersionString'] + '\n') def print_plist_info(plist_path, beforeWritten): dict = plistlib.readPlist(plist_path) metadata = dict["items"][0]["metadata"] softwarePackageDict = dict["items"][0]["assets"][0] state = "前" if beforeWritten else "后" print ('写入' + state +'的plist信息') print ('bundle-identifier: %s' % metadata['bundle-identifier']) print ('bundle-version: %s' % metadata['bundle-version']) print ('title: %s' % metadata['title']) print ('ipa url: %s' % softwarePackageDict['url'] + '\n')def writeToPlist(plist_path): global plist_root # 读取app.plist dict = plistlib.readPlist(plist_path) CFBundleDisplayName = '' isCFBundleDisplayNameExist = True try: CFBundleDisplayName = plist_root['CFBundleDisplayName'] except: print ('CFBundleDisplayName 不存在，将获取 CFBundleName') isCFBundleDisplayNameExist = False if isCFBundleDisplayNameExist != True: try: CFBundleDisplayName = plist_root['CFBundleName'] except: print ('CFBundleName 不存在') # 更改包信息 metadata = dict["items"][0]["metadata"] metadata['bundle-identifier'] = plist_root['CFBundleIdentifier'] metadata['bundle-version'] = plist_root['CFBundleShortVersionString'] metadata['title'] = CFBundleDisplayName # 更改ipa地址 softwarePackageDict = dict["items"][0]["assets"][0] # 生成新的 ipa 路径 global ipa_name url = softwarePackageDict['url'] urlComArr = url.split('/') # 删除文件名 urlComArr.pop() # 删除最后一个 urlComArr.append(ipa_name) # 拼接新文件名及扩展名 newUrlComArrStr = '/'.join(urlComArr) # Array to String softwarePackageDict['url'] = newUrlComArrStr plistlib.writePlist(dict, plist_path) # 写入plist if __name__ == '__main__': args = sys.argv[1:] if len(args) != 2: print ('参数错误，用法: python3 config.py /path/to/ipa /path/to/plist') sys.exit(0) global ipa_name ipa_path = args[0] analyze_ipa_with_plistlib(ipa_path) ipa_name = os.path.basename(ipa_path) plist_path = args[1] print_plist_info(plist_path, True) writeToPlist (plist_path) print_plist_info(plist_path, False) 说明每次新打包后，需要更新 plist 文件相关信息，直接在服务器或者本地运行该脚本便可更新 plist 信息，然后覆盖服务器上的同名文件即可（亲手实践过 ipa 分发就没困惑），但运行该脚本的系统应该安装了 Python3，否则无法运行。用法如下，选你的终端执行： 1python3 config.py appName.ipa路径 app.plist路径]]></content>
      <categories>
        <category>Python3</category>
      </categories>
      <tags>
        <tag>iOS打包</tag>
        <tag>iOS企业应用更新</tag>
        <tag>Python3 读写 plist</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原生 JavaScript 判断 DOM 是否包含某个 class]]></title>
    <url>%2F2017%2F03%2F23%2F%E5%8E%9F%E7%94%9F-JavaScript-%E5%88%A4%E6%96%AD-DOM-%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E6%9F%90%E4%B8%AA-class%2F</url>
    <content type="text"><![CDATA[使用 classlist 12345678910111213if (document.body.classList.contains('thatClass')) &#123; // do some stuff&#125;Other uses of classList:document.body.classList.add('thisClass');// $('body').addClass('thisClass');document.body.classList.remove('thatClass');// $('body').removeClass('thatClass');document.body.classList.toggle('anotherClass');// $('body').toggleClass('anotherClass'); 简单封装一下12345678function hasClass(el, cn)&#123; var classes = el.classList; for(var j = 0; j &lt; classes.length; j++)&#123; if(classes[j] == cn)&#123; return true; &#125; &#125;&#125; 支持IE812345function hasClass(el, cls) &#123; var regexp = new RegExp('(\\s|^)' + cls + '(\\s|$)'), target = (typeof el.className === 'undefined') ? window.event.srcElement : el; return target.className.match(regexp);&#125; 浏览器支持 Chrome 8.0 Firefox 3.6 IE 10 Opera 11.50 Safari 5.1]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>DOM</tag>
        <tag>DOM Class</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 企业版应用一键更新]]></title>
    <url>%2F2017%2F03%2F22%2FiOS-%E4%BC%81%E4%B8%9A%E7%89%88%E5%BA%94%E7%94%A8%E4%B8%80%E9%94%AE%E6%9B%B4%E6%96%B0%2F</url>
    <content type="text"><![CDATA[如果后台没有获取版本号的接口，自己就直接从下载企业版应用指向的 plist 文件中获取吧，如果有，就不用这么麻烦还要去下载整个 plist 文件了，直接根据拿到的版本好与本地对比即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#pragma mark -#pragma mark 检查更新- (void)checkForUpdating &#123; // 先清空之前下载的缓存文件 NSString *tmpDirectory = NSTemporaryDirectory(); NSFileManager *fileManager = [NSFileManager defaultManager]; NSError *error; NSArray *cacheFiles = [fileManager contentsOfDirectoryAtPath:tmpDirectory error:&amp;error]; for (NSString *file in cacheFiles) &#123; error = nil; [fileManager removeItemAtPath:[tmpDirectory stringByAppendingPathComponent:file] error:&amp;error]; &#125; // 从服务器下载plist文件 NSURLRequest *downloadRequest = [NSURLRequest requestWithURL:[NSURL URLWithString:CheckUpdatingPlistUrl]]; NSURLSessionConfiguration *sessionConfig = [NSURLSessionConfiguration defaultSessionConfiguration]; NSURLSession *urlSession = [NSURLSession sessionWithConfiguration:sessionConfig delegate:nil delegateQueue:nil]; NSURLSessionDownloadTask *task = [urlSession downloadTaskWithRequest:downloadRequest completionHandler:^(NSURL * _Nullable location, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123; if (error) &#123; WJLog(@"获取下载服务器版本失败:\n%@", error.localizedDescription); &#125; else &#123; NSDictionary *dict = [NSDictionary dictionaryWithContentsOfURL:location]; // 服务器版本号 NSString *serverVersion = dict[@"items"][0][@"metadata"][@"bundle-version"]; // 本地版本号 NSString *localVersion = [[NSBundle mainBundle] infoDictionary][@"CFBundleShortVersionString"]; // 对比版本号，升序 if ([localVersion compare:serverVersion options:NSNumericSearch] == NSOrderedAscending) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; // 先提示安装 FCAlertView *alert = [[FCAlertView alloc] init]; [alert showAlertWithTitle:@"提示" withSubtitle:@"新版本已发布，点击确定开始更新" withCustomImage:nil withDoneButtonTitle:nil andButtons:nil]; alert.hideDoneButton = YES; alert.bounceAnimations = YES; alert.colorScheme = alert.flatOrange; [alert makeAlertTypeCaution]; alert.subTitleColor = [UIColor redColor]; [alert addButton:@"确定" withActionBlock:^&#123; // 模拟器不支持 if (TARGET_IPHONE_SIMULATOR) &#123; WJLog(@"模拟器不支持该操作"); return; &#125; // 真机执行安装 NSURL *url = [NSURL URLWithString:[NSString stringWithFormat:@"itms-services://?action=download-manifest&amp;url=%@", CheckUpdatingPlistUrl]]; [[UIApplication sharedApplication] openURL:url]; // 动画退出App UIWindow *window = [UIApplication sharedApplication].keyWindow; [UIView animateWithDuration:.5f animations:^&#123; window.alpha = 0; CGFloat width = window.bounds.size.width; CGFloat height = window.bounds.size.height; window.frame = CGRectMake(width * 0.5, height * 0.5, 0, 0); &#125; completion:^(BOOL finished) &#123; exit(0); &#125;]; &#125;]; [alert addButton:@"下次再说" withActionBlock:nil]; &#125;); &#125; &#125; &#125;]; [task resume];&#125; 那个 FCAlertView 没有可以用原生的，比如： 123456789101112131415161718192021222324252627282930313233343536// 对比版本号，升序if ([localVersion compare:serverVersion options:NSNumericSearch] == NSOrderedAscending) &#123; __weak typeof(self) weakSelf = self; dispatch_async(dispatch_get_main_queue(), ^&#123; // 先提示安装 UIAlertController *alertVc = [UIAlertController alertControllerWithTitle:@"提示" message:@"新版本已发布，点击确定开始更新" preferredStyle:UIAlertControllerStyleAlert]; UIAlertAction *confirmAct = [UIAlertAction actionWithTitle:@"确定" style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) &#123; // 模拟器不支持 if (TARGET_IPHONE_SIMULATOR) &#123; WJLog(@"模拟器不支持该操作"); return; &#125; // 真机执行安装 NSURL *url = [NSURL URLWithString:[NSString stringWithFormat:@"itms-services://?action=download-manifest&amp;url=%@", CheckUpdatingPlistUrl]]; [[UIApplication sharedApplication] openURL:url]; // 动画退出App UIWindow *window = [UIApplication sharedApplication].keyWindow; [UIView animateWithDuration:.5f animations:^&#123; window.alpha = 0; CGFloat width = window.bounds.size.width; CGFloat height = window.bounds.size.height; window.frame = CGRectMake(width * 0.5, height * 0.5, 0, 0); &#125; completion:^(BOOL finished) &#123; exit(0); &#125;]; &#125;]; // 取消 UIAlertAction *cancelAct = [UIAlertAction actionWithTitle:@"下次再说" style:UIAlertActionStyleDefault handler:nil]; [alertVc addAction:confirmAct]; [alertVc addAction:cancelAct]; [weakSelf.window.rootViewController presentViewController:alertVc animated:YES completion:nil]; &#125;);&#125;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS 应用更新</tag>
        <tag>企业版应用更新</tag>
        <tag>打包</tag>
        <tag>发布</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为 NexT 主题添加球型标签云]]></title>
    <url>%2F2017%2F03%2F19%2F%E4%B8%BA-NexT-%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E7%90%83%E5%BD%A2%E6%A0%87%E7%AD%BE%E4%BA%91%2F</url>
    <content type="text"><![CDATA[确定你已开启标签功能参考 NexT 配置文档 添加标签页面 ，开启标签功能。 了解球形标签云插件了解球形标签云 javascript 插件，点击这里 下载插件下载 js 插件 tagcanvas.js 放入对应目录将下载的 tagcanvas.js 放入主题目录 themes/NexT/source/js/custom/tagcanvas.js，custom 为新建文件夹。 新建标签云文件，引用 js在 themes/NexT/layout/_partials 下建一个 plugin 文件夹，在该目录下 touch 一个名为 tagcanvas.swig 的文件，并写入如下内容： 1234567891011121314151617181920212223242526272829303132333435363738&lt;div class="tags" id="myTags"&gt; &lt;canvas width="350" height="350" id="my3DTags"&gt; &lt;p&gt;Anything in here will be replaced on browsers that support the canvas element&lt;/p&gt; &lt;/canvas&gt;&lt;/div&gt;&lt;div class="tags" id="tags"&gt; &lt;ul style="display: none"&gt; &#123;&#123; tagcloud(&#123; min_font: 16, max_font: 35, amount: 999, color: true, start_color: 'red', end_color: 'red', &#125;) &#125;&#125; &lt;/ul&gt;&lt;/div&gt;&lt;script type="text/javascript" src="/js/custom/tagcanvas.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" &gt; window.onload = function() &#123; try &#123; TagCanvas.Start('my3DTags','tags',&#123; textFont: 'Georgia,Optima', textColour: null, outlineColour: 'black', weight: true, reverse: true, depth: 0.8, maxSpeed: 0.05, bgRadius: 1, freezeDecel: true &#125;); &#125; catch(e) &#123; // something went wrong, hide the canvas container document.getElementById('myTags').style.display = 'none'; &#125; &#125;;&lt;/script&gt; 使用 tagcanvas.swig在 themes/NexT/layout/page.swig 中作如下修改： 替换红框中原来位置的 div 标签为如下： 12&#123;# tagcanvas plugin 球型云标签 #&#125;&#123;% include '_partials/plugin/tagcanvas.swig' %&#125;]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>标签</tag>
        <tag>主题</tag>
        <tag>球形标签云</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac 彻底卸载 MYSQL 解决疑难杂症]]></title>
    <url>%2F2017%2F03%2F18%2FMac-%E5%BD%BB%E5%BA%95%E5%8D%B8%E8%BD%BD-MYSQL-%E8%A7%A3%E5%86%B3%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87%2F</url>
    <content type="text"><![CDATA[备份数据库备份看个人了，可以用软件如 Navicat 导出，也可以用 mysqldump 命令导出。 kill mysql相关进程终端运行 ps -ax | grep mysql 查看 mysql 相关进程， 有的话 kill 卸载 Homebrew 安装的mysql卸载全部以前用 brew 安装 的 mysql，先 brew list 查看安装的 mysql 版本，假如列出了 `mysql@5.5， 则运行brew uninstall mysql@5.5，卸载完后执行brew cleanup`。 移除残留文件删除与 mysql 相关的文件 12345sudo rm /usr/local/mysql;sudo rm -rf /usr/local/var/mysql;sudo rm -rf /usr/local/mysql*;sudo rm -rf /Library/StartupItems/MySQLCOM;sudo rm -rf /Library/PreferencePanes/My* 移除残留自动登陆项移除自动登陆项，如果你安装过 DMG 版本的 mysql，则把以下命令中的 LaunchAgents 替换为 LaunchDaemons 再执行一次 1launchctl unload -w ~/Library/LaunchAgents/homebrew.mxcl.mysql.plist unload 之后再删除该文件， 123sudo rm ~/Library/LaunchAgents/homebrew.mxcl.mysql.plist或sudo rm ~/Library/LaunchDaemons/homebrew.mxcl.mysql.plist 移除残留配置subl /etc/hostconfig ` 后输入 Remove the line MYSQLCOM=-YES- ` 移除残留偏好设置1234rm -rf ~/Library/PreferencePanes/My*;sudo rm -rf /Library/Receipts/mysql*;sudo rm -rf /Library/Receipts/MySQL*;sudo rm -rf /private/var/db/receipts/*mysql* 重启电脑，重新安装 mysql建议使用 Homebrew 安装 12brew search mysqlbrew install 你要的版本 启动 mysql1mysql.server start 如果报 commond not found，则在 ~/.zshrc 或者 ~/.bashrc 中加入以下两行（注意替换mysql路径）： 12export MYSQL=/usr/local/Cellar/mysql@5.6/5.6.35/support-filesexport PATH=$MYSQL:$PATH]]></content>
      <categories>
        <category>系统疑难</category>
      </categories>
      <tags>
        <tag>MYSQL</tag>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 中为多说添加最近访客]]></title>
    <url>%2F2017%2F03%2F17%2FHexo-%E4%B8%AD%E4%B8%BA%E5%A4%9A%E8%AF%B4%E6%B7%BB%E5%8A%A0%E6%9C%80%E8%BF%91%E8%AE%BF%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[添加自定义样式1. 多说后台添加到多说后台管理-&gt;设置-&gt;基本设置-&gt;自定义css中添加如下css样式： 1234567891011121314151617181920212223242526272829303132333435363738#ds-reset .ds-avatar img,#ds-recent-visitors .ds-avatar img &#123;width: 54px;height: 54px; /*设置图像的长和宽，这里要根据自己的评论框情况更改*/border-radius: 27px; /*设置图像圆角效果,在这里我直接设置了超过width/2的像素，即为圆形了*/-webkit-border-radius: 27px; /*圆角效果：兼容webkit浏览器*/-moz-border-radius: 27px;box-shadow: inset 0 -1px 0 #3333sf; /*设置图像阴影效果*/-webkit-box-shadow: inset 0 -1px 0 #3333sf;-webkit-transition: 0.4s;-webkit-transition: -webkit-transform 0.4s ease-out;transition: transform 0.4s ease-out; /*变化时间设置为0.4秒(变化动作即为下面的图像旋转360读）*/-moz-transition: -moz-transform 0.4s ease-out;&#125;#ds-reset .ds-avatar img:hover,#ds-recent-visitors .ds-avatar img:hover &#123;/*设置鼠标悬浮在头像时的CSS样式*/ box-shadow: 0 0 10px #fff;rgba(255, 255, 255, .6), inset 0 0 20px rgba(255, 255, 255, 1);-webkit-box-shadow: 0 0 10px #fff;rgba(255, 255, 255, .6), inset 0 0 20px rgba(255, 255, 255, 1);transform: rotateZ(360deg); /*图像旋转360度*/-webkit-transform: rotateZ(360deg);-moz-transform: rotateZ(360deg);&#125;/*#ds-thread #ds-reset .ds-textarea-wrapper textarea &#123;background: url(http://www.wuxubj.cn/images/duoshuo_bkground.jpg) right no-repeat;&#125;*/#ds-recent-visitors .ds-avatar &#123;float: left&#125;/*隐藏多说底部版权*/#ds-thread #ds-reset .ds-powered-by &#123;display: none;&#125; 2. Hexo 本地添加自定义CSS（推荐）打开 /themes/NexT/layout/_custom/header.swig或者 themes/NexT/source/css/_custom/custom.styl输入以下内容（custom.styl 可省略 style 标签）: 1234567891011121314151617181920212223242526272829303132333435363738&lt;style type="text/css"&gt;#ds-reset .ds-avatar img,#ds-recent-visitors .ds-avatar img &#123;width: 54px;height: 54px; /*设置图像的长和宽，这里要根据自己的评论框情况更改*/border-radius: 27px; /*设置图像圆角效果,在这里我直接设置了超过width/2的像素，即为圆形了*/-webkit-border-radius: 27px; /*圆角效果：兼容webkit浏览器*/-moz-border-radius: 27px;box-shadow: inset 0 -1px 0 #3333sf; /*设置图像阴影效果*/-webkit-box-shadow: inset 0 -1px 0 #3333sf;-webkit-transition: 0.4s;-webkit-transition: -webkit-transform 0.4s ease-out;transition: transform 0.4s ease-out; /*变化时间设置为0.4秒(变化动作即为下面的图像旋转360读）*/-moz-transition: -moz-transform 0.4s ease-out;&#125;#ds-reset .ds-avatar img:hover,#ds-recent-visitors .ds-avatar img:hover &#123;/*设置鼠标悬浮在头像时的CSS样式*/ box-shadow: 0 0 10px #fff;rgba(255, 255, 255, .6), inset 0 0 20px rgba(255, 255, 255, 1);-webkit-box-shadow: 0 0 10px #fff;rgba(255, 255, 255, .6), inset 0 0 20px rgba(255, 255, 255, 1);transform: rotateZ(360deg); /*图像旋转360度*/-webkit-transform: rotateZ(360deg);-moz-transform: rotateZ(360deg);&#125;/*#ds-thread #ds-reset .ds-textarea-wrapper textarea &#123;background: url(http://www.wuxubj.cn/images/duoshuo_bkground.jpg) right no-repeat;&#125;*/#ds-recent-visitors .ds-avatar &#123;float: left&#125;/*隐藏多说底部版权*/#ds-thread #ds-reset .ds-powered-by &#123;display: none;&#125;&lt;/style&gt; 添加 dom在需要添加最近访客的网页对应的 markdown 文件中添加如下代码： 123&gt; 最近访客&lt;div class="ds-recent-visitors" data-num-items="28" data-avatar-size="42" id="ds-recent-visitors"&gt;&lt;/div&gt;&lt;br/&gt; 添加最近访客 dom 到模板文件中（此做法更新抛弃，采用下面做法）在博客站点根目录的 scaffolds/*.md 模板文件中添加以上 dom 代码，以后新建 [layout] 便无需手动拷贝。 编辑主题配置文件在主题配置文件 _config.yml 中添加： 12# 最近访客duoshuo_recent_visit: true 修改 reward.swi 文件文件路径: 1/themes/NexT/layout/_macro/reward.swi 在顶部添加内容：123456789&#123;% if theme.duoshuo_recent_visit %&#125;&lt;blockquote&gt;&lt;p&gt;最近访客&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;div class="ds-recent-visitors" data-num-items="28" data-avatar-size="42" id="ds-recent-visitors"&gt;&lt;/div&gt;&lt;br&gt;&lt;br&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;&#123;% endif %&#125; 保存，重启 Hexo 即可]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态加载javascript]]></title>
    <url>%2F2017%2F03%2F09%2F%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BDjavascript%2F</url>
    <content type="text"><![CDATA[使用以下函数 12345678910111213141516171819var dynamicLoading = &#123; meta : function()&#123; document.write('&lt;meta charset="utf-8"&gt;'); document.write('&lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;'); document.write('&lt;meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1, maximum-scale=1, minimum-scale=1, shrink-to-fit=no"&gt;'); &#125;, css: function(path)&#123; if(!path || path.length === 0)&#123; throw new Error('argument "path" is required!'); &#125; document.write('&lt;link rel="stylesheet" type="text/css" href="' + path + '"&gt;'); &#125;, js: function(path, charset)&#123; if(!path || path.length === 0)&#123; throw new Error('argument "path" is required!'); &#125; document.write('&lt;script type="text/javascript" src="' + path + '"&gt;&lt;/script&gt;'); &#125;&#125;; 12345678910111213141516171819202122232425262728// 另外一个独立的动态加载js的函数function loadJs(jsurl, head, callback) &#123; var script = document.createElement(script); script.setAttribute("type", "text/javascript"); if(callback) &#123; if(script.readyState) &#123; //IE script.onreadystatechange = function() &#123; if(script.readyState == "loaded" || script.readyState == "complete") &#123; script.onreadystatechange = null; callback(); &#125; &#125;; &#125; else &#123; //Others script.onload = function() &#123; callback(); &#125;; &#125; &#125; script.setAttribute("src", jsurl); if(head) document.getElementsByTagName(head)[0].appendChild(script); else &#123; document.body.appendChild(script); &#125;&#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用 dumpdecrypted 砸壳]]></title>
    <url>%2F2017%2F02%2F08%2F%E5%88%A9%E7%94%A8dumpdecrypted%E7%A0%B8%E5%A3%B3%2F</url>
    <content type="text"><![CDATA[1、编译生成 dumpdecrypted.dylib 2、给生成的 dumpdecrypted.dylib 签名 3、ssh到手机，ps aux | grep 目标APP查看APP安装目录 4、（可忽略这步）cycript -p 目标 APP，执行 1[[NSFileManager defaultManager] URLsForDirectory:NSDocumentDirectory inDomains:NSUserDomainMask][0] 查看沙盒目录 5、将 dumpdecrypted.dylib拷贝 /var/tmp，进入 /var/tmp 6、将 dumpdecrypted.dylib 拷贝到沙盒目录，进入沙盒目录，执行 1DYLD_INSERT_LIBRARIES=dumpdecrypted.dylib /var/containers/Bundle/Application/0B8A6E0F-9D64-4EF4-97D2-D3A508FC3574/APP.app/APP 7、得到目标 APP.decrypted就是二进制文件]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>逆向</tag>
        <tag>iOS安全</tag>
        <tag>破解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[security 使用]]></title>
    <url>%2F2017%2F02%2F08%2Fsecurity%20%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[概要这里记录Mac下security相关使用，想起来就补充。 查看可用签名1security find-identity -v -p codesigning 签名1codesign --force --verify --verbose --sign "iPhone Developer: 396736694@qq.com (Z4965JH2C8)” 目标包 查看描述文件信息1security cms -D -i xxx.mobileprovision 查看 WIFI 密码1security find-generic-password -ga "WIFI_name" | grep "password:"]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>打包</tag>
        <tag>iOS签名</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS企业内部应用分发]]></title>
    <url>%2F2017%2F01%2F11%2FiOS%E4%BC%81%E4%B8%9A%E5%86%85%E9%83%A8%E5%BA%94%E7%94%A8%E5%88%86%E5%8F%91%2F</url>
    <content type="text"><![CDATA[iOS 支持以无线方式安装企业内部应用，而无需使用 iTunes 或 App Store。 格式要求应用格式要求:.ipa，并且使用企业内部预置描述文件进行构建，即经企业证书签名。 无线安装要求： XML 清单文件（一个 plist 配置文件） 可让设备访问 Apple iTunes 服务器的网络配置（设备要能连接互联网，因为要校验） 对于 iOS 7.1 或更高版本， plist 文件和 ipa 文件需要放在 HTTPS 的服务器上为了安装应用，用户使用特殊的 URL 前缀从您的网站上下载plist清单文件，您可以分发该特殊前缀的URL给用户或者放置于可供用户访问的互联网上。 准备分发企业内部应用: 创建应用的归档，格式为 *.ipa 格式，并且归档中包括企业内部预置描述文件，且使用分发证书签名； 无线清单文件，您可以使用支持编辑 plist 文档的编辑器编写或者直接修改下面提供的范例，各字段意义范例中会写明； 可直接供内连网或互联网访问的 HTTPS 服务器。 关于无线 plist 清单文件单文件是一个 XML plist 文件，可供 Apple 设备用来从您的 Web 服务器上查找、下载和安装应用。 以下栏是必填项： URL：应用 (*.ipa) 文件的完全限定 HTTPS URL display-image：57 x 57 px 的 PNG 图像，在下载和安装过程中显示，图片的 Web URL full-size-image：512 x 512 px 的 PNG 图像，表示 iTunes 中相应的应用，图片的 Web URL bundle-identifier：应用的包标识符，与 Xcode 项目中指定的完全一样 bundle-version：应用的包版本，在 Xcode 项目中指定 title：下载和安装过程中显示的应用的名称样本清单文件还包含可选字段。例如，如果应用文件太大，并且想要在执行错误检验（TCP 通信通常会执行该检验）的基础上确保下载的完整性，可以使用 MD5 校验，使用见范例。您也可以在一个plist文件中配置多个应用，一个 item 作为一项。 构建网站将这些项目上传到网站上可供已认证的用户访问的区域： 应用 (.ipa) 文件 清单 (.plist) 文件您的网站可以是链接到清单文件的单个页面。用户轻点 Web 链接后会下载清单文件，并触发下载和安装。以下是示例链接：&lt;a href="itms-services://?action=download-manifest&amp;url=https://example.com/manifest.plist"&gt;安装应用&lt;/a&gt; 虽然 URL 的协议部分是“itms-services”，但 iTunes Store 并不参与此过程。 配置服务器 MIME 类型（一般不用配置）您可能需要配置 Web 服务器，让清单文件和应用文件可正确传输。 对于 Server 应用，请将 MIME 类型添加到网页服务的 MIME 类型设置： application/octet-stream ipa text/xml plist 对于微软的互联网信息服务器 (IIS)，请使用 IIS Manager 在服务器的“属性”页面中添加 MIME 类型： .ipa application/octet-stream .plist text/xml 无线 iOS 应用分发故障诊断如果无线应用分发失败，并显示“无法下载”信息： 请确定应用已正确进行签名。测试方法是使用 Apple Configurator 2 将它安装到设备上，然后查看是否发生错误。 请确定清单文件的链接是否正确，清单文件是否可供网络用户访问。 请确定 .ipa 文件（在清单文件中）的 URL 是否正确，并且该 .ipa 文件是否可供网络用户通过 HTTPS 访问。 网络配置要求如果设备连接到内网，那么您必须允许它访问以下站点： https://ax.init.itunes.apple.com 使用蜂窝移动网络下载应用时，设备会限制其当前文件大小。如果无法访问此站点，安装可能会失败。 https://ppq.apple.com 设备会联系此网站，检查用来给预置描述文件签名的分发证书状态。 应用更新 程序内检查 Server 端ipa版本和本地版本，比较是否已发布新版本，并提示用户更新。 如果用户想保留旧版本数据，请告知其不要卸载旧版本，并且新旧版本 bundle-identifier 相同。 更新方法：直接使用应用内部的openURL 方法，打开的是plist文件的web url 带 itms-services描述 链接（真机）。 证书验证 用户首次打开应用时，系统会通过联系 Apple 的 OCSP 服务器来验证分发证书。如果证书已撤销，应用将不会启动。为了验证状态，设备必须能够访问 ocsp.apple.com。 OCSP 响应会在设备上缓存一段时间（由 OCSP 服务器指定），当前为 3 到 7 天之间。在重新启动设备和缓存的响应过期之前，将不会再次检查证书的有效性。如果当时收到撤销命令，系统将阻止应用运行。【警告】撤销分发证书会导致使用该证书签名的所有应用失效。只有万不得已时才应撤销证书，比如确定专用密钥已丢失或确信证书已遭破解。 示例示例 iOS 应用 plist 清单文件，可复制，保存为plist格式，也可从 这里 下载 &lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt; &lt;plist version="1.0"&gt; &lt;dict&gt; &lt;key&gt;items&lt;/key&gt; &lt;array&gt; &lt;dict&gt; &lt;key&gt;assets&lt;/key&gt; &lt;array&gt; &lt;dict&gt; &lt;key&gt;kind&lt;/key&gt; &lt;string&gt;software-package&lt;/string&gt; &lt;key&gt;md5-size&lt;/key&gt; &lt;integer&gt;10485760&lt;/integer&gt; &lt;key&gt;md5s&lt;/key&gt; &lt;array&gt; &lt;string&gt;41fa64bb7a7cae5a46bfb45821ac8bba&lt;/string&gt; &lt;string&gt;51fa64bb7a7cae5a46bfb45821ac8bba&lt;/string&gt; &lt;/array&gt; &lt;key&gt;url&lt;/key&gt; &lt;string&gt;https://www.example.com/apps/foo.ipa&lt;/string&gt; &lt;/dict&gt; &lt;dict&gt; &lt;key&gt;kind&lt;/key&gt; &lt;string&gt;display-image&lt;/string&gt; &lt;key&gt;needs-shine&lt;/key&gt; &lt;true/&gt; &lt;key&gt;url&lt;/key&gt; &lt;string&gt;https://www.example.com/image.57x57.png&lt;/string&gt; &lt;/dict&gt; &lt;dict&gt; &lt;key&gt;kind&lt;/key&gt; &lt;string&gt;full-size-image&lt;/string&gt; &lt;key&gt;md5&lt;/key&gt; &lt;string&gt;61fa64bb7a7cae5a46bfb45821ac8bba&lt;/string&gt; &lt;key&gt;needs-shine&lt;/key&gt; &lt;true/&gt; &lt;key&gt;url&lt;/key&gt;&lt;string&gt;https://www.example.com/image.512x512.jpg&lt;/string&gt; &lt;/dict&gt; &lt;/array&gt; &lt;key&gt;metadata&lt;/key&gt; &lt;dict&gt; &lt;key&gt;bundle-identifier&lt;/key&gt; &lt;string&gt;com.example.fooapp&lt;/string&gt; &lt;key&gt;bundle-version&lt;/key&gt; &lt;string&gt;1.0&lt;/string&gt; &lt;key&gt;kind&lt;/key&gt; &lt;string&gt;software&lt;/string&gt; &lt;key&gt;subtitle&lt;/key&gt; &lt;string&gt;Apple&lt;/string&gt; &lt;key&gt;title&lt;/key&gt; &lt;string&gt;Example Corporate App&lt;/string&gt; &lt;/dict&gt; &lt;/dict&gt; &lt;/array&gt; &lt;/dict&gt; &lt;/plist&gt; 简单配置示例作为包体积较小的应用，如以下简单配置即可，从这里下载 &lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt; &lt;plist version="1.0"&gt; &lt;dict&gt; &lt;key&gt;items&lt;/key&gt; &lt;array&gt; &lt;dict&gt; &lt;key&gt;assets&lt;/key&gt; &lt;array&gt; &lt;dict&gt; &lt;key&gt;kind&lt;/key&gt; &lt;string&gt;software-package&lt;/string&gt; &lt;key&gt;url&lt;/key&gt; &lt;string&gt;https://yourwebsite/appName.ipa&lt;/string&gt; &lt;/dict&gt; &lt;dict&gt; &lt;key&gt;kind&lt;/key&gt; &lt;string&gt;full-size-image&lt;/string&gt; &lt;key&gt;needs-shine&lt;/key&gt; &lt;true/&gt; &lt;key&gt;url&lt;/key&gt; &lt;string&gt;https://yourwebsite/app_icon_full_size.png&lt;/string&gt; &lt;/dict&gt; &lt;dict&gt; &lt;key&gt;kind&lt;/key&gt; &lt;string&gt;display-image&lt;/string&gt; &lt;key&gt;needs-shine&lt;/key&gt; &lt;true/&gt; &lt;key&gt;url&lt;/key&gt; &lt;string&gt;https://yourwebsite/app_icon_download.png&lt;/string&gt; &lt;/dict&gt; &lt;/array&gt; &lt;key&gt;metadata&lt;/key&gt; &lt;dict&gt; &lt;key&gt;bundle-identifier&lt;/key&gt; &lt;string&gt; your app bundle id &lt;/string&gt; &lt;key&gt;bundle-version&lt;/key&gt; &lt;string&gt;shortVersion&lt;/string&gt; &lt;key&gt;kind&lt;/key&gt; &lt;string&gt;software&lt;/string&gt; &lt;key&gt;subtitle&lt;/key&gt; &lt;string&gt;欢迎使用&lt;/string&gt; &lt;key&gt;title&lt;/key&gt; &lt;string&gt; app 名称&lt;/string&gt; &lt;/dict&gt; &lt;/dict&gt; &lt;/array&gt; &lt;/dict&gt; &lt;/plist&gt; Author: CoderJay 如需转载，请注明出处]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>打包</tag>
        <tag>发布</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac查看CPU具体型号]]></title>
    <url>%2F2016%2F11%2F16%2FMac%E6%9F%A5%E7%9C%8BCPU%E5%85%B7%E4%BD%93%E5%9E%8B%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[查看 CPU 型号1sysctl machdep.cpu.brand_string 查看系统相关信息12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455➜ system_profiler -listDataTypesAvailable Datatypes:SPParallelATADataTypeSPUniversalAccessDataTypeSPSecureElementDataTypeSPApplicationsDataTypeSPAudioDataTypeSPBluetoothDataTypeSPCameraDataTypeSPCardReaderDataTypeSPComponentDataTypeSPiBridgeDataTypeSPDeveloperToolsDataTypeSPDiagnosticsDataTypeSPDisabledSoftwareDataTypeSPDiscBurningDataTypeSPEthernetDataTypeSPExtensionsDataTypeSPFibreChannelDataTypeSPFireWireDataTypeSPFirewallDataTypeSPFontsDataTypeSPFrameworksDataTypeSPDisplaysDataTypeSPHardwareDataTypeSPHardwareRAIDDataTypeSPInstallHistoryDataTypeSPLegacySoftwareDataTypeSPNetworkLocationDataTypeSPLogsDataTypeSPManagedClientDataTypeSPMemoryDataTypeSPNVMeDataTypeSPNetworkDataTypeSPPCIDataTypeSPParallelSCSIDataTypeSPPowerDataTypeSPPrefPaneDataTypeSPPrintersSoftwareDataTypeSPPrintersDataTypeSPConfigurationProfileDataTypeSPRawCameraDataTypeSPSASDataTypeSPSerialATADataTypeSPSPIDataTypeSPSmartCardsDataTypeSPSoftwareDataTypeSPStartupItemDataTypeSPStorageDataTypeSPSyncServicesDataTypeSPThunderboltDataTypeSPUSBDataTypeSPNetworkVolumeDataTypeSPWWANDataTypeSPAirPortDataType 查看对应信息，比如查看硬件概述123456789101112131415161718➜ system_profiler SPHardwareDataTypeHardware: Hardware Overview: Model Name: MacBook Air Model Identifier: MacBookAir7,2 Processor Name: Intel Core i7 Processor Speed: 2.2 GHz Number of Processors: 1 Total Number of Cores: 2 L2 Cache (per Core): 256 KB L3 Cache: 4 MB Memory: 8 GB Boot ROM Version: 184.0.0.0.0 SMC Version (system): 2.27f2 Serial Number (system): FVFW5047J1WV Hardware UUID: 61763F2C-47F2-580E-9E02-409384172D75 查看有线网络信息123456789101112131415161718192021222324➜ system_profiler SPEthernetDataTypeEthernet Cards: USB 10/100 LAN: Type: USB BSD name: en3 Kext name: AppleUSBECM.kext Location: /System/Library/Extensions/AppleUSBECM.kext Version: 5.0.0 MAC Address: 9c:eb:e8:b0:a6:ff Product ID: 17 Vendor ID: 10007 USB: Type: USB BSD name: en4 Kext name: AppleUSBNCM.kext Location: /System/Library/Extensions/AppleUSBNCM.kext Version: 5.0.0 MAC Address: de:56:e7:af:d6:89 Product ID: 4776 Vendor ID: 1452 查看应用信息1system_profiler SPApplicationsDataType 生成 XML 报告1➜ system_profiler -xml SPEthernetDataType SPFirewallDataType &gt; ~/Desktop/system_profile-EthernetFirewall.xml 更多使用查看帮助1➜ system_profiler -h]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Mac使用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 开发中常见误操作及个人认为的最佳解决办法]]></title>
    <url>%2F2016%2F08%2F03%2Fgit-%E5%BC%80%E5%8F%91%E4%B8%AD%E5%B8%B8%E8%A7%81%E8%AF%AF%E6%93%8D%E4%BD%9C%E5%8F%8A%E4%B8%AA%E4%BA%BA%E8%AE%A4%E4%B8%BA%E7%9A%84%E6%9C%80%E4%BD%B3%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[概要这篇文章记录的是在使用git过程中遇到的问题及我的解决办法，普通的使用这里不会记录，遇到了更多问题之后我会来更新这篇文章。 commit时选错了对应文件提交记录一般只做一件事情就好，可以的话，适当的细分是很有必要的，当然对应的关联的改动文件也要正确，但是如果是一次改动中动了多个文件，但是改了两个需求，又想分两次提交，当然是多选该功能改动的文件然后写commit log，但是如果不小心选错了或者多选择了不相关文件并已经commit了的话，可是使用git reset来恢复，先git log复制最新一次的上一次的commit id，执行git reset --soft desc_commit_id，此时代码便会恢复到你刚刚提交之前，改动都还在但是错误的 commit log 不见了，这是强迫症最舒服的地方，此时你可以重新选择文件再次提交，干净的commit log是不是很舒服？ 注意git reset是有点危险的操作，在不确定是否一定抛弃已有改动，不要使用git reset --hard，注意这里的参数，--hard和--soft，前者会恢复到当次 commit id并且discard了commit id之前所有的commit id的改动，如果远程端没有记录，那么你将丢失未保存的所有改动，切记切记；而后者只会删除你不需要的commit log，但是该commit id之前所有的commit id的改动都还在，只是’commit log’被清了，此时你可以重新写log，如果已经推送到了远程，发现很及时的话，先git pull最新代码，确保没有同事新提交过代码，直接用reset之后的记录覆盖远端，如果有同事提交了，可以git reset --soft之后cheery pick该记录再覆盖远端。 慢慢细读并跟着走的话应该可以看懂了，这里还是实例记录下： 123456789101112131415161718192021222324252627282930313233343536373839404142☁ Desktop mkdir example☁ Desktop cd example☁ example git initInitialized empty Git repository in /Users/VanJay/Desktop/example/.git/☁ example [master] git add .☁ example [master] git clone https://github.com/dracula/xcode.git☁ example [master] git commit -m "Initial commit"On branch masterInitial commitnothing to commit☁ example [master] git logfatal: your current branch 'master' does not have any commits yet☁ example [master] touch a.file☁ example [master] ⚡ git add .☁ example [master] ⚡ git commit -m "Added a.file"[master (root-commit) fa2ed5d] Added a.file 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 a.file☁ example [master] git log☁ example [master] touch b.file☁ example [master] ⚡ touch c.file☁ example [master] ⚡ git add .☁ example [master] ⚡ git commit helperror: pathspec 'help' did not match any file(s) known to git.☁ example [master] ⚡ git commit --help☁ example [master] ⚡ git commit -m "Added b.file"[master 0a03cd8] Added b.file 2 files changed, 0 insertions(+), 0 deletions(-) create mode 100644 b.file create mode 100644 c.file☁ example [master] git log☁ example [master] git reset --soft fa2ed5d01756b3b63b00488418c1a73eb30c4d66☁ example [master] ⚡ git statusOn branch masterChanges to be committed: (use "git reset HEAD &lt;file&gt;..." to unstage) new file: b.file new file: c.file☁ example [master] ⚡ git log 可以看到在提交了 b.file和c.file之后恢复了之前的状态，git log查看只有一次commit log了，这个时候可以重新写log提交。]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OC用AFN做Soap请求webService]]></title>
    <url>%2F2016%2F01%2F10%2FOC%E7%94%A8AFN%E5%81%9ASoap%E8%AF%B7%E6%B1%82webService%2F</url>
    <content type="text"><![CDATA[前言好吧，标题有点拗口。我平时一般不发帖子，因为感觉太花时间了，还是喜欢宅着研究技术。但这个帖子网上资料还是没有很详细的，周末了明天休息，所以现在写下来总结一下，也希望能帮助有这方面需求的开发者朋友，如果错误之处还请谅解，欢迎指出。排版大家就不要在意了，我也不清楚这个支不支持markdown，就直接手动简单排一下。 进入主题，最近公司做一个新项目，后台是webService，要做iOS版本的客户端，由于我以前不怎么了解这方面，所以云里雾里得摸索了两天，因为后台人员也不清楚我具体要传什么给他，所以。。。。我就两边跑。。。。最终我确定问题还是在于后端，今天上午完美解决，对webService和WSDL以及CXF有了个大概的了解。 我就不做过多的概念介绍了，我很懒不愿复制粘贴，只要说一些细节让大家少走弯路就可以。 在继续往下之前你需要先去了解一些概念：SOAP、WSDL、CXF，和他们之间的关系。这里我觉得这个帖子比较好，推荐一下，Web Service笔记（三）：wsdl 与 soap协议详解 , 对XML或者HTML稍微有点了解看了这篇文章之后对WSDL基本都能大体了解了，这里也感谢一下作者。 假定现在你对它们有个大体的了解，SOAP请求就是你发一段XML给后台，然后后台返回数据给你，它是通用的，参数后台会在XML中提取，所以我们在这个过程中其实就是在于传的XML的内容，本文也会讲到中间遇到的一些细节。 首先不要把它想的很复杂，弄通了封装一下，其实这种方式传的东西个人感觉和普通的GET/POST差不多，甚或更方便。WSDL文档由于我现在不在公司连不上服务器所以就不介绍。 开始吧首先XML内容，你的SOAP协议版本要和后台一致，不然后台报错会说版本不一致之类的，这里列出，请自行对比。 SOAP 1.1以下是 SOAP 1.1 请求和响应示例。所显示的占位符需替换为实际值。 请求 12345678910111213141516POST /WebServices/MobileCodeWS.asmx HTTP/1.1Host: webservice.webxml.com.cnContent-Type: text/xml; charset=utf-8Content-Length: lengthSOAPAction: "http://WebXml.com.cn/getMobileCodeInfo"&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;soap:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/"&gt; &lt;soap:Body&gt; &lt;getMobileCodeInfo xmlns="http://WebXml.com.cn/"&gt; &lt;mobileCode&gt;string&lt;/mobileCode&gt; &lt;userID&gt;string&lt;/userID&gt; &lt;/getMobileCodeInfo&gt; &lt;/soap:Body&gt;&lt;/soap:Envelope&gt; 响应 123456789101112HTTP/1.1 200 OKContent-Type: text/xml; charset=utf-8Content-Length: length&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;soap:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/"&gt; &lt;soap:Body&gt; &lt;getMobileCodeInfoResponse xmlns="http://WebXml.com.cn/"&gt; &lt;getMobileCodeInfoResult&gt;string&lt;/getMobileCodeInfoResult&gt; &lt;/getMobileCodeInfoResponse&gt; &lt;/soap:Body&gt;&lt;/soap:Envelope&gt; SOAP 1.2以下是 SOAP 1.2 请求和响应示例。所显示的占位符需替换为实际值。 请求 1234567891011121314POST /WebServices/MobileCodeWS.asmx HTTP/1.1Host: webservice.webxml.com.cnContent-Type: application/soap+xml; charset=utf-8Content-Length: length&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;soap12:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap12="http://www.w3.org/2003/05/soap-envelope"&gt; &lt;soap12:Body&gt; &lt;getMobileCodeInfo xmlns="http://WebXml.com.cn/"&gt; &lt;mobileCode&gt;string&lt;/mobileCode&gt; &lt;userID&gt;string&lt;/userID&gt; &lt;/getMobileCodeInfo&gt; &lt;/soap12:Body&gt;&lt;/soap12:Envelope&gt; 响应 123456789101112HTTP/1.1 200 OKContent-Type: application/soap+xml; charset=utf-8Content-Length: length&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;soap12:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap12="http://www.w3.org/2003/05/soap-envelope"&gt; &lt;soap12:Body&gt; &lt;getMobileCodeInfoResponse xmlns="http://WebXml.com.cn/"&gt; &lt;getMobileCodeInfoResult&gt;string&lt;/getMobileCodeInfoResult&gt; &lt;/getMobileCodeInfoResponse&gt; &lt;/soap12:Body&gt;&lt;/soap12:Envelope&gt; 注意点直接说注意点，拿SOAP 1.1 请求做例子，要传的XML文档为: 123456789&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;soap:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/"&gt; &lt;soap:Body&gt; &lt;getMobileCodeInfo xmlns="http://WebXml.com.cn/"&gt; &lt;mobileCode&gt;string&lt;/mobileCode&gt; &lt;userID&gt;string&lt;/userID&gt; &lt;/getMobileCodeInfo&gt; &lt;/soap:Body&gt;&lt;/soap:Envelope&gt; &lt;soap: Body&gt; 标签以外的不用改，head一般也不用传，要调用的方法和参数都包在body里面，比如这个例子中， getMobileCodeInfo 是WSDL文档发布的你要调用的方法名，其后接的xmlns是你wsdl文档中对应的 targetNameSpace ，这个和你JAVA中的 package 名对应，比如你后台JAVA代码中该方法中import的package为 com.xxxx.oooo 那么这里的xmlns就是 ooo.xxxx.com ，mobileCode和userID是这个方法中接收的参数名，那么也就是说该方法在其JAVA后台大概是这个样子 1public getMobileCodeInfo (@WebParam(name="mobileCode" , name="userID") String mobileCode, String userID) 对应的WSDL中该operation的input下也应该有两个name就是mobileCode和userID，注意@WebParam(name=”mobileCode” , name=”userID”) 不能少，这个注解让后台认识参数名，少了后台会一直报unexpected element ，我们后台一开始就少了这个，搞了很久。这种情况是参数分开传的情况，有的后台的参数直接一个request，但是里面包含有几个键值对也其实就是相当于几个参数，刚接触的新手在这里很容易绕弯，比如我后台有这个个方法 public login (WebParam(name=”req” ) String req) ，很明显这里只接一个参数，而且叫做req，但是这个请求就是需要账户名和密码，所以在对应的xml中文档应这样写body中内容 12345&lt;soap12:Body&gt; &lt;login xmlns="http://WebXml.com.cn/"&gt; &lt;req&gt;&#123;@"userNameKey": zhangsan, @"password": pwdpwd&#125;&lt;/req&gt; &lt;/login&gt;&lt;/soap12:Body&gt; NSURLSession请求soap最后请求地址就是你的wsdl文档中的Endpoint address地址，请求体就是该XML，发个POST请求就完事啦，这里又有事了，本人是强迫症，因为一开始就用的AFN请求，咋请求咋报错，于是跟着网上找的DEMO换NSURLConnection，一不小心成功了一次，但是这个iOS已经废弃了不喜欢，于是用NSURLSession，恩也成功了，但是还是感觉好麻烦，发个NSURLSession请求soap的代码: 1234567891011121314151617181920212223242526272829303132333435363738394041 NSString *soapStr = [NSString stringWithFormat:@"&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\ &lt;soap:Envelope xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\"\ xmlns:soap=\"http://schemas.xmlsoap.org/soap/envelope/\"&gt;\ &lt;soap:Header&gt;\ &lt;/soap:Header&gt;\ &lt;soap:Body&gt;\ &lt;login xmlns=\"targetNameSpace地址/\"&gt;\ &lt;param1&gt;test&lt;/param1&gt;\ &lt;param2&gt;test&lt;/param2&gt;\ &lt;/login&gt;\ &lt;/soap:Body&gt;\ &lt;/soap:Envelope&gt;"]; NSURL *url=[NSURL URLWithString:@"你自己wsdl文档中对应的endpoint address"]; NSMutableURLRequest *request=[NSMutableURLRequest requestWithURL:url]; // 访问方式 [request setHTTPMethod:@"POST"]; // 设置请求头(请求头也可以不设置，前两个设不设置都一样，应该默认的，但是SOAPAction我怎么都设置不对，不设置也可以，干脆不设置了) // [request addValue:@"text/xml; charset=utf-8" forHTTPHeaderField:@"Content-Type"];// [request addValue:[NSString stringWithFormat:@"%zd", soapStr.length] forHTTPHeaderField:@"Content-Length"]; // [request addValue:@"nameSpace/methodName" forHTTPHeaderField:@"SOAPAction"]; // body内容 [request setHTTPBody:[soapStr dataUsingEncoding:NSUTF8StringEncoding]]; NSURLSession *session = [NSURLSession sharedSession]; NSURLSessionDataTask *task = [session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123; NSString *result = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding]; WJLog(@"进入成功回调Session-----结果：%@----请求地址：%@", result, response.URL); if (error) &#123; WJLog(@"Session----失败----%@", error.localizedDescription); &#125; &#125;]; [task resume]; AFHTTPRequestOperation 请求经过和后台七改八改都无果，我干脆自己了解这些文档规范，在上午确定我操作没错之后，直接说后台那边有问题，然后后台改，重启服务器我请求没有任何进展，最后竟然是什么问题你们知道么。。前一天其实我已经传对了XML，只是后台改动的代码放错了地方，只放到了正式服没有放测试服，我也是，，，醉了，，不过也好，要是那么顺畅我就不会去过多了解这方面了。好了，要传什么，注意点都讲了，现在到了客户端的问题，用官方SDK请求是不是感觉很麻烦？是的，对于用惯了AFN或者自己封装的网络请求工具类的人来说如果每次都要写这多么代码发一次请求太痛苦了，于是我想可不可以用AFN请求SOAP，一开始想用manager发请求，直接把XML当params发POST肯定是直接挂了，于是想要设置HTTPBody要不用AFHTTPRequestOperation？没错这样确实可以，代码如下： 1234567891011121314151617NSMutableURLRequest *request=[NSMutableURLRequest requestWithURL:url]; [request setHTTPMethod:@"POST"]; [request setHTTPBody:[soapStr dataUsingEncoding:NSUTF8StringEncoding]]; AFHTTPRequestOperation *operation = [[AFHTTPRequestOperation alloc] initWithRequest:request]; // 设置返回数据格式 operation.responseSerializer = [AFHTTPResponseSerializer serializer]; [operation setCompletionBlockWithSuccess:^(AFHTTPRequestOperation * _Nonnull operation, id _Nonnull responseObject) &#123; NSString *result = [[NSString alloc] initWithData:responseObject encoding:NSUTF8StringEncoding]; WJLog(@"AFN--成功--结果：%@----返回数据%@", result, responseObject); &#125; failure:^(AFHTTPRequestOperation * _Nonnull operation, NSError * _Nonnull error) &#123; WJLog(@"AFN--失败--%@", error.localizedDescription); &#125;]; [operation start]; 这一看感觉和NSURLSession没多大差别，还是想用manager，关键问题就在于设置request的HTTBbody为XML，但是AFHTTPSessionManager已经把request封装了，默认用的params，怎么改？于是想改动或者添加AFN内部方法，但是总感觉这样不好，万一更新库了又要搞一遍。于是想能否拦截这个request，或者通过manager.requestSerializer设置HTTPBody，敲set浏览一下没有HTTPBody字眼的，用KVC也不行，那样还是相当于把XML当params传了，伤心绝望之时看到这个方法: 123 [manager.requestSerializer setQueryStringSerializationWithBlock:^NSString *(NSURLRequest *request, NSDictionary *parameters, NSError *__autoreleasing *error) &#123; // &#125;] 简单封装 AFHTTPSessionManager 请求一看里面有request 有 params 高兴了，说不定在这里能拦截，于是直接写 123[manager.requestSerializer setQueryStringSerializationWithBlock:^NSString *(NSURLRequest *request, NSDictionary *parameters, NSError *__autoreleasing *error) &#123; return soapStr;&#125;] 请求成功，happy。接下来另一个问题了，简单封装一下，我收到的是二进制，所以把AFN封装成了个工具类，供大家参考，欢迎提出改进 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/*** 请求SOAP，返回NSData** @param url 请求地址* @param soapBody soap的XML中方法和参数段* @param success 成功block* @param failure 失败block*/+ (void)SOAPData:(NSString *)url soapBody:(NSString *)soapBody success:(void (^)(id responseObject))success failure:(void(^)(NSError *error))failure &#123; NSString *soapStr = [NSString stringWithFormat: @"&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\ &lt;soap:Envelope xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\"\ xmlns:soap=\"http://schemas.xmlsoap.org/soap/envelope/\"&gt;\ &lt;soap:Header&gt;\ &lt;/soap:Header&gt;\ &lt;soap:Body&gt;%@&lt;/soap:Body&gt;\ &lt;/soap:Envelope&gt;",soapBody]; AFHTTPSessionManager *manager = [AFHTTPSessionManager manager]; manager.responseSerializer = [AFXMLParserResponseSerializer serializer]; // 设置请求超时时间 manager.requestSerializer.timeoutInterval = 30; // 返回NSData manager.responseSerializer = [AFHTTPResponseSerializer serializer]; // 设置请求头，也可以不设置 [manager.requestSerializer setValue:@"application/soap+xml; charset=utf-8" forHTTPHeaderField:@"Content-Type"]; [manager.requestSerializer setValue:[NSString stringWithFormat:@"%zd", soapStr.length] forHTTPHeaderField:@"Content-Length"]; // 设置HTTPBody [manager.requestSerializer setQueryStringSerializationWithBlock:^NSString *(NSURLRequest *request, NSDictionary *parameters, NSError *__autoreleasing *error) &#123; return soapStr; &#125;]; [manager POST:url parameters:soapStr success:^(NSURLSessionDataTask * _Nonnull task, id _Nonnull responseObject) &#123; // 把返回的二进制数据转为字符串 NSString *result = [[NSString alloc] initWithData:responseObject encoding:NSUTF8StringEncoding]; // 利用正则表达式取出&lt;return&gt;&lt;/return&gt;之间的字符串 NSRegularExpression *regular = [[NSRegularExpression alloc] initWithPattern:@"(?&lt;=return\\&gt;).*(?=&lt;/return)" options:NSRegularExpressionCaseInsensitive error:nil]; NSDictionary *dict = [NSDictionary dictionary]; for (NSTextCheckingResult *checkingResult in [regular matchesInString:result options:0 range:NSMakeRange(0, result.length)]) &#123; // 得到字典 dict = [NSJSONSerialization JSONObjectWithData:[[result substringWithRange:checkingResult.range] dataUsingEncoding:NSUTF8StringEncoding] options:NSJSONReadingMutableLeaves error:nil]; &#125; // 请求成功并且结果有值把结果传出去 if (success &amp;&amp; dict) &#123; success(dict); &#125; &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123; if (failure) &#123; failure(error); &#125; &#125;];&#125; 原文地址：OC用AFN做Soap请求webService 结束语差不多了，如果有什么问题指正欢迎大家留言。排版真的很丑，大家见谅，洗洗睡了。 Author: CoderJay 如需转载，请注明出处]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>AFN</tag>
        <tag>Soap</tag>
        <tag>WebService</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ASI 和 AFN 区别]]></title>
    <url>%2F2015%2F10%2F06%2FASI-%E5%92%8C-AFN-%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[一 底层实现 AFN的底层基于OC的NSURLConnection和NSURLSession ASI的底层基于纯C语言的CFNetwork框架 ASI的运行性能 高于 AFN 二 对服务器返回的数据处理 ASI没有直接提供对服务器数据处理的方式，直接返回data\string AFN提供了多种对服务器数据处理的方式 JSON处理 XML处理 其他处理 三 监听请求的过程 AFN提供了success和failure两个block来监听请求的过程（只能监听成功和失败） success : 请求成功后调用 failure : 请求失败后调用 ASI提供了3套方案，每一套方案都能监听请求的完整过程（监听请求开始、接收到响应头信息、接受到具体数据、接受完毕、请求失败） 成为代理，遵守协议，实现协议中的代理方法 成为代理，不遵守协议，自定义代理方法 设置block 四 在文件下载和文件上传的使用难易度 AFN 不容易监听下载进度和上传进度 不容易实现断点续传 一般只用来下载不大的文件 ASI 非常容易实现下载和上传 非常容易监听下载进度和上传进度 非常容易实现断点续传 下载或大或小的文件都行 五 ASI提供了更多的实用功能 控制圈圈要不要在请求过程中转 可以轻松地设置请求之间的依赖：每一个请求都是一个 NSOperation 对象 可以统一管理所有请求（还专门提供了一个叫做 ASINetworkQueue 来管理所有的请求对象） 暂停\恢复\取消所有的请求 监听整个队列中所有请求的下载进度和上传进度]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>网络协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OC 千位分隔符格式化数字]]></title>
    <url>%2F2015%2F08%2F16%2FOC-%E5%8D%83%E4%BD%8D%E5%88%86%E9%9A%94%E7%AC%A6%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[工作中总是碰到很多需求，比如金额需要以千位分隔的方式显示，这是OC版本转换方法，其它语言的可参考，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** 转换目标字符串为千位分隔显示 @param digitString 目标字符串 @return 转换结果字符串 */+ (NSString *)groupedThousandsDigitStringWithStr:(NSString *)digitString &#123; // 判断小数部位 NSRange rangeOfPoint = [digitString rangeOfString:@"."]; NSString *pointStr = @""; if (rangeOfPoint.length &gt;= 1) &#123; pointStr = [digitString substringFromIndex:rangeOfPoint.location]; &#125; // 去掉小数部位 digitString = [digitString substringToIndex:rangeOfPoint.location]; // 去掉小数位后长度小于3直接返回原字符 if (digitString.length &lt;= 3) return [digitString stringByAppendingString:pointStr]; NSMutableString *processString = [NSMutableString stringWithString:digitString]; NSInteger location = processString.length - 3; NSMutableArray *processArray = [NSMutableArray array]; while (location &gt;= 0) &#123; NSString *temp = [processString substringWithRange:NSMakeRange(location, 3)]; [processArray addObject:temp]; if (location &lt; 3 &amp;&amp; location &gt; 0) &#123; NSString *t = [processString substringWithRange:NSMakeRange(0, location)]; [processArray addObject:t]; &#125; location -= 3; &#125; NSMutableArray *resultsArray = [NSMutableArray array]; NSInteger k = 0; for (NSString *str in processArray) &#123; k++; NSMutableString *tmp = [NSMutableString stringWithString:str]; if (str.length &gt; 2 &amp;&amp; k &lt; processArray.count ) &#123; [tmp insertString:@"," atIndex:0]; [resultsArray addObject:tmp]; &#125; else &#123; [resultsArray addObject:tmp]; &#125; &#125; NSMutableString *resultString = [NSMutableString string]; for (NSInteger i = resultsArray.count - 1 ; i &gt;= 0; i--) &#123; NSString *tmp = [resultsArray objectAtIndex:i]; [resultString appendString:tmp]; &#125; return [resultString stringByAppendingString:pointStr];&#125;]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>格式化</tag>
        <tag>OC字符串</tag>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu 查看分区内文件及文件夹占用大小]]></title>
    <url>%2F2013%2F04%2F30%2FUbuntu%20%E6%9F%A5%E7%9C%8B%E5%88%86%E5%8C%BA%E5%86%85%E6%96%87%E4%BB%B6%E5%8F%8A%E6%96%87%E4%BB%B6%E5%A4%B9%E5%8D%A0%E7%94%A8%E5%A4%A7%E5%B0%8F%2F</url>
    <content type="text"><![CDATA[查看磁盘占用123456789vanjay@VanJay:~$ df -h文件系统 容量 已用 可用 已用% 挂载点udev 3.9G 0 3.9G 0% /devtmpfs 789M 2.0M 787M 1% /run/dev/sdb5 9.4G 8.0G 926M 90% /tmpfs 3.9G 31M 3.9G 1% /dev/shmtmpfs 5.0M 4.0K 5.0M 1% /run/locktmpfs 3.9G 0 3.9G 0% /sys/fs/cgroup/dev/loop0 88M 88M 0 100% /snap/core/5662 / 分区空间都哪去了？12345678910111213141516171819202122232425262728vanjay@VanJay:~$ sudo du -hsx /* | sort -rh | head -n 4016G /home3.9G /usr2.4G /var792M /lib451M /swapfile252M /opt140M /boot21M /root14M /etc13M /bin12M /sbin2.0M /run132K /tmp40K /snap16K /lost+found8.0K /media4.0K /srv4.0K /mnt4.0K /lib644.0K /cdrom0 /vmlinuz.old0 /vmlinuz0 /sys0 /proc0 /initrd.img.old0 /initrd.img0 /dev home分区被什么占用了？1234vanjay@VanJay:~$ sudo du -hsx /home/* | sort -rh | head -n 357.8G /home/data7.6G /home/vanjay16K /home/lost+found 交互式查看安装库1sudo apt install ncdu 比如查看/分区123456789101112131415161718192021222324252627282930313233ncdu 1.12 ~ Use the arrow keys to navigate, press ? for help--- / ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ 3.9 GiB [##########] /usr 2.4 GiB [###### ] /var 791.2 MiB [# ] /lib 450.6 MiB [# ] swapfile 251.2 MiB [ ] /opt 139.8 MiB [ ] /boot 20.7 MiB [ ] /root 13.7 MiB [ ] /etc 12.3 MiB [ ] /bin 11.3 MiB [ ] /sbin 3.6 MiB [ ] .__deepin.lft 132.0 KiB [ ] /tmp 40.0 KiB [ ] /snape 16.0 KiB [ ] /lost+found 8.0 KiB [ ] /media 4.0 KiB [ ] /lib64e 4.0 KiB [ ] /srve 4.0 KiB [ ] /mnte 4.0 KiB [ ] /cdrom 4.0 KiB [ ] .__deepin.num@ 0.0 B [ ] initrd.img.old@ 0.0 B [ ] initrd.img@ 0.0 B [ ] vmlinuz.old@ 0.0 B [ ] vmlinuz&gt; 0.0 B [ ] /sys&gt; 0.0 B [ ] /run&gt; 0.0 B [ ] /proc&gt; 0.0 B [ ] /home&gt; 0.0 B [ ] /dev Total disk usage: 7.9 GiB Apparent size: 7.8 GiB Items: 209677 可使用方向键逐级查看]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu 开启 ssh 登录]]></title>
    <url>%2F2013%2F04%2F02%2FUbuntu-%E5%BC%80%E5%90%AF-ssh-%E7%99%BB%E5%BD%95%2F</url>
    <content type="text"><![CDATA[电脑多了，总是需要切来切去，工作或者在家里都不止一台电脑，jenkins 构建机、网盘机等，linux 服务机我这用的基本都是 Ubuntu，记录下 Ubuntu 开启 ssh 登录。 查看是否安装了 ssh1ps -e | grep ssh 安装ssh-server服务1sudo apt-get install openssh-server 查看安装的服务1dpkg -l | grep ssh 再次ps -e | grep ssh查看 ssh 是否运行 远程登录测试1ssh user@ip]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Shell</tag>
        <tag>SSH</tag>
      </tags>
  </entry>
</search>
